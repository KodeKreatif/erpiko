diff -Naur include/openssl/cmp.h include-/openssl/cmp.h
--- includeold/openssl/cmp.h	1970-01-01 07:00:00.000000000 +0700
+++ include/openssl/cmp.h	2017-04-20 21:31:22.810582705 +0700
@@ -0,0 +1,1513 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* cmp.h
+ * CMP (RFC 4210) header file for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#ifndef HEADER_CMP_H
+#define HEADER_CMP_H
+
+#include <openssl/ossl_typ.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/safestack.h>
+
+#ifdef HAVE_CURL
+#include <curl/curl.h>
+#endif
+
+#include <openssl/crmf.h>
+
+#define CMP_VERSION 2L
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+
+/* ########################################################################## *
+ * ASN.1 DECLARATIONS
+ * ########################################################################## */
+
+/*
+	 RevAnnContent ::= SEQUENCE {
+		 status				 PKIStatus,
+		 certId				 CertId,
+		 willBeRevokedAt	 GeneralizedTime,
+		 badSinceDate		 GeneralizedTime,
+		 crlDetails			 Extensions  OPTIONAL
+		 -- extra CRL details (e.g., crl number, reason, location, etc.)
+	 }
+ */
+typedef struct cmp_revanncontent_st
+	{
+	ASN1_INTEGER			 *status;
+	CRMF_CERTID				 *certId;
+	ASN1_GENERALIZEDTIME	 *willBeRevokedAt;
+	ASN1_GENERALIZEDTIME	 *badSinceDate;
+	X509_EXTENSIONS			 *crlDetails;
+	} CMP_REVANNCONTENT;
+CMP_REVANNCONTENT *CMP_REVANNCONTENT_new(void);
+void CMP_REVANNCONTENT_free(CMP_REVANNCONTENT *a);
+CMP_REVANNCONTENT *d2i_CMP_REVANNCONTENT(CMP_REVANNCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_REVANNCONTENT(CMP_REVANNCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_REVANNCONTENT_it;
+
+/*
+	 Challenge ::= SEQUENCE {
+		 owf				 AlgorithmIdentifier  OPTIONAL,
+
+		 -- MUST be present in the first Challenge; MAY be omitted in
+		 -- any subsequent Challenge in POPODecKeyChallContent (if
+		 -- omitted, then the owf used in the immediately preceding
+		 -- Challenge is to be used).
+
+		 witness			 OCTET STRING,
+		 -- the result of applying the one-way function (owf) to a
+		 -- randomly-generated INTEGER, A.	[Note that a different
+		 -- INTEGER MUST be used for each Challenge.]
+		 challenge			 OCTET STRING
+		 -- the encryption (under the public key for which the cert.
+		 -- request is being made) of Rand, where Rand is specified as
+		 --   Rand ::= SEQUENCE {
+		 --		 int	  INTEGER,
+		 --		  - the randomly-generated INTEGER A (above)
+		 --		 sender   GeneralName
+		 --		  - the sender's name (as included in PKIHeader)
+		 --   }
+	 }
+ */
+typedef struct cmp_challenge_st
+	{
+	X509_ALGOR		  *owf;
+	ASN1_OCTET_STRING *whitness;
+	ASN1_OCTET_STRING *challenge;
+	} CMP_CHALLENGE;
+CMP_CHALLENGE *CMP_CHALLENGE_new(void);
+void CMP_CHALLENGE_free(CMP_CHALLENGE *a);
+CMP_CHALLENGE *d2i_CMP_CHALLENGE(CMP_CHALLENGE **a, const unsigned char **in, long len);
+int i2d_CMP_CHALLENGE(CMP_CHALLENGE *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CHALLENGE_it;
+DECLARE_STACK_OF(CMP_CHALLENGE)
+
+#if 0
+/* the RFC explicitly allows substituting CMPCertificate with X509:
+ *
+	  CMPCertificate ::= CHOICE {
+		 x509v3PKCert		 Certificate
+	  }
+   -- This syntax, while bits-on-the-wire compatible with the
+   -- standard X.509 definition of "Certificate", allows the
+   -- possibility of future certificate types (such as X.509
+   -- attribute certificates, WAP WTLS certificates, or other kinds
+   -- of certificates) within this certificate management protocol,
+   -- should a need ever arise to support such generality.  Those
+   -- implementations that do not foresee a need to ever support
+   -- other certificate types MAY, if they wish, comment out the
+   -- above structure and "un-comment" the following one prior to
+   -- compiling this ASN.1 module.  (Note that interoperability
+   -- with implementations that don't do this will be unaffected by
+   -- this change.)
+
+   -- CMPCertificate ::= Certificate
+ */
+#define CMP_CMPCERTIFICATE_X509V3PKCERT   0
+typedef struct cmp_cmpcertificate_st
+	{
+	int type;
+	union
+		{
+		X509 *x509v3PKCert;
+		} value;
+	} CMP_CMPCERTIFICATE;
+CMP_CMPCERTIFICATE *CMP_CMPCERTIFICATE_new(void);
+void CMP_CMPCERTIFICATE_free(CMP_CMPCERTIFICATE *a);
+CMP_CMPCERTIFICATE *d2i_CMP_CMPCERTIFICATE(CMP_CMPCERTIFICATE **a, const unsigned char **in, long len);
+int i2d_CMP_CMPCERTIFICATE(CMP_CMPCERTIFICATE *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CMPCERTIFICATE_it;
+DECLARE_STACK_OF(CMP_CMPCERTIFICATE)
+#endif
+
+
+/*
+	 CAKeyUpdAnnContent ::= SEQUENCE {
+		 oldWithNew   CMPCertificate, -- old pub signed with new priv
+		 newWithOld   CMPCertificate, -- new pub signed with old priv
+		 newWithNew   CMPCertificate  -- new pub signed with new priv
+	 }
+ */
+typedef struct cmp_cakeyupdanncontent_st
+	{
+	/* the RFC explicitly allows substituting CMPCertificate with X509 */
+	X509 *oldWithNew;
+	X509 *newWithOld;
+	X509 *newWithNew;
+	} CMP_CAKEYUPDANNCONTENT;
+CMP_CAKEYUPDANNCONTENT *CMP_CAKEYUPDANNCONTENT_new(void);
+void CMP_CAKEYUPDANNCONTENT_free(CMP_CAKEYUPDANNCONTENT *a);
+CMP_CAKEYUPDANNCONTENT *d2i_CMP_CAKEYUPDANNCONTENT(CMP_CAKEYUPDANNCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_CAKEYUPDANNCONTENT(CMP_CAKEYUPDANNCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CAKEYUPDANNCONTENT_it;
+
+/* declared already here as it will be used in CMP_PKIMESSAGE (nested) and infotype and * value*/
+typedef STACK_OF(CMP_PKIMESSAGE) CMP_PKIMESSAGES;
+CMP_PKIMESSAGES *CMP_PKIMESSAGES_new(void);
+void CMP_PKIMESSAGES_free(CMP_PKIMESSAGES *a);
+CMP_PKIMESSAGES *d2i_CMP_PKIMESSAGES(CMP_PKIMESSAGES **a, const unsigned char **in, long len);
+int i2d_CMP_PKIMESSAGES(CMP_PKIMESSAGES *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKIMESSAGES_it;
+
+/* ESS_SIGNING_CERT comes from ts.h, but ESS_SIGNING_CERT_it isn't declared there */
+extern const ASN1_ITEM ESS_SIGNING_CERT_it;
+DECLARE_STACK_OF(ESS_SIGNING_CERT)
+
+/*
+	 InfoTypeAndValue ::= SEQUENCE {
+		 infoType				OBJECT IDENTIFIER,
+		 infoValue				ANY DEFINED BY infoType  OPTIONAL
+	 }
+ */
+typedef struct cmp_infotypeandvalue_st
+	{
+	ASN1_OBJECT *infoType;
+	union
+		{
+		char *ptr;
+		/* NID_id_it_caProtEncCert - CA Protocol Encryption Certificate  */
+		X509 *caProtEncCert;
+		/* NID_id_it_signKeyPairTypes - Signing Key Pair Types	*/
+		STACK_OF(X509_ALGOR) *signKeyPairTypes;
+		/* NID_id_it_encKeyPairTypes - Encryption/Key Agreement Key Pair Types	*/
+		STACK_OF(X509_ALGOR) *encKeyPairTypes;
+		/* NID_id_it_preferredSymmAlg - Preferred Symmetric Algorithm  */
+		X509_ALGOR *preferredSymmAlg;
+		/* NID_id_it_caKeyUpdateInfo - Updated CA Key Pair	*/
+		CMP_CAKEYUPDANNCONTENT *caKeyUpdateInfo;
+		/* NID_id_it_currentCRL - CRL  */
+		X509_CRL *currentCRL;
+		/* NID_id_it_unsupportedOIDs - Unsupported Object Identifiers  */
+		STACK_OF(ASN1_OBJECT) *unsupportedOIDs;
+		/* NID_id_it_keyPairParamReq - Key Pair Parameters Request	*/
+		ASN1_OBJECT *keyPairParamReq;
+		/* NID_id_it_keyPairParamRep - Key Pair Parameters Response  */
+		X509_ALGOR *keyPairParamRep;
+		/* NID_id_it_revPassphrase - Revocation Passphrase	*/
+		CRMF_ENCRYPTEDVALUE *revPassphrase;
+		/* NID_id_it_implicitConfirm - ImplicitConfirm	*/
+		ASN1_NULL *implicitConfirm;
+		/* NID_id_it_confirmWaitTime - ConfirmWaitTime	*/
+		ASN1_GENERALIZEDTIME *confirmWaitTime;
+		/* NID_id_it_origPKIMessage - origPKIMessage  */
+		CMP_PKIMESSAGES *origPKIMessage;
+		/* NID_id_it_suppLangTags - Supported Language Tags */
+		STACK_OF(ASN1_UTF8STRING) *suppLangTagsValue;
+		/* this is to be used for so far undeclared objects */
+		ASN1_TYPE *other;
+		} infoValue;
+	} CMP_INFOTYPEANDVALUE;
+
+CMP_INFOTYPEANDVALUE *CMP_INFOTYPEANDVALUE_new(void);
+void CMP_INFOTYPEANDVALUE_free(CMP_INFOTYPEANDVALUE *a);
+CMP_INFOTYPEANDVALUE *d2i_CMP_INFOTYPEANDVALUE(CMP_INFOTYPEANDVALUE **a, const unsigned char **in, long len);
+int i2d_CMP_INFOTYPEANDVALUE(CMP_INFOTYPEANDVALUE *a, unsigned char **out);
+extern const ASN1_ITEM CMP_INFOTYPEANDVALUE_it;
+
+DECLARE_STACK_OF(CMP_INFOTYPEANDVALUE)
+
+#if 0
+/* TODO: that should be changed to be a real CMP_PKIFREETEXT type? */
+/*
+ PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
+	 -- text encoded as UTF-8 String [RFC3629] (note: each
+	 -- UTF8String MAY include an [RFC3066] language tag
+	 -- to indicate the language of the contained text
+	 -- see [RFC2482] for details)
+ */
+DECLARE_STACK_OF(ASN1_UTF8STRING)
+typedef STACK_OF(ASN1_UTF8STRING) CMP_PKIFREETEXT;
+CMP_PKIFREETEXT *CMP_PKIFREETEXT_new(void);
+void CMP_PKIFREETEXT_free(CMP_PKIFREETEXT *a);
+CMP_PKIFREETEXT *d2i_CMP_PKIFREETEXT(CMP_PKIFREETEXT **a, const unsigned char **in, long len);
+int i2d_CMP_PKIFREETEXT(CMP_PKIFREETEXT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKIFREETEXT_it;
+#endif
+
+/*
+	 PKIFailureInfo ::= BIT STRING {
+	 -- since we can fail in more than one way!
+	 -- More codes may be added in the future if/when required.
+		 badAlg				 (0),
+		 -- unrecognized or unsupported Algorithm Identifier
+		 badMessageCheck	 (1),
+		 -- integrity check failed (e.g., signature did not verify)
+		 badRequest			 (2),
+		 -- transaction not permitted or supported
+		 badTime			 (3),
+		 -- messageTime was not sufficiently close to the system time,
+		 -- as defined by local policy
+		 badCertId			 (4),
+		 -- no certificate could be found matching the provided criteria
+		 badDataFormat		 (5),
+		 -- the data submitted has the wrong format
+		 wrongAuthority		 (6),
+		 -- the authority indicated in the request is different from the
+		 -- one creating the response token
+		 incorrectData		 (7),
+		 -- the requester's data is incorrect (for notary services)
+		 missingTimeStamp	 (8),
+		 -- when the timestamp is missing but should be there
+		 -- (by policy)
+		 badPOP				 (9),
+		 -- the proof-of-possession failed
+		 certRevoked		 (10),
+			-- the certificate has already been revoked
+		 certConfirmed		 (11),
+			-- the certificate has already been confirmed
+		 wrongIntegrity		 (12),
+			-- invalid integrity, password based instead of signature or
+			-- vice versa
+		 badRecipientNonce	 (13),
+			-- invalid recipient nonce, either missing or wrong value
+		 timeNotAvailable	 (14),
+			-- the TSA's time source is not available
+		 unacceptedPolicy	 (15),
+			-- the requested TSA policy is not supported by the TSA.
+		 unacceptedExtension (16),
+			-- the requested extension is not supported by the TSA.
+		 addInfoNotAvailable (17),
+			-- the additional information requested could not be
+			-- understood or is not available
+		 badSenderNonce		 (18),
+			-- invalid sender nonce, either missing or wrong size
+		 badCertTemplate	 (19),
+			-- invalid cert. template or missing mandatory information
+		 signerNotTrusted	 (20),
+			-- signer of the message unknown or not trusted
+		 transactionIdInUse  (21),
+			-- the transaction identifier is already in use
+		 unsupportedVersion  (22),
+			-- the version of the message is not supported
+		 notAuthorized		 (23),
+			-- the sender was not authorized to make the preceding
+			-- request or perform the preceding action
+		 systemUnavail		 (24),
+		 -- the request cannot be handled due to system unavailability
+		 systemFailure		 (25),
+		 -- the request cannot be handled due to system failure
+		 duplicateCertReq	 (26)
+		 -- certificate cannot be issued because a duplicate
+		 -- certificate already exists
+	 }
+	 */
+#define CMP_PKIFAILUREINFO_badAlg				 0
+#define CMP_PKIFAILUREINFO_badMessageCheck		 1
+#define CMP_PKIFAILUREINFO_badRequest			 2
+#define CMP_PKIFAILUREINFO_badTime				 3
+#define CMP_PKIFAILUREINFO_badCertId			 4
+#define CMP_PKIFAILUREINFO_badDataFormat		 5
+#define CMP_PKIFAILUREINFO_wrongAuthority		 6
+#define CMP_PKIFAILUREINFO_incorrectData		 7
+#define CMP_PKIFAILUREINFO_missingTimeStamp		 8
+#define CMP_PKIFAILUREINFO_badPOP				 9
+#define CMP_PKIFAILUREINFO_certRevoked			10
+#define CMP_PKIFAILUREINFO_certConfirmed		11
+#define CMP_PKIFAILUREINFO_wrongIntegrity		12
+#define CMP_PKIFAILUREINFO_badRecipientNonce	13
+#define CMP_PKIFAILUREINFO_timeNotAvailable		14
+#define CMP_PKIFAILUREINFO_unacceptedPolicy		15
+#define CMP_PKIFAILUREINFO_unacceptedExtension	16
+#define CMP_PKIFAILUREINFO_addInfoNotAvailable	17
+#define CMP_PKIFAILUREINFO_badSenderNonce		18
+#define CMP_PKIFAILUREINFO_badCertTemplate		19
+#define CMP_PKIFAILUREINFO_signerNotTrusted		20
+#define CMP_PKIFAILUREINFO_transactionIdInUse	21
+#define CMP_PKIFAILUREINFO_unsupportedVersion	22
+#define CMP_PKIFAILUREINFO_notAuthorized		23
+#define CMP_PKIFAILUREINFO_systemUnavail		24
+#define CMP_PKIFAILUREINFO_systemFailure		25
+#define CMP_PKIFAILUREINFO_duplicateCertReq		26
+#define CMP_PKIFAILUREINFO_MAX					26
+typedef ASN1_BIT_STRING CMP_PKIFAILUREINFO;
+
+#define CMP_CTX_FAILINFO_badAlg				 (1 << 0)
+#define CMP_CTX_FAILINFO_badMessageCheck	 (1 << 1)
+#define CMP_CTX_FAILINFO_badRequest			 (1 << 2)
+#define CMP_CTX_FAILINFO_badTime			 (1 << 3)
+#define CMP_CTX_FAILINFO_badCertId			 (1 << 4)
+#define CMP_CTX_FAILINFO_badDataFormat		 (1 << 5)
+#define CMP_CTX_FAILINFO_wrongAuthority		 (1 << 6)
+#define CMP_CTX_FAILINFO_incorrectData		 (1 << 7)
+#define CMP_CTX_FAILINFO_missingTimeStamp	 (1 << 8)
+#define CMP_CTX_FAILINFO_badPOP				 (1 << 9)
+#define CMP_CTX_FAILINFO_certRevoked		 (1 << 10)
+#define CMP_CTX_FAILINFO_certConfirmed		 (1 << 11)
+#define CMP_CTX_FAILINFO_wrongIntegrity		 (1 << 12)
+#define CMP_CTX_FAILINFO_badRecipientNonce	 (1 << 13)
+#define CMP_CTX_FAILINFO_timeNotAvailable	 (1 << 14)
+#define CMP_CTX_FAILINFO_unacceptedPolicy	 (1 << 15)
+#define CMP_CTX_FAILINFO_unacceptedExtension (1 << 16)
+#define CMP_CTX_FAILINFO_addInfoNotAvailable (1 << 17)
+#define CMP_CTX_FAILINFO_badSenderNonce		 (1 << 18)
+#define CMP_CTX_FAILINFO_badCertTemplate	 (1 << 19)
+#define CMP_CTX_FAILINFO_signerNotTrusted	 (1 << 20)
+#define CMP_CTX_FAILINFO_transactionIdInUse  (1 << 21)
+#define CMP_CTX_FAILINFO_unsupportedVersion  (1 << 22)
+#define CMP_CTX_FAILINFO_notAuthorized		 (1 << 23)
+#define CMP_CTX_FAILINFO_systemUnavail		 (1 << 24)
+#define CMP_CTX_FAILINFO_systemFailure		 (1 << 25)
+#define CMP_CTX_FAILINFO_duplicateCertReq	 (1 << 26)
+
+/*
+	 PKIStatus ::= INTEGER {
+		 accepted				 (0),
+		 -- you got exactly what you asked for
+		 grantedWithMods		(1),
+		 -- you got something like what you asked for; the
+		 -- requester is responsible for ascertaining the differences
+		 rejection				(2),
+		 -- you don't get it, more information elsewhere in the message
+		 waiting				(3),
+		 -- the request body part has not yet been processed; expect to
+		 -- hear more later (note: proper handling of this status
+		 -- response MAY use the polling req/rep PKIMessages specified
+		 -- in Section 5.3.22; alternatively, polling in the underlying
+		 -- transport layer MAY have some utility in this regard)
+		 revocationWarning		(4),
+		 -- this message contains a warning that a revocation is
+		 -- imminent
+		 revocationNotification (5),
+		 -- notification that a revocation has occurred
+		 keyUpdateWarning		(6)
+		 -- update already done for the oldCertId specified in
+		 -- CertReqMsg
+	 }
+	 */
+#define CMP_PKISTATUS_accepted					0
+#define CMP_PKISTATUS_grantedWithMods			1
+#define CMP_PKISTATUS_rejection					2
+#define CMP_PKISTATUS_waiting					3
+#define CMP_PKISTATUS_revocationWarning			4
+#define CMP_PKISTATUS_revocationNotification	5
+#define CMP_PKISTATUS_keyUpdateWarning			6
+
+typedef ASN1_INTEGER CMP_PKISTATUS;
+CMP_PKISTATUS *CMP_PKISTATUS_new(void);
+void CMP_PKISTATUS_free(CMP_PKISTATUS *a);
+CMP_PKISTATUS *d2i_CMP_PKISTATUS(CMP_PKISTATUS **a, const unsigned char **in, long len);
+int i2d_CMP_PKISTATUS(CMP_PKISTATUS *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKISTATUS_it;
+
+/*
+	 CertOrEncCert ::= CHOICE {
+		 certificate	 [0] CMPCertificate,
+		 encryptedCert	 [1] EncryptedValue
+	 }
+ */
+#define CMP_CERTORENCCERT_CERTIFICATE	0
+#define CMP_CERTORENCCERT_ENCRYPTEDCERT 1
+typedef struct cmp_certorenccert_st
+	{
+	int type;
+	union
+		{
+		/* the RFC explicitly allows substituting CMPCertificate with X509 */
+		X509  *certificate;
+		CRMF_ENCRYPTEDVALUE *encryptedCert;
+		} value;
+	} CMP_CERTORENCCERT;
+CMP_CERTORENCCERT *CMP_CERTORENCCERT_new(void);
+void CMP_CERTORENCCERT_free(CMP_CERTORENCCERT *a);
+CMP_CERTORENCCERT *d2i_CMP_CERTORENCCERT(CMP_CERTORENCCERT **a, const unsigned char **in, long len);
+int i2d_CMP_CERTORENCCERT(CMP_CERTORENCCERT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CERTORENCCERT_it;
+
+/*
+	 CertifiedKeyPair ::= SEQUENCE {
+		 certOrEncCert		 CertOrEncCert,
+		 privateKey		 [0] EncryptedValue		 OPTIONAL,
+		 -- see [CRMF] for comment on encoding
+		 publicationInfo [1] PKIPublicationInfo  OPTIONAL
+	 }
+ */
+typedef struct cmp_certifiedkeypair_st
+	{
+	CMP_CERTORENCCERT		*certOrEncCert;
+	CRMF_ENCRYPTEDVALUE		*privateKey;
+	CRMF_PKIPUBLICATIONINFO *failInfo;
+	} CMP_CERTIFIEDKEYPAIR;
+CMP_CERTIFIEDKEYPAIR *CMP_CERTIFIEDKEYPAIR_new(void);
+void CMP_CERTIFIEDKEYPAIR_free(CMP_CERTIFIEDKEYPAIR *a);
+CMP_CERTIFIEDKEYPAIR *d2i_CMP_CERTIFIEDKEYPAIR(CMP_CERTIFIEDKEYPAIR **a, const unsigned char **in, long len);
+int i2d_CMP_CERTIFIEDKEYPAIR(CMP_CERTIFIEDKEYPAIR *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CERTIFIEDKEYPAIR_it;
+
+/*
+	 PKIStatusInfo ::= SEQUENCE {
+		 status		   PKIStatus,
+		 statusString  PKIFreeText	   OPTIONAL,
+		 failInfo	   PKIFailureInfo  OPTIONAL
+	 }
+ */
+typedef struct cmp_pkistatusinfo_st
+	{
+	CMP_PKISTATUS	   *status;
+#if 0
+	CMP_PKIFREETEXT    *statusString;
+#endif
+	STACK_OF(ASN1_UTF8STRING)	 *statusString;
+	CMP_PKIFAILUREINFO *failInfo;
+	} CMP_PKISTATUSINFO;
+CMP_PKISTATUSINFO *CMP_PKISTATUSINFO_new(void);
+void CMP_PKISTATUSINFO_free(CMP_PKISTATUSINFO *a);
+CMP_PKISTATUSINFO *d2i_CMP_PKISTATUSINFO(CMP_PKISTATUSINFO **a, const unsigned char **in, long len);
+int i2d_CMP_PKISTATUSINFO(CMP_PKISTATUSINFO *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKISTATUSINFO_it;
+DECLARE_STACK_OF(CMP_PKISTATUSINFO)
+
+/*
+	 RevReqContent ::= SEQUENCE OF RevDetails
+
+	 RevDetails ::= SEQUENCE {
+		 certDetails		 CertTemplate,
+		 -- allows requester to specify as much as they can about
+		 -- the cert. for which revocation is requested
+		 -- (e.g., for cases in which serialNumber is not available)
+		 crlEntryDetails	 Extensions		  OPTIONAL
+		 -- requested crlEntryExtensions
+	 }
+*/
+typedef struct cmp_revdetails_st
+	{
+	CRMF_CERTTEMPLATE		 *certDetails;
+	X509_EXTENSIONS			 *crlEntryDetails;
+	} CMP_REVDETAILS;
+CMP_REVDETAILS *CMP_REVDETAILS_new(void);
+void CMP_REVDETAILS_free(CMP_REVDETAILS *a);
+CMP_REVDETAILS *d2i_CMP_REVDETAILS(CMP_REVDETAILS **a, const unsigned char **in, long len);
+int i2d_CMP_REVDETAILS(CMP_REVDETAILS *a, unsigned char **out);
+extern const ASN1_ITEM CMP_REVDETAILS_it;
+DECLARE_STACK_OF(CMP_REVDETAILS)
+
+/*
+	 RevRepContent ::= SEQUENCE {
+		 status		  SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+		 -- in same order as was sent in RevReqContent
+		 revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
+											 OPTIONAL,
+		 -- IDs for which revocation was requested
+		 -- (same order as status)
+		 crls	  [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+											 OPTIONAL
+		 -- the resulting CRLs (there may be more than one)
+	 }
+ */
+typedef struct cmp_revrep_st
+	{
+	STACK_OF(CMP_PKISTATUSINFO) *status;
+	STACK_OF(CRMF_CERTID)		*certId;
+	STACK_OF(X509)				*crls;
+	} CMP_REVREPCONTENT;
+CMP_REVREPCONTENT *CMP_REVREPCONTENT_new(void);
+void CMP_REVREPCONTENT_free(CMP_REVREPCONTENT *a);
+CMP_REVREPCONTENT *d2i_CMP_REVREPCONTENT(CMP_REVREPCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_REVREPCONTENT(CMP_REVREPCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_REVREPCONTENT_it;
+
+/*
+	 KeyRecRepContent ::= SEQUENCE {
+		 status					 PKIStatusInfo,
+		 newSigCert			 [0] CMPCertificate OPTIONAL,
+		 caCerts			 [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate OPTIONAL,
+		 keyPairHist		 [2] SEQUENCE SIZE (1..MAX) OF CertifiedKeyPair OPTIONAL
+	 }
+*/
+typedef struct cmp_keyrecrepcontent_st
+	{
+	CMP_PKISTATUSINFO		*status;
+	/* the RFC explicitly allows substituting CMPCertificate with X509 */
+	X509					*newSigCert;
+	STACK_OF(X509)			*caCerts;
+	STACK_OF(CMP_CERTIFIEDKEYPAIR) *keyPairHist;
+	} CMP_KEYRECREPCONTENT;
+CMP_KEYRECREPCONTENT *CMP_KEYRECREPCONTENT_new(void);
+void CMP_KEYRECREPCONTENT_free(CMP_KEYRECREPCONTENT *a);
+CMP_KEYRECREPCONTENT *d2i_CMP_KEYRECREPCONTENT(CMP_KEYRECREPCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_KEYRECREPCONTENT(CMP_KEYRECREPCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_KEYRECREPCONTENT_it;
+
+/*
+	 ErrorMsgContent ::= SEQUENCE {
+		 pKIStatusInfo			PKIStatusInfo,
+		 errorCode				INTEGER			  OPTIONAL,
+		 -- implementation-specific error codes
+		 errorDetails			PKIFreeText		  OPTIONAL
+		 -- implementation-specific error details
+	 }
+ */
+typedef struct cmp_errormsgcontent_st
+	{
+	CMP_PKISTATUSINFO *pKIStatusInfo;
+	ASN1_INTEGER	  *errorCode;
+	STACK_OF(ASN1_UTF8STRING)	*errorDetails;
+#if 0
+	CMP_PKIFREETEXT   *errorDetails;
+#endif
+	} CMP_ERRORMSGCONTENT;
+CMP_ERRORMSGCONTENT *CMP_ERRORMSGCONTENT_new(void);
+void CMP_ERRORMSGCONTENT_free(CMP_ERRORMSGCONTENT *a);
+CMP_ERRORMSGCONTENT *d2i_CMP_ERRORMSGCONTENT(CMP_ERRORMSGCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_ERRORMSGCONTENT(CMP_ERRORMSGCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_ERRORMSGCONTENT_it;
+
+/*
+	 CertConfirmContent ::= SEQUENCE OF CertStatus
+
+	 CertStatus ::= SEQUENCE {
+		certHash	OCTET STRING,
+		-- the hash of the certificate, using the same hash algorithm
+		-- as is used to create and verify the certificate signature
+		certReqId	INTEGER,
+		-- to match this confirmation with the corresponding req/rep
+		statusInfo	PKIStatusInfo OPTIONAL
+	 }
+ */
+typedef struct cmp_certstatus_st
+	{
+	ASN1_OCTET_STRING	*certHash;
+	ASN1_INTEGER		*certReqId;
+	CMP_PKISTATUSINFO	*statusInfo;
+	} CMP_CERTSTATUS;
+DECLARE_STACK_OF(CMP_CERTSTATUS)
+DECLARE_ASN1_SET_OF(CMP_CERTSTATUS)
+CMP_CERTSTATUS *CMP_CERTSTATUS_new(void);
+void CMP_CERTSTATUS_free(CMP_CERTSTATUS *a);
+CMP_CERTSTATUS *d2i_CMP_CERTSTATUS(CMP_CERTSTATUS **a, const unsigned char **in, long len);
+int i2d_CMP_CERTSTATUS(CMP_CERTSTATUS *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CERTSTATUS_it;
+
+typedef STACK_OF(CMP_CERTSTATUS) CMP_CERTCONFIRMCONTENT;
+CMP_CERTCONFIRMCONTENT *CMP_CERTCONFIRMCONTENT_new(void);
+void CMP_CERTCONFIRMCONTENT_free(CMP_CERTCONFIRMCONTENT *a);
+CMP_CERTCONFIRMCONTENT *d2i_CMP_CERTCONFIRMCONTENT(CMP_CERTCONFIRMCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_CERTCONFIRMCONTENT(CMP_CERTCONFIRMCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CERTCONFIRMCONTENT_it;
+
+/*
+	 CertResponse ::= SEQUENCE {
+		 certReqId			 INTEGER,
+		 -- to match this response with corresponding request (a value
+		 -- of -1 is to be used if certReqId is not specified in the
+		 -- corresponding request)
+		 status				 PKIStatusInfo,
+		 certifiedKeyPair	 CertifiedKeyPair	 OPTIONAL,
+		 rspInfo			 OCTET STRING		 OPTIONAL
+		 -- analogous to the id-regInfo-utf8Pairs string defined
+		 -- for regInfo in CertReqMsg [CRMF]
+	 }
+ */
+typedef struct cmp_certresponse_st
+	{
+	ASN1_INTEGER		 *certReqId;
+	CMP_PKISTATUSINFO	 *status;
+	CMP_CERTIFIEDKEYPAIR *certifiedKeyPair;
+	ASN1_OCTET_STRING	 *rspInfo;
+	} CMP_CERTRESPONSE;
+CMP_CERTRESPONSE *CMP_CERTRESPONSE_new(void);
+void CMP_CERTRESPONSE_free(CMP_CERTRESPONSE *a);
+CMP_CERTRESPONSE *d2i_CMP_CERTRESPONSE(CMP_CERTRESPONSE **a, const unsigned char **in, long len);
+int i2d_CMP_CERTRESPONSE(CMP_CERTRESPONSE *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CERTRESPONSE_it;
+DECLARE_STACK_OF(CMP_CERTRESPONSE)
+
+/*
+	 CertRepMessage ::= SEQUENCE {
+		 caPubs		  [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+						  OPTIONAL,
+		 response		  SEQUENCE OF CertResponse
+	 }
+ */
+typedef struct cmp_certrepmessage_st
+	{
+	/* the RFC explicitly allows substituting CMPCertificate with X509 */
+	STACK_OF(X509) *caPubs;
+	STACK_OF(CMP_CERTRESPONSE)	 *response;
+	} CMP_CERTREPMESSAGE;
+CMP_CERTREPMESSAGE *CMP_CERTREPMESSAGE_new(void);
+void CMP_CERTREPMESSAGE_free(CMP_CERTREPMESSAGE *a);
+CMP_CERTREPMESSAGE *d2i_CMP_CERTREPMESSAGE(CMP_CERTREPMESSAGE **a, const unsigned char **in, long len);
+int i2d_CMP_CERTREPMESSAGE(CMP_CERTREPMESSAGE *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CERTREPMESSAGE_it;
+
+/* the following is from RFC 2986 - PKCS #10
+
+Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
+	type	ATTRIBUTE.&id({IOSet}),
+	values	SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
+}
+
+CertificationRequestInfo ::= SEQUENCE {
+	version		  INTEGER { v1(0) } (v1,...),
+	subject		  Name,
+	subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
+	attributes	  [0] Attributes{{ CRIAttributes }}
+}
+
+CertificationRequest ::= SEQUENCE {
+	certificationRequestInfo CertificationRequestInfo,
+	signatureAlgorithm		 AlgorithmIdentifier{{ SignatureAlgorithms }},
+	signature				 BIT STRING
+}
+*/
+typedef struct pkcs10_attribute_st
+	{
+	ASN1_OBJECT			*id;
+	STACK_OF(ASN1_TYPE) *values;
+	} PKCS10_ATTRIBUTE;
+PKCS10_ATTRIBUTE *PKCS10_ATTRIBUTE_new(void);
+void PKCS10_ATTRIBUTE_free(PKCS10_ATTRIBUTE *a);
+PKCS10_ATTRIBUTE *d2i_PKCS10_ATTRIBUTE(PKCS10_ATTRIBUTE **a, const unsigned char **in, long len);
+int i2d_PKCS10_ATTRIBUTE(PKCS10_ATTRIBUTE *a, unsigned char **out);
+extern const ASN1_ITEM PKCS10_ATTRIBUTE_it;
+DECLARE_STACK_OF(PKCS10_ATTRIBUTE)
+
+typedef struct pkcs10_certificationrequestinfo_st
+	{
+	ASN1_INTEGER			   *version;
+	X509_NAME				   *subject;
+	X509_PUBKEY				   *subjectPKInfo;
+	STACK_OF(PKCS10_ATTRIBUTE) attributes;
+	} PKCS10_CERTIFICATIONREQUESTINFO;
+PKCS10_CERTIFICATIONREQUESTINFO *PKCS10_CERTIFICATIONREQUESTINFO_new(void);
+void PKCS10_CERTIFICATIONREQUESTINFO_free(PKCS10_CERTIFICATIONREQUESTINFO *a);
+PKCS10_CERTIFICATIONREQUESTINFO *d2i_PKCS10_CERTIFICATIONREQUESTINFO(PKCS10_CERTIFICATIONREQUESTINFO **a, const unsigned char **in, long len);
+int i2d_PKCS10_CERTIFICATIONREQUESTINFO(PKCS10_CERTIFICATIONREQUESTINFO *a, unsigned char **out);
+extern const ASN1_ITEM PKCS10_CERTIFICATIONREQUESTINFO_it;
+
+typedef struct pkcs10_certificationrequest_st
+	{
+	PKCS10_CERTIFICATIONREQUESTINFO *certificationRequestInfo;
+	X509_ALGOR						*signatureAlgorithm;
+	ASN1_BIT_STRING					*signature;
+	} PKCS10_CERTIFICATIONREQUEST;
+PKCS10_CERTIFICATIONREQUEST *PKCS10_CERTIFICATIONREQUEST_new(void);
+void PKCS10_CERTIFICATIONREQUEST_free(PKCS10_CERTIFICATIONREQUEST *a);
+PKCS10_CERTIFICATIONREQUEST *d2i_PKCS10_CERTIFICATIONREQUEST(PKCS10_CERTIFICATIONREQUEST **a, const unsigned char **in, long len);
+int i2d_PKCS10_CERTIFICATIONREQUEST(PKCS10_CERTIFICATIONREQUEST *a, unsigned char **out);
+extern const ASN1_ITEM PKCS10_CERTIFICATIONREQUEST_it;
+
+/*
+	 PollReqContent ::= SEQUENCE OF SEQUENCE {
+		 certReqId				INTEGER
+	 }
+ */
+typedef struct cmp_pollreq_st
+	{
+	ASN1_INTEGER *certReqId;
+	} CMP_POLLREQ;
+CMP_POLLREQ *CMP_POLLREQ_new(void);
+void CMP_POLLREQ_free(CMP_POLLREQ *a);
+CMP_POLLREQ *d2i_CMP_POLLREQ(CMP_POLLREQ **a, const unsigned char **in, long len);
+int i2d_CMP_POLLREQ(CMP_POLLREQ *a, unsigned char **out);
+extern const ASN1_ITEM CMP_POLLREQ_it;
+DECLARE_STACK_OF(CMP_POLLREQ)
+typedef STACK_OF(CMP_POLLREQ) CMP_POLLREQCONTENT;
+CMP_POLLREQCONTENT *CMP_POLLREQCONTENT_new(void);
+void CMP_POLLREQCONTENT_free(CMP_POLLREQCONTENT *a);
+CMP_POLLREQCONTENT *d2i_CMP_POLLREQCONTENT(CMP_POLLREQCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_POLLREQCONTENT(CMP_POLLREQCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_POLLREQCONTENT_it;
+
+/*
+	 PollRepContent ::= SEQUENCE OF SEQUENCE {
+		 certReqId				INTEGER,
+		 checkAfter				INTEGER,  -- time in seconds
+		 reason					PKIFreeText OPTIONAL
+	 }
+ */
+typedef struct cmp_pollrep_st
+	{
+	ASN1_INTEGER *certReqId;
+	ASN1_INTEGER *checkAfter;
+	STACK_OF(ASN1_UTF8STRING) *reason;
+	} CMP_POLLREP;
+CMP_POLLREP *CMP_POLLREP_new(void);
+void CMP_POLLREP_free(CMP_POLLREP *a);
+CMP_POLLREP *d2i_CMP_POLLREP(CMP_POLLREP **a, const unsigned char **in, long len);
+int i2d_CMP_POLLREP(CMP_POLLREP *a, unsigned char **out);
+extern const ASN1_ITEM CMP_POLLREP_it;
+DECLARE_STACK_OF(CMP_POLLREP)
+typedef STACK_OF(CMP_POLLREP) CMP_POLLREPCONTENT;
+CMP_POLLREPCONTENT *CMP_POLLREPCONTENT_new(void);
+void CMP_POLLREPCONTENT_free(CMP_POLLREPCONTENT *a);
+CMP_POLLREPCONTENT *d2i_CMP_POLLREPCONTENT(CMP_POLLREPCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_POLLREPCONTENT(CMP_POLLREPCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_POLLREPCONTENT_it;
+
+/*
+	 PKIHeader ::= SEQUENCE {
+		 pvno				 INTEGER	 { cmp1999(1), cmp2000(2) },
+		 sender				 GeneralName,
+		 -- identifies the sender
+		 recipient			 GeneralName,
+		 -- identifies the intended recipient
+		 messageTime	 [0] GeneralizedTime		 OPTIONAL,
+		 -- time of production of this message (used when sender
+		 -- believes that the transport will be "suitable"; i.e.,
+		 -- that the time will still be meaningful upon receipt)
+		 protectionAlg	 [1] AlgorithmIdentifier	 OPTIONAL,
+		 -- algorithm used for calculation of protection bits
+		 senderKID		 [2] KeyIdentifier			 OPTIONAL,
+		 recipKID		 [3] KeyIdentifier			 OPTIONAL,
+		 -- to identify specific keys used for protection
+		 transactionID	 [4] OCTET STRING			 OPTIONAL,
+		 -- identifies the transaction; i.e., this will be the same in
+		 -- corresponding request, response, certConf, and PKIConf
+		 -- messages
+		 senderNonce	 [5] OCTET STRING			 OPTIONAL,
+		 recipNonce		 [6] OCTET STRING			 OPTIONAL,
+		 -- nonces used to provide replay protection, senderNonce
+		 -- is inserted by the creator of this message; recipNonce
+		 -- is a nonce previously inserted in a related message by
+		 -- the intended recipient of this message
+		 freeText		 [7] PKIFreeText			 OPTIONAL,
+		 -- this may be used to indicate context-specific instructions
+		 -- (this field is intended for human consumption)
+		 generalInfo	 [8] SEQUENCE SIZE (1..MAX) OF
+								InfoTypeAndValue	 OPTIONAL
+		 -- this may be used to convey context-specific information
+		 -- (this field not primarily intended for human consumption)
+	 }
+*/
+typedef struct cmp_pkiheader_st
+	{
+	ASN1_INTEGER				  *pvno;
+	GENERAL_NAME				  *sender;
+	GENERAL_NAME				  *recipient;
+	ASN1_GENERALIZEDTIME		  *messageTime;    /* 0 */
+	X509_ALGOR					  *protectionAlg;  /* 1 */
+	ASN1_OCTET_STRING			  *senderKID;	   /* 2 */
+	ASN1_OCTET_STRING			  *recipKID;	   /* 3 */
+	ASN1_OCTET_STRING			  *transactionID;  /* 4 */
+	ASN1_OCTET_STRING			  *senderNonce;    /* 5 */
+	ASN1_OCTET_STRING			  *recipNonce;	   /* 6 */
+	STACK_OF(ASN1_UTF8STRING)	  *freeText;	   /* 7 */
+	STACK_OF(CMP_INFOTYPEANDVALUE) *generalInfo;	/* 8 */
+	} CMP_PKIHEADER;
+CMP_PKIHEADER *CMP_PKIHEADER_new(void);
+void CMP_PKIHEADER_free(CMP_PKIHEADER *a);
+CMP_PKIHEADER *d2i_CMP_PKIHEADER(CMP_PKIHEADER **a, const unsigned char **in, long len);
+int i2d_CMP_PKIHEADER(CMP_PKIHEADER *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKIHEADER_it;
+
+#define V_CMP_PKIBODY_IR	0
+#define V_CMP_PKIBODY_IP	1
+#define V_CMP_PKIBODY_CR	2
+#define V_CMP_PKIBODY_CP	3
+#define V_CMP_PKIBODY_P10CR	4
+#define V_CMP_PKIBODY_POPDECC	5
+#define V_CMP_PKIBODY_POPDECR	6
+#define V_CMP_PKIBODY_KUR	7
+#define V_CMP_PKIBODY_KUP	8
+#define V_CMP_PKIBODY_KRR	9
+#define V_CMP_PKIBODY_KRP	10
+#define V_CMP_PKIBODY_RR	11
+#define V_CMP_PKIBODY_RP	12
+#define V_CMP_PKIBODY_CCR	13
+#define V_CMP_PKIBODY_CCP	14
+#define V_CMP_PKIBODY_CKUANN	15
+#define V_CMP_PKIBODY_CANN	16
+#define V_CMP_PKIBODY_RANN	17
+#define V_CMP_PKIBODY_CRLANN	18
+#define V_CMP_PKIBODY_PKICONF	19
+#define V_CMP_PKIBODY_NESTED	20
+#define V_CMP_PKIBODY_GENM	21
+#define V_CMP_PKIBODY_GENP	22
+#define V_CMP_PKIBODY_ERROR	23
+#define V_CMP_PKIBODY_CERTCONF	24
+#define V_CMP_PKIBODY_POLLREQ	25
+#define V_CMP_PKIBODY_POLLREP	26
+
+typedef STACK_OF(CMP_CHALLENGE) CMP_POPODECKEYCHALLCONTENT;
+CMP_POPODECKEYCHALLCONTENT *CMP_POPODECKEYCHALLCONTENT_new(void);
+void CMP_POPODECKEYCHALLCONTENT_free(CMP_POPODECKEYCHALLCONTENT *a);
+CMP_POPODECKEYCHALLCONTENT *d2i_CMP_POPODECKEYCHALLCONTENT(CMP_POPODECKEYCHALLCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_POPODECKEYCHALLCONTENT(CMP_POPODECKEYCHALLCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_POPODECKEYCHALLCONTENT_it;
+
+typedef STACK_OF(ASN1_INTEGER) CMP_POPODECKEYRESPCONTENT;
+CMP_POPODECKEYRESPCONTENT *CMP_POPODECKEYRESPCONTENT_new(void);
+void CMP_POPODECKEYRESPCONTENT_free(CMP_POPODECKEYRESPCONTENT *a);
+CMP_POPODECKEYRESPCONTENT *d2i_CMP_POPODECKEYRESPCONTENT(CMP_POPODECKEYRESPCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_POPODECKEYRESPCONTENT(CMP_POPODECKEYRESPCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_POPODECKEYRESPCONTENT_it;
+
+typedef STACK_OF(CMP_REVDETAILS) CMP_REVREQCONTENT;
+CMP_REVREQCONTENT *CMP_REVREQCONTENT_new(void);
+void CMP_REVREQCONTENT_free(CMP_REVREQCONTENT *a);
+CMP_REVREQCONTENT *d2i_CMP_REVREQCONTENT(CMP_REVREQCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_REVREQCONTENT(CMP_REVREQCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_REVREQCONTENT_it;
+
+typedef STACK_OF(X509_CRL) CMP_CRLANNCONTENT;
+CMP_CRLANNCONTENT *CMP_CRLANNCONTENT_new(void);
+void CMP_CRLANNCONTENT_free(CMP_CRLANNCONTENT *a);
+CMP_CRLANNCONTENT *d2i_CMP_CRLANNCONTENT(CMP_CRLANNCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_CRLANNCONTENT(CMP_CRLANNCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CRLANNCONTENT_it;
+
+typedef STACK_OF(CMP_INFOTYPEANDVALUE) CMP_GENMSGCONTENT;
+CMP_GENMSGCONTENT *CMP_GENMSGCONTENT_new(void);
+void CMP_GENMSGCONTENT_free(CMP_GENMSGCONTENT *a);
+CMP_GENMSGCONTENT *d2i_CMP_GENMSGCONTENT(CMP_GENMSGCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_GENMSGCONTENT(CMP_GENMSGCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_GENMSGCONTENT_it;
+
+typedef STACK_OF(CMP_INFOTYPEANDVALUE) CMP_GENREPCONTENT;
+CMP_GENREPCONTENT *CMP_GENREPCONTENT_new(void);
+void CMP_GENREPCONTENT_free(CMP_GENREPCONTENT *a);
+CMP_GENREPCONTENT *d2i_CMP_GENREPCONTENT(CMP_GENREPCONTENT **a, const unsigned char **in, long len);
+int i2d_CMP_GENREPCONTENT(CMP_GENREPCONTENT *a, unsigned char **out);
+extern const ASN1_ITEM CMP_GENREPCONTENT_it;
+
+/*
+	 PKIBody ::= CHOICE {		-- message-specific body elements
+		 ir		  [0]  CertReqMessages,		   --Initialization Request
+		 ip		  [1]  CertRepMessage,		   --Initialization Response
+		 cr		  [2]  CertReqMessages,		   --Certification Request
+		 cp		  [3]  CertRepMessage,		   --Certification Response
+		 p10cr	  [4]  CertificationRequest,   --imported from [PKCS10]
+		 popdecc  [5]  POPODecKeyChallContent, --pop Challenge
+		 popdecr  [6]  POPODecKeyRespContent,  --pop Response
+		 kur	  [7]  CertReqMessages,		   --Key Update Request
+		 kup	  [8]  CertRepMessage,		   --Key Update Response
+		 krr	  [9]  CertReqMessages,		   --Key Recovery Request
+		 krp	  [10] KeyRecRepContent,	   --Key Recovery Response
+		 rr		  [11] RevReqContent,		   --Revocation Request
+		 rp		  [12] RevRepContent,		   --Revocation Response
+		 ccr	  [13] CertReqMessages,		   --Cross-Cert. Request
+		 ccp	  [14] CertRepMessage,		   --Cross-Cert. Response
+		 ckuann   [15] CAKeyUpdAnnContent,	   --CA Key Update Ann.
+		 cann	  [16] CertAnnContent,		   --Certificate Ann.
+		 rann	  [17] RevAnnContent,		   --Revocation Ann.
+		 crlann   [18] CRLAnnContent,		   --CRL Announcement
+		 pkiconf  [19] PKIConfirmContent,	   --Confirmation
+		 nested   [20] NestedMessageContent,   --Nested Message
+		 genm	  [21] GenMsgContent,		   --General Message
+		 genp	  [22] GenRepContent,		   --General Response
+		 error	  [23] ErrorMsgContent,		   --Error Message
+		 certConf [24] CertConfirmContent,	   --Certificate confirm
+		 pollReq  [25] PollReqContent,		   --Polling request
+		 pollRep  [26] PollRepContent		   --Polling response
+*/
+typedef struct cmp_pkibody_st
+	{
+	int type;
+	union
+		{
+		CRMF_CERTREQMESSAGES   *ir;   /* 0 */
+		CMP_CERTREPMESSAGE			*ip;   /* 1 */
+		CRMF_CERTREQMESSAGES   *cr;   /* 2 */
+		CMP_CERTREPMESSAGE			*cp;   /* 3 */
+		/* p10cr	[4]  CertificationRequest,	 --imported from [PKCS10] */
+		PKCS10_CERTIFICATIONREQUEST *p10cr;   /* 4 */
+		/* popdecc	[5]  POPODecKeyChallContent, --pop Challenge */
+		/* POPODecKeyChallContent ::= SEQUENCE OF Challenge */
+		CMP_POPODECKEYCHALLCONTENT *popdecc; /* 5 */
+		/* popdecr	[6]  POPODecKeyRespContent,  --pop Response */
+		/* POPODecKeyRespContent ::= SEQUENCE OF INTEGER */
+		CMP_POPODECKEYRESPCONTENT  *popdecr; /* 6 */
+		CRMF_CERTREQMESSAGES   *kur;   /* 7 */
+		CMP_CERTREPMESSAGE			*kup;	/* 8 */
+		CRMF_CERTREQMESSAGES   *krr;   /* 9 */
+
+		/* krp		[10] KeyRecRepContent,		 --Key Recovery Response */
+		CMP_KEYRECREPCONTENT		*krp;	/* 10 */
+		/* rr		[11] RevReqContent,			 --Revocation Request */
+		CMP_REVREQCONTENT	 *rr; /* 11 */
+		/* rp		[12] RevRepContent,			 --Revocation Response */
+		CMP_REVREPCONTENT	*rp; /* 12 */
+		/* ccr		[13] CertReqMessages,		 --Cross-Cert. Request */
+		CRMF_CERTREQMESSAGES   *ccr; /* 13 */
+		/* ccp		[14] CertRepMessage,		 --Cross-Cert. Response */
+		CMP_CERTREPMESSAGE			*ccp; /* 14 */
+		/* ckuann	[15] CAKeyUpdAnnContent,	 --CA Key Update Ann. */
+		CMP_CAKEYUPDANNCONTENT	 *ckuann; /* 15 */
+		/* cann		[16] CertAnnContent,		 --Certificate Ann. */
+		/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+		X509					   *cann; /* 16 */
+		/* rann		[17] RevAnnContent,			 --Revocation Ann. */
+		CMP_REVANNCONTENT		   *rann; /* 17 */
+		/* crlann	[18] CRLAnnContent,			 --CRL Announcement */
+		/* CRLAnnContent ::= SEQUENCE OF CertificateList */
+		CMP_CRLANNCONTENT		  *crlann;
+		/* PKIConfirmContent ::= NULL */
+		/* pkiconf	[19] PKIConfirmContent,		 --Confirmation */
+		/* CMP_PKICONFIRMCONTENT would be only a typedef of ASN1_NULL */
+		/* CMP_CONFIRMCONTENT *pkiconf; */
+		/* NOTE: this should ASN1_NULL according to the RFC but there might be a struct in it when sent from faulty servers... */
+		ASN1_TYPE						*pkiconf; /* 19 */
+		/* nested	[20] NestedMessageContent,	 --Nested Message */
+		/* NestedMessageContent ::= PKIMessages */
+		CMP_PKIMESSAGES				   *nested; /* 20 */
+		/* genm		[21] GenMsgContent,			 --General Message */
+		/* GenMsgContent ::= SEQUENCE OF InfoTypeAndValue */
+		CMP_GENMSGCONTENT *genm; /* 21 */
+		/* genp		[22] GenRepContent,			 --General Response */
+		/* GenRepContent ::= SEQUENCE OF InfoTypeAndValue */
+		CMP_GENREPCONTENT *genp; /* 22 */
+		/* error	[23] ErrorMsgContent,		 --Error Message */
+		CMP_ERRORMSGCONTENT			   *error;	  /* 23 */
+		/* certConf [24] CertConfirmContent,	 --Certificate confirm */
+		CMP_CERTCONFIRMCONTENT		   *certConf; /* 24 */
+		/* pollReq	[25] PollReqContent,		 --Polling request */
+		CMP_POLLREQCONTENT			*pollReq;
+		/* pollRep	[26] PollRepContent			 --Polling response */
+		CMP_POLLREPCONTENT			 *pollRep;
+		} value;
+	} CMP_PKIBODY;
+CMP_PKIBODY *CMP_PKIBODY_new(void);
+void CMP_PKIBODY_free(CMP_PKIBODY *a);
+CMP_PKIBODY *d2i_CMP_PKIBODY(CMP_PKIBODY **a, const unsigned char **in, long len);
+int i2d_CMP_PKIBODY(CMP_PKIBODY *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKIBODY_it;
+
+/*
+	 PKIProtection ::= BIT STRING
+
+	 PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
+
+	  PKIMessage ::= SEQUENCE {
+		 header			  PKIHeader,
+		 body			  PKIBody,
+		 protection   [0] PKIProtection OPTIONAL,
+		 extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+						  OPTIONAL
+	 }
+ */
+typedef struct cmp_pkimessage_st
+	{
+	CMP_PKIHEADER				 *header;
+	CMP_PKIBODY					 *body;
+	ASN1_BIT_STRING				 *protection; /* 0 */
+	/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+	STACK_OF(X509) *extraCerts; /* 1 */
+	} CMP_PKIMESSAGE;
+CMP_PKIMESSAGE *CMP_PKIMESSAGE_new(void);
+void CMP_PKIMESSAGE_free(CMP_PKIMESSAGE *a);
+CMP_PKIMESSAGE *d2i_CMP_PKIMESSAGE(CMP_PKIMESSAGE **a, const unsigned char **in, long len);
+int i2d_CMP_PKIMESSAGE(CMP_PKIMESSAGE *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PKIMESSAGE_it;
+DECLARE_STACK_OF(CMP_PKIMESSAGE) /* PKIMessages */
+
+/*
+	 ProtectedPart ::= SEQUENCE {
+		 header    PKIHeader,
+		 body	   PKIBody
+	 }
+	 */
+typedef struct cmp_protectedpart_st
+	{
+	CMP_PKIHEADER				 *header;
+	CMP_PKIBODY					 *body;
+	} CMP_PROTECTEDPART;
+CMP_PROTECTEDPART *CMP_PROTECTEDPART_new(void);
+void CMP_PROTECTEDPART_free(CMP_PROTECTEDPART *a);
+CMP_PROTECTEDPART *d2i_CMP_PROTECTEDPART(CMP_PROTECTEDPART **a, const unsigned char **in, long len);
+int i2d_CMP_PROTECTEDPART(CMP_PROTECTEDPART *a, unsigned char **out);
+extern const ASN1_ITEM CMP_PROTECTEDPART_it;
+
+/* this is not defined here as it is already in CRMF:
+	 id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
+	 PBMParameter ::= SEQUENCE {
+		 salt				 OCTET STRING,
+		 -- note:  implementations MAY wish to limit acceptable sizes
+		 -- of this string to values appropriate for their environment
+		 -- in order to reduce the risk of denial-of-service attacks
+		 owf				 AlgorithmIdentifier,
+		 -- AlgId for a One-Way Function (SHA-1 recommended)
+		 iterationCount		 INTEGER,
+		 -- number of times the OWF is applied
+		 -- note:  implementations MAY wish to limit acceptable sizes
+		 -- of this integer to values appropriate for their environment
+		 -- in order to reduce the risk of denial-of-service attacks
+		 mac				 AlgorithmIdentifier
+		 -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+	 }	 -- or HMAC [RFC2104, RFC2202])
+ */
+
+/*
+	TODO: this is not yet defined here - but DH is anyway not used yet
+
+	 id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
+	 DHBMParameter ::= SEQUENCE {
+		 owf				 AlgorithmIdentifier,
+		 -- AlgId for a One-Way Function (SHA-1 recommended)
+		 mac				 AlgorithmIdentifier
+		 -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+	 }	 -- or HMAC [RFC2104, RFC2202])
+
+ */
+
+/* The following is not cared for, because it is described in section 5.2.5
+ * that this is beyond the scope of CMP
+	 OOBCert ::= CMPCertificate
+
+	 OOBCertHash ::= SEQUENCE {
+		 hashAlg	 [0] AlgorithmIdentifier	 OPTIONAL,
+		 certId		 [1] CertId					 OPTIONAL,
+		 hashVal		 BIT STRING
+		 -- hashVal is calculated over the DER encoding of the
+		 -- self-signed certificate with the identifier certID.
+	 }
+ */
+
+/* ########################################################################## *
+ * context DECLARATIONS
+ * ########################################################################## */
+
+typedef void (*cmp_logfn_t)(const char *msg);
+typedef int (*cmp_certConfFn_t)(int status, const X509 *cert);
+
+/* this structure is used to store the context for CMP sessions
+ * partly using OpenSSL ASN.1 types in order to ease handling it */
+typedef struct cmp_ctx_st
+	{
+	/* "reference and secret" for MSG_MAC_ALG */
+	ASN1_OCTET_STRING	 *referenceValue;
+	ASN1_OCTET_STRING	 *secretValue;
+	/* for setting itav for EJBCA in CA mode */
+	ASN1_UTF8STRING		 *regToken;
+	/* certificate used to identify the server */
+	X509				 *srvCert;
+	/* current client certificate used to identify and sign for MSG_SIG_ALG */
+	X509				 *clCert;
+	X509				 *oldClCert;
+	/* subject name to be used in the cert template. NB: could also be taken
+	 * from clcert */
+	X509_NAME			 *subjectName;
+	/* to set in recipient in pkiheader */
+	X509_NAME			 *recipient;
+	/* names to be added to the cert template as the subjectAltName extension */
+	STACK_OF(GENERAL_NAME) *subjectAltNames;
+	/* whether or not the subjectAltName extension should be set critical */
+	int                   setSubjectAltNameCritical;
+	/* Stack of CA certificates sent by the CA in a IP message */
+	STACK_OF(X509)		 *caPubs;
+	/* stack of extraCerts to be included when sending a PKI message */
+	STACK_OF(X509)		 *extraCertsOut;
+	/* stack of extraCerts received from remote */
+	STACK_OF(X509)		 *extraCertsIn;
+	/* EVP_PKEY holding the *current* key pair
+	 * Note: this is not an ASN.1 type */
+	EVP_PKEY			 *pkey;
+	/* *new* CLIENT certificate received from the CA
+	 * TODO: this should be a stack since there could be more than one */
+	X509				 *newClCert;
+	/* EVP_PKEY holding the *new* key pair
+	 * Note: this is not an ASN.1 type */
+	EVP_PKEY			 *newPkey;
+	/* the current transaction ID */
+	ASN1_OCTET_STRING	 *transactionID;
+	/* last nonce received */
+	ASN1_OCTET_STRING	 *recipNonce;
+	/* to set implicitConfirm in IR/KUR/CR messges false=0 true!=0 */
+	int	implicitConfirm;
+	/* Proof-of-posession mechanism used. Defaults to signature (POPOsignkingKey) */
+	int	popoMethod;
+	/* maximum time in secods to wait for an http transfer to complete
+	 * Note: only usable with libcurl! */
+	int	HttpTimeOut;
+	/* maximum time to poll the server for a response if a 'waiting' PKIStatus is received */
+	int maxPollTime;
+	/* PKIStatus of last received IP/CP/KUP */
+	/* TODO: this should be a stack since there could be more than one */
+	int lastPKIStatus;
+	/* failInfoCode of last received IP/CP/KUP */
+	/* TODO: this should be a stack since there could be more than one */
+	unsigned long failInfoCode;
+	STACK_OF(ASN1_UTF8STRING) *lastStatusString;
+
+	/* log callback functions for error and debug messages */
+	cmp_logfn_t error_cb, debug_cb;
+
+	/* callback for letting the user check the received certificate and
+	 * reject if necessary */
+	cmp_certConfFn_t certConf_cb;
+
+	/* stores for trusted and untrusted (intermediate) certificates */
+	X509_STORE *trusted_store;
+	X509_STORE *untrusted_store;
+
+	/* include root certs from extracerts when validating? Used for 3GPP-style E.7 */
+	int permitTAInExtraCertsForIR;
+	/* stores the server Cert as soon as it's trust chain has been validated */
+	X509 *validatedSrvCert;
+
+	/* HTTP transfer related settings */
+	char	  *serverName;
+	int		  serverPort;
+	char	  *serverPath;
+	char	  *proxyName;
+	int		  proxyPort;
+	int       lastHTTPCode;
+	int       useTLS;
+	char	  *sourceAddress;
+
+	CERTIFICATEPOLICIES *policies;
+
+	} CMP_CTX;
+
+CMP_CTX *CMP_CTX_new(void);
+void CMP_CTX_free(CMP_CTX *a);
+CMP_CTX *d2i_CMP_CTX(CMP_CTX **a, const unsigned char **in, long len);
+int i2d_CMP_CTX(CMP_CTX *a, unsigned char **out);
+extern const ASN1_ITEM CMP_CTX_it;
+
+/* ########################################################################## *
+ * function DECLARATIONS
+ * ########################################################################## */
+
+/* cmp_msg.c */
+CMP_PKIMESSAGE *CMP_ir_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_cr_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_rr_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_certConf_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_kur_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_genm_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_pollReq_new( CMP_CTX *ctx, int reqId);
+
+/* cmp_lib.c */
+long CMP_REVREPCONTENT_PKIStatus_get(CMP_REVREPCONTENT *revRep, long reqId);
+int CMP_PKIHEADER_set_version(CMP_PKIHEADER *hdr, int version);
+int CMP_PKIHEADER_set1_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+int CMP_PKIHEADER_set1_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+int CMP_PKIHEADER_set1_transactionID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *transactionID);
+int CMP_PKIHEADER_set1_recipNonce(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *recipNonce);
+int CMP_PKIHEADER_set1_senderKID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *senderKID);
+int CMP_PKIHEADER_set_messageTime(CMP_PKIHEADER *hdr);
+int CMP_PKIMESSAGE_set_implicitConfirm(CMP_PKIMESSAGE *msg);
+int CMP_PKIMESSAGE_check_implicitConfirm(CMP_PKIMESSAGE *msg);
+int CMP_PKIHEADER_push0_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text);
+int CMP_PKIHEADER_push1_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text);
+int CMP_PKIHEADER_init(CMP_CTX *ctx, CMP_PKIHEADER *hdr);
+ASN1_BIT_STRING *CMP_calc_protection_pbmac(CMP_PKIMESSAGE *pkimessage, const ASN1_OCTET_STRING *secret);
+int CMP_PKIMESSAGE_protect(CMP_CTX *ctx, CMP_PKIMESSAGE *msg);
+int CMP_CERTSTATUS_set_certHash( CMP_CERTSTATUS *certStatus, const X509 *cert);
+int CMP_PKIHEADER_generalInfo_item_push0(CMP_PKIHEADER *hdr, const CMP_INFOTYPEANDVALUE *itav);
+int CMP_PKIMESSAGE_genm_item_push0(CMP_PKIMESSAGE *msg, const CMP_INFOTYPEANDVALUE *itav);
+int CMP_ITAV_stack_item_push0(STACK_OF(CMP_INFOTYPEANDVALUE) **itav_sk_p, const CMP_INFOTYPEANDVALUE *itav);
+long CMP_PKISTATUSINFO_PKIstatus_get( CMP_PKISTATUSINFO *statusInfo);
+long CMP_CERTREPMESSAGE_PKIStatus_get( CMP_CERTREPMESSAGE *certRep, long certReqId);
+char *CMP_CERTREPMESSAGE_PKIFailureInfoString_get0(CMP_CERTREPMESSAGE *certRep, long certReqId);
+STACK_OF(ASN1_UTF8STRING)* CMP_CERTREPMESSAGE_PKIStatusString_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+CMP_PKIFAILUREINFO *CMP_CERTREPMESSAGE_PKIFailureInfo_get0(CMP_CERTREPMESSAGE *certRep, long certReqId);
+X509 *CMP_CERTREPMESSAGE_get_certificate(CMP_CTX *ctx, CMP_CERTREPMESSAGE *certrep);
+int CMP_PKIFAILUREINFO_check( ASN1_BIT_STRING *failInfo, int codeBit);
+CMP_CERTRESPONSE *CMP_CERTREPMESSAGE_certResponse_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+int CMP_CERTREPMESSAGE_certType_get( CMP_CERTREPMESSAGE *certRep, long certReqId);
+int CMP_PKIMESSAGE_set_bodytype( CMP_PKIMESSAGE *msg, int type);
+int CMP_PKIMESSAGE_get_bodytype( CMP_PKIMESSAGE *msg);
+char *CMP_PKIMESSAGE_parse_error_msg( CMP_PKIMESSAGE *msg, char *errormsg, int bufsize);
+ASN1_OCTET_STRING *CMP_get_cert_subject_key_id(const X509 *cert);
+STACK_OF(X509) *CMP_build_cert_chain(X509_STORE *store, X509 *cert);
+
+/* cmp_vfy.c */
+int CMP_validate_msg(CMP_CTX *ctx, CMP_PKIMESSAGE *msg);
+
+/* from cmp_http.c */
+int CMP_PKIMESSAGE_http_perform(const CMP_CTX *ctx, const CMP_PKIMESSAGE *msg, CMP_PKIMESSAGE **out);
+long CMP_get_http_response_code(const CMP_CTX *ctx);
+
+
+/* from cmp_ses.c */
+X509 *CMP_doInitialRequestSeq(CMP_CTX *ctx);
+X509 *CMP_doCertificateRequestSeq(CMP_CTX *ctx);
+int CMP_doRevocationRequestSeq(CMP_CTX *ctx);
+X509 *CMP_doKeyUpdateRequestSeq(CMP_CTX *ctx);
+STACK_OF(CMP_INFOTYPEANDVALUE) *CMP_doGeneralMessageSeq(CMP_CTX *ctx, int nid, char *value);
+
+/* from cmp_ctx.c */
+CMP_CTX *CMP_CTX_create(void);
+int CMP_CTX_init( CMP_CTX *ctx);
+int CMP_CTX_set0_trustedStore( CMP_CTX *ctx, X509_STORE *store);
+int CMP_CTX_set0_untrustedStore( CMP_CTX *ctx, X509_STORE *store);
+void CMP_CTX_delete(CMP_CTX *ctx);
+int CMP_CTX_set_error_callback( CMP_CTX *ctx, cmp_logfn_t cb);
+int CMP_CTX_set_debug_callback( CMP_CTX *ctx, cmp_logfn_t cb);
+int CMP_CTX_set_certConf_callback( CMP_CTX *ctx, cmp_certConfFn_t cb);
+int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len);
+int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len);
+int CMP_CTX_set1_regToken( CMP_CTX *ctx, const char *regtoken, const size_t len);
+/* for backwards compatibility, TODO: remove asap */
+#define CMP_CTX_set1_caCert CMP_CTX_set1_srvCert
+int CMP_CTX_set1_srvCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set1_oldClCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name);
+int CMP_CTX_set1_recipient( CMP_CTX *ctx, const X509_NAME *name);
+int CMP_CTX_subjectAltName_push1( CMP_CTX *ctx, const GENERAL_NAME *name);
+int CMP_CTX_set1_sender( CMP_CTX *ctx, const X509_NAME *name);
+X509_NAME* CMP_CTX_sender_get( CMP_CTX *ctx);
+STACK_OF(X509)* CMP_CTX_caPubs_get1( CMP_CTX *ctx);
+X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx);
+int CMP_CTX_caPubs_num( CMP_CTX *ctx);
+int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs);
+int CMP_CTX_policyOID_push1( CMP_CTX *ctx, const char *policyOID);
+
+int CMP_CTX_set1_extraCertsOut( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsOut);
+int CMP_CTX_extraCertsOut_push1( CMP_CTX *ctx, const X509 *val);
+int CMP_CTX_extraCertsOut_num( CMP_CTX *ctx);
+STACK_OF(X509)* CMP_CTX_extraCertsIn_get1( CMP_CTX *ctx);
+int CMP_CTX_set1_extraCertsIn( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsIn);
+X509 *CMP_CTX_extraCertsIn_pop( CMP_CTX *ctx);
+int CMP_CTX_extraCertsIn_num( CMP_CTX *ctx);
+int CMP_CTX_loadUntrustedStack(CMP_CTX *ctx, STACK_OF(X509) *stack);
+
+int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id);
+int CMP_CTX_set1_senderNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
+int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
+int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name);
+int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port);
+int CMP_CTX_set1_proxyName( CMP_CTX *ctx, const char *name);
+int CMP_CTX_set1_proxyPort( CMP_CTX *ctx, int port);
+int CMP_CTX_set1_sourceAddress( CMP_CTX *ctx, const char *ip);
+/* for backwards compatibility, TODO: remove asap */
+#define CMP_CTX_set1_timeOut CMP_CTX_set_HttpTimeOut
+int CMP_CTX_set1_timeOut( CMP_CTX *ctx, int time);
+int CMP_CTX_set1_popoMethod( CMP_CTX *ctx, int method);
+int CMP_CTX_set1_serverPath( CMP_CTX *ctx, const char *path);
+int CMP_CTX_set_failInfoCode(CMP_CTX *ctx, CMP_PKIFAILUREINFO *failInfo);
+unsigned long CMP_CTX_failInfoCode_get(CMP_CTX *ctx);
+STACK_OF(ASN1_UTF8STRING) *CMP_CTX_statusString_get( CMP_CTX *ctx);
+#define CMP_CTX_OPT_UNSET                      0
+#define CMP_CTX_OPT_SET                        1
+#define CMP_CTX_OPT_IMPLICITCONFIRM            2
+#define CMP_CTX_OPT_POPMETHOD                  3
+#define CMP_CTX_OPT_MAXPOLLTIME                4
+#define CMP_CTX_PERMIT_TA_IN_EXTRACERTS_FOR_IR 5
+#define CMP_CTX_SET_SUBJECTALTNAME_CRITICAL    6
+#define CMP_CTX_USE_TLS                        7
+int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val);
+#if 0
+int CMP_CTX_push_freeText( CMP_CTX *ctx, const char *text);
+#endif
+
+int CMP_CTX_error_callback(const char *str, size_t len, void *u);
+void CMP_printf(const CMP_CTX *ctx, const char *fmt, ...);
+
+/* BIO definitions */
+#define d2i_CMP_PKIMESSAGE_bio(bp,p) ASN1_d2i_bio_of(CMP_PKIMESSAGE,CMP_PKIMESSAGE_new,d2i_CMP_PKIMESSAGE,bp,p)
+#define i2d_CMP_PKIMESSAGE_bio(bp,o) ASN1_i2d_bio_of(CMP_PKIMESSAGE,i2d_CMP_PKIMESSAGE,bp,o)
+#define d2i_CMP_PROTECTEDPART_bio(bp,p) ASN1_d2i_bio_of(CMP_PROTECTEDPART,CMP_PROTECTEDPART_new,d2i_CMP_PROTECTEDPART,bp,p)
+#define i2d_CMP_PROTECTEDPART_bio(bp,o) ASN1_i2d_bio_of(CMP_PROTECTEDPART,i2d_CMP_PROTECTEDPART,bp,o)
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_CMP_strings(void);
+
+/* Error codes for the CMP functions. */
+
+/* Function codes. */
+#define CMP_F_CMP_CALC_PROTECTION_PBMAC			 100
+#define CMP_F_CMP_CALC_PROTECTION_SIG			 101
+#define CMP_F_CMP_CERTCONF_NEW				 102
+#define CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1		 103
+#define CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE	 104
+#define CMP_F_CMP_CERTREPMESSAGE_PKIFAILUREINFOSTRING_GET0 105
+#define CMP_F_CMP_CERTREPMESSAGE_PKIFAILUREINFO_GET0	 106
+#define CMP_F_CMP_CERTREPMESSAGE_PKISTATUSSTRING_GET0	 107
+#define CMP_F_CMP_CERTREPMESSAGE_PKISTATUS_GET		 108
+#define CMP_F_CMP_CERTSTATUS_SET_CERTHASH		 109
+#define CMP_F_CMP_CR_NEW				 110
+#define CMP_F_CMP_CTX_CAPUBS_GET1			 111
+#define CMP_F_CMP_CTX_CAPUBS_NUM			 112
+#define CMP_F_CMP_CTX_CAPUBS_POP			 113
+#define CMP_F_CMP_CTX_CREATE				 114
+#define CMP_F_CMP_CTX_EXTRACERTSIN_GET1			 115
+#define CMP_F_CMP_CTX_EXTRACERTSIN_NUM			 116
+#define CMP_F_CMP_CTX_EXTRACERTSIN_POP			 117
+#define CMP_F_CMP_CTX_EXTRACERTSOUT_NUM			 118
+#define CMP_F_CMP_CTX_EXTRACERTSOUT_PUSH1		 119
+#define CMP_F_CMP_CTX_INIT				 120
+#define CMP_F_CMP_CTX_SET0_NEWPKEY			 121
+#define CMP_F_CMP_CTX_SET0_PKEY				 122
+#define CMP_F_CMP_CTX_SET1_CAPUBS			 123
+#define CMP_F_CMP_CTX_SET1_CLCERT			 124
+#define CMP_F_CMP_CTX_SET1_EXTRACERTSIN			 125
+#define CMP_F_CMP_CTX_SET1_EXTRACERTSOUT		 126
+#define CMP_F_CMP_CTX_SET1_NEWCLCERT			 127
+#define CMP_F_CMP_CTX_SET1_NEWPKEY			 128
+#define CMP_F_CMP_CTX_SET1_OLDCLCERT			 129
+#define CMP_F_CMP_CTX_SET1_PKEY				 130
+#define CMP_F_CMP_CTX_SET1_POPOMETHOD			 131
+#define CMP_F_CMP_CTX_SET1_PROXYNAME			 132
+#define CMP_F_CMP_CTX_SET1_PROXYPORT			 133
+#define CMP_F_CMP_CTX_SET1_RECIPIENT			 134
+#define CMP_F_CMP_CTX_SET1_RECIPNONCE			 135
+#define CMP_F_CMP_CTX_SET1_REFERENCEVALUE		 136
+#define CMP_F_CMP_CTX_SET1_REGTOKEN			 137
+#define CMP_F_CMP_CTX_SET1_SECRETVALUE			 138
+#define CMP_F_CMP_CTX_SET1_SERVERNAME			 139
+#define CMP_F_CMP_CTX_SET1_SERVERPATH			 140
+#define CMP_F_CMP_CTX_SET1_SERVERPORT			 141
+#define CMP_F_CMP_CTX_SET1_SOURCEADDRESS		 142
+#define CMP_F_CMP_CTX_SET1_SRVCERT			 143
+#define CMP_F_CMP_CTX_SET1_SUBJECTNAME			 144
+#define CMP_F_CMP_CTX_SET1_TRANSACTIONID		 145
+#define CMP_F_CMP_CTX_SET_HTTPTIMEOUT			 146
+#define CMP_F_CMP_CTX_SUBJECTALTNAME_PUSH1		 147
+#define CMP_F_CMP_DOCERTIFICATEREQUESTSEQ		 148
+#define CMP_F_CMP_DOGENERALMESSAGESEQ			 149
+#define CMP_F_CMP_DOINITIALREQUESTSEQ			 150
+#define CMP_F_CMP_DOKEYUPDATEREQUESTSEQ			 151
+#define CMP_F_CMP_DOREVOCATIONREQUESTSEQ		 152
+#define CMP_F_CMP_GENM_NEW				 153
+#define CMP_F_CMP_IR_NEW				 154
+#define CMP_F_CMP_KUR_NEW				 155
+#define CMP_F_CMP_NEW_HTTP_BIO				 156
+#define CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM		 157
+#define CMP_F_CMP_PKIMESSAGE_PARSE_ERROR_MSG		 158
+#define CMP_F_CMP_PKIMESSAGE_PROTECT			 159
+#define CMP_F_CMP_PKISTATUSINFO_PKISTATUS_GET_STRING	 160
+#define CMP_F_CMP_POLLREQ_NEW				 161
+#define CMP_F_CMP_REVREPCONTENT_PKISTATUS_GET		 162
+#define CMP_F_CMP_RR_NEW				 163
+#define CMP_F_CMP_VALIDATE_CERT_PATH			 164
+#define CMP_F_CMP_VALIDATE_MSG				 165
+#define CMP_F_CMP_VERIFY_SIGNATURE			 166
+#define CMP_F_PARSE_HTTP_LINE1				 167
+#define CMP_F_PKEY_DUP					 168
+#define CMP_F_POLLFORRESPONSE				 169
+#define CMP_F_SENDCERTCONF				 170
+
+/* Reason codes. */
+#define CMP_R_ALGORITHM_NOT_SUPPORTED			 100
+#define CMP_R_CERTIFICATE_NOT_FOUND			 101
+#define CMP_R_CP_NOT_RECEIVED				 102
+#define CMP_R_CURL_ERROR				 103
+#define CMP_R_ERROR_CALCULATING_PROTECTION		 104
+#define CMP_R_ERROR_CREATING_CERTCONF			 105
+#define CMP_R_ERROR_CREATING_CR				 106
+#define CMP_R_ERROR_CREATING_GENM			 107
+#define CMP_R_ERROR_CREATING_IR				 108
+#define CMP_R_ERROR_CREATING_KUR			 109
+#define CMP_R_ERROR_CREATING_POLLREQ			 110
+#define CMP_R_ERROR_CREATING_RR				 111
+#define CMP_R_ERROR_DECODING_CERTIFICATE		 112
+#define CMP_R_ERROR_DECRYPTING_CERTIFICATE		 113
+#define CMP_R_ERROR_DECRYPTING_ENCCERT			 114
+#define CMP_R_ERROR_DECRYPTING_KEY			 115
+#define CMP_R_ERROR_DECRYPTING_SYMMETRIC_KEY		 116
+#define CMP_R_ERROR_NONCES_DO_NOT_MATCH			 117
+#define CMP_R_ERROR_PARSING_ERROR_MESSAGE		 118
+#define CMP_R_ERROR_PARSING_PKISTATUS			 119
+#define CMP_R_ERROR_PROTECTING_MESSAGE			 120
+#define CMP_R_ERROR_REQID_NOT_FOUND			 121
+#define CMP_R_ERROR_SETTING_CERTHASH			 122
+#define CMP_R_ERROR_VALIDATING_PROTECTION		 123
+#define CMP_R_FAILED_TO_DECODE_PKIMESSAGE		 124
+#define CMP_R_GENP_NOT_RECEIVED				 125
+#define CMP_R_INVALID_ARGS				 126
+#define CMP_R_INVALID_CONTENT_TYPE			 127
+#define CMP_R_INVALID_CONTEXT				 128
+#define CMP_R_INVALID_KEY				 129
+#define CMP_R_INVALID_PARAMETERS			 130
+#define CMP_R_IP_NOT_RECEIVED				 131
+#define CMP_R_KUP_NOT_RECEIVED				 132
+#define CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION	 133
+#define CMP_R_NO_CERTIFICATE_RECEIVED			 134
+#define CMP_R_NO_SECRET_VALUE_GIVEN_FOR_PBMAC		 135
+#define CMP_R_NO_TRUSTED_CERTIFICATES_SET		 136
+#define CMP_R_NO_VALID_SRVCERT_FOUND			 137
+#define CMP_R_NULL_ARGUMENT				 138
+#define CMP_R_PKIBODY_ERROR				 139
+#define CMP_R_PKICONF_NOT_RECEIVED			 140
+#define CMP_R_POLLREP_NOT_RECEIVED			 141
+#define CMP_R_REQUEST_REJECTED_BY_CA			 142
+#define CMP_R_RP_NOT_RECEIVED				 143
+#define CMP_R_SERVER_NOT_REACHABLE			 144
+#define CMP_R_SERVER_RESPONSE_ERROR			 145
+#define CMP_R_SERVER_RESPONSE_PARSE_ERROR		 146
+#define CMP_R_UNABLE_TO_CREATE_CONTEXT			 147
+#define CMP_R_UNEXPECTED_PKISTATUS			 148
+#define CMP_R_UNKNOWN_ALGORITHM_ID			 149
+#define CMP_R_UNKNOWN_CERTTYPE				 150
+#define CMP_R_UNKNOWN_PKISTATUS				 151
+#define CMP_R_UNSUPPORTED_ALGORITHM			 152
+#define CMP_R_UNSUPPORTED_CIPHER			 153
+#define CMP_R_UNSUPPORTED_KEY_TYPE			 154
+#define CMP_R_UNSUPPORTED_PROTECTION_ALG_DHBASEDMAC	 155
+#define CMP_R_WRONG_ALGORITHM_OID			 156
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Naur include/openssl/crmf.h include-/openssl/crmf.h
--- includeold/openssl/crmf.h	1970-01-01 07:00:00.000000000 +0700
+++ include/openssl/crmf.h	2017-04-20 21:06:52.242653620 +0700
@@ -0,0 +1,714 @@
+/* vim: set cino={1s noet ts=4 sts=4 sw=4: */
+/* crypto/crmf/crmf.h
+ * Header file for CRMF (RFC 4211) for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#ifndef HEADER_CRMF_H
+#define HEADER_CRMF_H
+
+#include <openssl/ossl_typ.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/safestack.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+
+/*
+Attributes ::= SET OF Attribute
+=> X509_ATTRIBUTE
+
+PrivateKeyInfo ::= SEQUENCE {
+   version					 INTEGER,
+   privateKeyAlgorithm		 AlgorithmIdentifier,
+   privateKey				 OCTET STRING,
+   attributes				 [0] IMPLICIT Attributes OPTIONAL
+}
+*/
+typedef struct crmf_privatekeyinfo_st
+	{
+	ASN1_INTEGER			 *version;
+	X509_ALGOR				 *AlgorithmIdentifier;
+	ASN1_OCTET_STRING		 *privateKey;
+	STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */
+	} CRMF_PRIVATEKEYINFO;
+CRMF_PRIVATEKEYINFO *CRMF_PRIVATEKEYINFO_new(void);
+void CRMF_PRIVATEKEYINFO_free(CRMF_PRIVATEKEYINFO *a);
+CRMF_PRIVATEKEYINFO *d2i_CRMF_PRIVATEKEYINFO(CRMF_PRIVATEKEYINFO **a, const unsigned char **in, long len);
+int i2d_CRMF_PRIVATEKEYINFO(CRMF_PRIVATEKEYINFO *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_PRIVATEKEYINFO_it;
+
+
+/* section 4.2.1 Private Key Info Content Type
+   id-ct-encKeyWithID OBJECT IDENTIFIER ::= {id-ct 21}
+
+EncKeyWithID ::= SEQUENCE {
+  privateKey		   PrivateKeyInfo,
+  identifier CHOICE {
+	string			   UTF8String,
+	generalName		   GeneralName
+  } OPTIONAL
+}
+*/
+typedef struct crmf_enckeywithid_identifier_st
+	{
+	int type;
+	union
+		{
+		ASN1_UTF8STRING *string;
+		GENERAL_NAME	*generalName;
+		} value;
+	} CRMF_ENCKEYWITHID_IDENTIFIER;
+	CRMF_ENCKEYWITHID_IDENTIFIER *CRMF_ENCKEYWITHID_IDENTIFIER_new(void);
+void CRMF_ENCKEYWITHID_IDENTIFIER_free(CRMF_ENCKEYWITHID_IDENTIFIER *a);
+CRMF_ENCKEYWITHID_IDENTIFIER *d2i_CRMF_ENCKEYWITHID_IDENTIFIER(CRMF_ENCKEYWITHID_IDENTIFIER **a, const unsigned char **in, long len);
+int i2d_CRMF_ENCKEYWITHID_IDENTIFIER(CRMF_ENCKEYWITHID_IDENTIFIER *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_ENCKEYWITHID_IDENTIFIER_it;
+
+typedef struct crmf_enckeywithid_st
+	{
+	CRMF_PRIVATEKEYINFO			 *privateKey;
+	CRMF_ENCKEYWITHID_IDENTIFIER *identifier; /* [0] */
+	} CRMF_ENCKEYWITHID;
+CRMF_ENCKEYWITHID *CRMF_ENCKEYWITHID_new(void);
+void CRMF_ENCKEYWITHID_free(CRMF_ENCKEYWITHID *a);
+CRMF_ENCKEYWITHID *d2i_CRMF_ENCKEYWITHID(CRMF_ENCKEYWITHID **a, const unsigned char **in, long len);
+int i2d_CRMF_ENCKEYWITHID(CRMF_ENCKEYWITHID *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_ENCKEYWITHID_it;
+
+/*
+CertId ::= SEQUENCE {
+ issuer			  GeneralName,
+ serialNumber	  INTEGER }
+ */
+typedef struct crmf_certid_st
+	{
+	GENERAL_NAME *issuer;
+	ASN1_INTEGER *serialNumber;
+	} CRMF_CERTID;
+CRMF_CERTID *CRMF_CERTID_new(void);
+void CRMF_CERTID_free(CRMF_CERTID *a);
+CRMF_CERTID *d2i_CRMF_CERTID(CRMF_CERTID **a, const unsigned char **in, long len);
+int i2d_CRMF_CERTID(CRMF_CERTID *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_CERTID_it;
+DECLARE_STACK_OF(CRMF_CERTID)
+
+/*
+EncryptedValue ::= SEQUENCE {
+ intendedAlg   [0] AlgorithmIdentifier	OPTIONAL,
+ -- the intended algorithm for which the value will be used
+ symmAlg	   [1] AlgorithmIdentifier	OPTIONAL,
+ -- the symmetric algorithm used to encrypt the value
+ encSymmKey    [2] BIT STRING			OPTIONAL,
+ -- the (encrypted) symmetric key used to encrypt the value
+ keyAlg		   [3] AlgorithmIdentifier	OPTIONAL,
+ -- algorithm used to encrypt the symmetric key
+ valueHint	   [4] OCTET STRING			OPTIONAL,
+ -- a brief description or identifier of the encValue content
+ -- (may be meaningful only to the sending entity, and used only
+ -- if EncryptedValue might be re-examined by the sending entity
+ -- in the future)
+ encValue		BIT STRING }
+ -- the encrypted value itself
+*/
+typedef struct crmf_encrypetedvalue_st
+	{
+	X509_ALGOR				 *intendedAlg; /* 0 */
+	X509_ALGOR				 *symmAlg; /* 1 */
+	ASN1_BIT_STRING			 *encSymmKey; /* 2 */
+	X509_ALGOR				 *keyAlg; /* 3 */
+	ASN1_OCTET_STRING		 *valueHint; /* 4 */
+	ASN1_BIT_STRING			 *encValue;
+	} CRMF_ENCRYPTEDVALUE;
+CRMF_ENCRYPTEDVALUE *CRMF_ENCRYPTEDVALUE_new(void);
+void CRMF_ENCRYPTEDVALUE_free(CRMF_ENCRYPTEDVALUE *a);
+CRMF_ENCRYPTEDVALUE *d2i_CRMF_ENCRYPTEDVALUE(CRMF_ENCRYPTEDVALUE **a, const unsigned char **in, long len);
+int i2d_CRMF_ENCRYPTEDVALUE(CRMF_ENCRYPTEDVALUE *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_ENCRYPTEDVALUE_it;
+
+/*
+EncryptedKey ::= CHOICE {
+ encryptedValue		   EncryptedValue,	 -- Deprecated
+ envelopedData	   [0] EnvelopedData }
+ */
+typedef struct crmf_encryptedkey_st
+	{
+	int type;
+	union
+		{
+		CRMF_ENCRYPTEDVALUE *encryptedValue; /* Deprecated */
+		/* TODO: This is not ASN1_NULL but CMS_ENVELOPEDDATA which should be somehow taken from crypto/cms which exists now - this is not used anywhere so far */
+		ASN1_NULL *envelopedData;
+		} value;
+	} CRMF_ENCRYPTEDKEY;
+CRMF_ENCRYPTEDKEY *CRMF_ENCRYPTEDKEY_new(void);
+void CRMF_ENCRYPTEDKEY_free(CRMF_ENCRYPTEDKEY *a);
+CRMF_ENCRYPTEDKEY *d2i_CRMF_ENCRYPTEDKEY(CRMF_ENCRYPTEDKEY **a, const unsigned char **in, long len);
+int i2d_CRMF_ENCRYPTEDKEY(CRMF_ENCRYPTEDKEY *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_ENCRYPTEDKEY_it;
+
+/*
+PKIArchiveOptions ::= CHOICE {
+ encryptedPrivKey	  [0] EncryptedKey,
+ -- the actual value of the private key
+ keyGenParameters	  [1] KeyGenParameters,
+ -- parameters that allow the private key to be re-generated
+ archiveRemGenPrivKey [2] BOOLEAN }
+ -- set to TRUE if sender wishes receiver to archive the private
+ -- key of a key pair that the receiver generates in response to
+ -- this request; set to FALSE if no archival is desired.
+*/
+typedef struct crmf_pkiarchiveoptions_st
+	{
+	int type;
+	union
+		{
+		CRMF_ENCRYPTEDKEY *encryptedPrivKey; /* 0 */
+		ASN1_OCTET_STRING *keyGenParameters; /* KeyGenParameters ::= OCTET STRING */ /* 1 */
+		ASN1_BOOLEAN	  *archiveRemGenPrivKey; /* 2 */
+		} value;
+	} CRMF_PKIARCHIVEOPTIONS;
+CRMF_PKIARCHIVEOPTIONS *CRMF_PKIARCHIVEOPTIONS_new(void);
+void CRMF_PKIARCHIVEOPTIONS_free(CRMF_PKIARCHIVEOPTIONS *a);
+CRMF_PKIARCHIVEOPTIONS *d2i_CRMF_PKIARCHIVEOPTIONS(CRMF_PKIARCHIVEOPTIONS **a, const unsigned char **in, long len);
+int i2d_CRMF_PKIARCHIVEOPTIONS(CRMF_PKIARCHIVEOPTIONS *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_PKIARCHIVEOPTIONS_it;
+CRMF_PKIARCHIVEOPTIONS *CRMF_PKIARCHIVEOPTIONS_dup( CRMF_PKIARCHIVEOPTIONS *pkiPubInfo);
+
+/*
+SinglePubInfo ::= SEQUENCE {
+ pubMethod	  INTEGER {
+	 dontCare	 (0),
+	 x500		 (1),
+	 web		 (2),
+	 ldap		 (3) },
+ pubLocation  GeneralName OPTIONAL }
+ */
+typedef struct crmf_singlepubinfo_st
+	{
+	ASN1_INTEGER *pubMethod;
+	GENERAL_NAME *pubLocation;
+	} CRMF_SINGLEPUBINFO;
+CRMF_SINGLEPUBINFO *CRMF_SINGLEPUBINFO_new(void);
+void CRMF_SINGLEPUBINFO_free(CRMF_SINGLEPUBINFO *a);
+CRMF_SINGLEPUBINFO *d2i_CRMF_SINGLEPUBINFO(CRMF_SINGLEPUBINFO **a, const unsigned char **in, long len);
+int i2d_CRMF_SINGLEPUBINFO(CRMF_SINGLEPUBINFO *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_SINGLEPUBINFO_it;
+
+/*
+PKIPublicationInfo ::= SEQUENCE {
+action	   INTEGER {
+			 dontPublish (0),
+			 pleasePublish (1) },
+pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
+  -- pubInfos MUST NOT be present if action is "dontPublish"
+  -- (if action is "pleasePublish" and pubInfos is omitted,
+  -- "dontCare" is assumed)
+*/
+typedef struct crmf_pkipublicationinfo_st
+	{
+	ASN1_INTEGER *action;
+	CRMF_SINGLEPUBINFO *pubinfos;
+	} CRMF_PKIPUBLICATIONINFO;
+CRMF_PKIPUBLICATIONINFO *CRMF_PKIPUBLICATIONINFO_new(void);
+void CRMF_PKIPUBLICATIONINFO_free(CRMF_PKIPUBLICATIONINFO *a);
+CRMF_PKIPUBLICATIONINFO *d2i_CRMF_PKIPUBLICATIONINFO(CRMF_PKIPUBLICATIONINFO **a, const unsigned char **in, long len);
+int i2d_CRMF_PKIPUBLICATIONINFO(CRMF_PKIPUBLICATIONINFO *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_PKIPUBLICATIONINFO_it;
+CRMF_PKIPUBLICATIONINFO *CRMF_PKIPUBLICATIONINFO_dup( CRMF_PKIPUBLICATIONINFO *pkiPubInfo);
+
+/*
+PKMACValue ::= SEQUENCE {
+algId  AlgorithmIdentifier,
+-- algorithm value shall be PasswordBasedMac {1 2 840 113533 7 66 13}
+-- parameter value is PBMParameter
+value  BIT STRING }
+*/
+typedef struct crmf_pkmacvalue_st
+	{
+	X509_ALGOR		*algId;
+	ASN1_BIT_STRING *value;
+	} CRMF_PKMACVALUE;
+CRMF_PKMACVALUE *CRMF_PKMACVALUE_new(void);
+void CRMF_PKMACVALUE_free(CRMF_PKMACVALUE *a);
+CRMF_PKMACVALUE *d2i_CRMF_PKMACVALUE(CRMF_PKMACVALUE **a, const unsigned char **in, long len);
+int i2d_CRMF_PKMACVALUE(CRMF_PKMACVALUE *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_PKMACVALUE_it;
+
+/*
+SubsequentMessage ::= INTEGER {
+ encrCert (0),
+ -- requests that resulting certificate be encrypted for the
+ -- end entity (following which, POP will be proven in a
+ -- confirmation message)
+ challengeResp (1) }
+ -- requests that CA engage in challenge-response exchange with
+ -- end entity in order to prove private key possession
+
+POPOPrivKey ::= CHOICE {
+ thisMessage	   [0] BIT STRING,		   -- Deprecated
+ -- possession is proven in this message (which contains the private
+ -- key itself (encrypted for the CA))
+ subsequentMessage [1] SubsequentMessage,
+ -- possession will be proven in a subsequent message
+ dhMAC			   [2] BIT STRING,		   -- Deprecated
+ agreeMAC		   [3] PKMACValue,
+ encryptedKey	   [4] EnvelopedData }
+*/
+#define CRMF_POPOPRIVKEY_THISMESSAGE	   0
+#define CRMF_POPOPRIVKEY_SUBSEQUENTMESSAGE 1
+#define CRMF_POPOPRIVKEY_DHMAC			   2
+#define CRMF_POPOPRIVKEY_AGREEMAC		   3
+#define CRMF_POPOPRIVKEY_ENCRYPTEDKEY	   4
+
+#define CRMF_SUBSEQUENTMESSAGE_ENCRCERT		 0
+#define CRMF_SUBSEQUENTMESSAGE_CHALLENGERESP 1
+
+typedef struct crmf_popoprivkey_st
+	{
+	int type;
+	union
+		{
+		ASN1_BIT_STRING   *thisMessage; /* Deprecated */ /* 0 */
+		ASN1_INTEGER	  *subsequentMessage; /* 1 */
+		ASN1_BIT_STRING   *dhMAC; /* 2 */
+		CRMF_PKMACVALUE   *agreeMAC; /* 3 */
+		/* TODO: This is not ASN1_NULL but CMS_ENVELOPEDDATA which should be somehow taken from crypto/cms which exists now - this is not used anywhere so far */
+		ASN1_NULL		  *encryptedKey; /* 4 */
+		} value;
+	} CRMF_POPOPRIVKEY;
+CRMF_POPOPRIVKEY *CRMF_POPOPRIVKEY_new(void);
+void CRMF_POPOPRIVKEY_free(CRMF_POPOPRIVKEY *a);
+CRMF_POPOPRIVKEY *d2i_CRMF_POPOPRIVKEY(CRMF_POPOPRIVKEY **a, const unsigned char **in, long len);
+int i2d_CRMF_POPOPRIVKEY(CRMF_POPOPRIVKEY *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_POPOPRIVKEY_it;
+
+/*
+PBMParameter ::= SEQUENCE {
+   salt				   OCTET STRING,
+   owf				   AlgorithmIdentifier,
+   -- AlgId for a One-Way Function (SHA-1 recommended)
+   iterationCount	   INTEGER,
+   -- number of times the OWF is applied
+   mac				   AlgorithmIdentifier
+   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+}	-- or HMAC [HMAC, RFC2202])
+*/
+typedef struct crmf_pbmparameter_st
+	{
+	ASN1_OCTET_STRING *salt;
+	X509_ALGOR		  *owf;
+	ASN1_INTEGER	  *iterationCount;
+	X509_ALGOR		  *mac;
+	} CRMF_PBMPARAMETER;
+CRMF_PBMPARAMETER *CRMF_PBMPARAMETER_new(void);
+void CRMF_PBMPARAMETER_free(CRMF_PBMPARAMETER *a);
+CRMF_PBMPARAMETER *d2i_CRMF_PBMPARAMETER(CRMF_PBMPARAMETER **a, const unsigned char **in, long len);
+int i2d_CRMF_PBMPARAMETER(CRMF_PBMPARAMETER *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_PBMPARAMETER_it;
+
+/*
+POPOSigningKeyInput ::= SEQUENCE {
+ authInfo			 CHOICE {
+	 sender				 [0] GeneralName,
+	 -- used only if an authenticated identity has been
+	 -- established for the sender (e.g., a DN from a
+	 -- previously-issued and currently-valid certificate)
+	 publicKeyMAC		 PKMACValue },
+	 -- used if no authenticated GeneralName currently exists for
+	 -- the sender; publicKeyMAC contains a password-based MAC
+	 -- on the DER-encoded value of publicKey
+ publicKey			 SubjectPublicKeyInfo }  -- from CertTemplate
+*/
+typedef struct crmf_poposigningkeyinput_authinfo_st
+	{
+	int type;
+	union
+		{
+		GENERAL_NAME	*sender; /* 0 */
+		CRMF_PKMACVALUE *publicKeyMAC; /* 1 */
+		} value;
+	} CRMF_POPOSIGNINGKEYINPUT_AUTHINFO;
+CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_new(void);
+void CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_free(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *a);
+CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *d2i_CRMF_POPOSIGNINGKEYINPUT_AUTHINFO(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO **a, const unsigned char **in, long len);
+int i2d_CRMF_POPOSIGNINGKEYINPUT_AUTHINFO(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it;
+
+typedef struct crmf_poposigningkeyinput_st
+	{
+	CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *authinfo;
+	X509_PUBKEY *publicKey;
+	} CRMF_POPOSIGNINGKEYINPUT;
+CRMF_POPOSIGNINGKEYINPUT *CRMF_POPOSIGNINGKEYINPUT_new(void);
+void CRMF_POPOSIGNINGKEYINPUT_free(CRMF_POPOSIGNINGKEYINPUT *a);
+CRMF_POPOSIGNINGKEYINPUT *d2i_CRMF_POPOSIGNINGKEYINPUT(CRMF_POPOSIGNINGKEYINPUT **a, const unsigned char **in, long len);
+int i2d_CRMF_POPOSIGNINGKEYINPUT(CRMF_POPOSIGNINGKEYINPUT *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_POPOSIGNINGKEYINPUT_it;
+
+/*
+POPOSigningKey ::= SEQUENCE {
+ poposkInput		   [0] POPOSigningKeyInput OPTIONAL,
+ algorithmIdentifier   AlgorithmIdentifier,
+ signature			   BIT STRING }
+ */
+typedef struct crmf_poposigningkey_st
+	{
+	CRMF_POPOSIGNINGKEYINPUT *poposkInput;
+	X509_ALGOR				 *algorithmIdentifier;
+	ASN1_BIT_STRING			 *signature;
+	} CRMF_POPOSIGNINGKEY;
+CRMF_POPOSIGNINGKEY *CRMF_POPOSIGNINGKEY_new(void);
+void CRMF_POPOSIGNINGKEY_free(CRMF_POPOSIGNINGKEY *a);
+CRMF_POPOSIGNINGKEY *d2i_CRMF_POPOSIGNINGKEY(CRMF_POPOSIGNINGKEY **a, const unsigned char **in, long len);
+int i2d_CRMF_POPOSIGNINGKEY(CRMF_POPOSIGNINGKEY *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_POPOSIGNINGKEY_it;
+
+/*
+ProofOfPossession ::= CHOICE {
+ raVerified		   [0] NULL,
+ -- used if the RA has already verified that the requester is in
+ -- possession of the private key
+ signature		   [1] POPOSigningKey,
+ keyEncipherment   [2] POPOPrivKey,
+ keyAgreement	   [3] POPOPrivKey }
+ */
+#define CRMF_PROOFOFPOSESSION_RAVERIFIED	  0
+#define CRMF_PROOFOFPOSESSION_SIGNATURE		  1
+#define CRMF_PROOFOFPOSESSION_KEYENCIPHERMENT 2
+#define CRMF_PROOFOFPOSESSION_KEYAGREEMENT	  3
+typedef struct crmf_proofofpossesion_st
+	{
+	int type;
+	union
+		{
+		ASN1_NULL			*raVerified; /* 0 */
+		CRMF_POPOSIGNINGKEY *signature;  /* 1 */
+		CRMF_POPOPRIVKEY	*keyEncipherment; /* 2 */
+		CRMF_POPOPRIVKEY	*keyAgreement; /* 3 */
+		} value;
+	} CRMF_PROOFOFPOSSESION;
+CRMF_PROOFOFPOSSESION *CRMF_PROOFOFPOSSESION_new(void);
+void CRMF_PROOFOFPOSSESION_free(CRMF_PROOFOFPOSSESION *a);
+CRMF_PROOFOFPOSSESION *d2i_CRMF_PROOFOFPOSSESION(CRMF_PROOFOFPOSSESION **a, const unsigned char **in, long len);
+int i2d_CRMF_PROOFOFPOSSESION(CRMF_PROOFOFPOSSESION *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_PROOFOFPOSSESION_it;
+
+/*
+OptionalValidity ::= SEQUENCE {
+ notBefore	[0] Time OPTIONAL,
+ notAfter	[1] Time OPTIONAL } -- at least one MUST be present
+ */
+typedef struct crmf_optionalvalidity_st
+	{
+	ASN1_TIME *notBefore; /* 0 */
+	ASN1_TIME *notAfter;  /* 1 */
+	} CRMF_OPTIONALVALIDITY;
+CRMF_OPTIONALVALIDITY *CRMF_OPTIONALVALIDITY_new(void);
+void CRMF_OPTIONALVALIDITY_free(CRMF_OPTIONALVALIDITY *a);
+CRMF_OPTIONALVALIDITY *d2i_CRMF_OPTIONALVALIDITY(CRMF_OPTIONALVALIDITY **a, const unsigned char **in, long len);
+int i2d_CRMF_OPTIONALVALIDITY(CRMF_OPTIONALVALIDITY *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_OPTIONALVALIDITY_it;
+
+/*
+CertTemplate ::= SEQUENCE {
+ version	  [0] Version				OPTIONAL,
+ serialNumber [1] INTEGER				OPTIONAL,
+ signingAlg   [2] AlgorithmIdentifier	OPTIONAL,
+ issuer		  [3] Name					OPTIONAL,
+ validity	  [4] OptionalValidity		OPTIONAL,
+ subject	  [5] Name					OPTIONAL,
+ publicKey	  [6] SubjectPublicKeyInfo	OPTIONAL,
+ issuerUID	  [7] UniqueIdentifier		OPTIONAL,
+ subjectUID   [8] UniqueIdentifier		OPTIONAL,
+ extensions   [9] Extensions			OPTIONAL }
+ */
+
+typedef struct crmf_certtemplate_st
+	{
+	ASN1_INTEGER *version;		 /* 0 */
+	/* serialNumber MUST be omitted.  This field is assigned by the CA
+	 * during certificate creation. */
+	ASN1_INTEGER *serialNumber;  /* 1 */
+	/* signingAlg MUST be omitted.	This field is assigned by the CA
+	 * during certificate creation. */
+	X509_ALGOR	 *signingAlg;	 /* 2 */
+	X509_NAME	 *issuer;		 /* 3 */
+	CRMF_OPTIONALVALIDITY *validity; /* 4 */
+	X509_NAME	 *subject;		 /* 5 */
+	X509_PUBKEY  *publicKey;	 /* 6 */
+	/* According to rfc 3280:
+	   UniqueIdentifier  ::=  BIT STRING
+	*/
+	/* issuerUID is deprecated in version 2 */
+	ASN1_BIT_STRING *issuerUID;  /* 7 */
+	/* subjectUID is deprecated in version 2 */
+	ASN1_BIT_STRING *subjectUID; /* 8 */
+#if 0
+	/* TODO: That should be - but that's only cosmetical */
+	X509_EXTENSIONS	*extensions; /* 9 */
+#endif
+	STACK_OF(X509_EXTENSION)  *extensions; /* 9 */
+	} CRMF_CERTTEMPLATE;
+CRMF_CERTTEMPLATE *CRMF_CERTTEMPLATE_new(void);
+void CRMF_CERTTEMPLATE_free(CRMF_CERTTEMPLATE *a);
+CRMF_CERTTEMPLATE *d2i_CRMF_CERTTEMPLATE(CRMF_CERTTEMPLATE **a, const unsigned char **in, long len);
+int i2d_CRMF_CERTTEMPLATE(CRMF_CERTTEMPLATE *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_CERTTEMPLATE_it;
+
+/*
+CertRequest ::= SEQUENCE {
+ certReqId	   INTEGER,			 -- ID for matching request and reply
+ certTemplate  CertTemplate,  -- Selected fields of cert to be issued
+ controls	   Controls OPTIONAL }	 -- Attributes affecting issuance
+ */
+typedef struct crmf_certrequest_st
+	{
+	ASN1_INTEGER	  *certReqId;
+	CRMF_CERTTEMPLATE *certTemplate;
+	/* TODO: make CRMF_CONTROLS out of that - but only cosmetical */
+	STACK_OF(CRMF_ATTRIBUTETYPEANDVALUE) *controls;
+	} CRMF_CERTREQUEST;
+CRMF_CERTREQUEST *CRMF_CERTREQUEST_new(void);
+void CRMF_CERTREQUEST_free(CRMF_CERTREQUEST *a);
+CRMF_CERTREQUEST *d2i_CRMF_CERTREQUEST(CRMF_CERTREQUEST **a, const unsigned char **in, long len);
+int i2d_CRMF_CERTREQUEST(CRMF_CERTREQUEST *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_CERTREQUEST_it;
+CRMF_CERTREQUEST *CRMF_CERTREQUEST_dup( CRMF_CERTREQUEST *atav);
+
+/* TODO: isn't there a better way to have this for ANY type? */
+typedef struct crmf_attributetypeandvalue_st
+	{
+	ASN1_OBJECT *type;
+	union
+		{
+		/* NID_id_regCtrl_regToken */
+		ASN1_UTF8STRING *regToken;
+
+		/* NID_id_regCtrl_authenticator */
+		ASN1_UTF8STRING *authenticator;
+
+		/* NID_id_regCtrl_pkiPublicationInfo */
+		CRMF_PKIPUBLICATIONINFO *pkiPublicationInfo;
+
+		/* NID_id_regCtrl_pkiArchiveOptions */
+		CRMF_PKIARCHIVEOPTIONS *pkiArchiveOptions;
+
+		/* NID_id_regCtrl_oldCertID */
+		CRMF_CERTID		*oldCertId;
+
+		/* NID_id_regCtrl_protocolEncrKey */
+		X509_PUBKEY		*protocolEncrKey;
+
+		/* NID_id_regInfo_utf8Pairs */
+		ASN1_UTF8STRING *utf8pairs;
+
+		/* NID_id_regInfo_certReq */
+		CRMF_CERTREQUEST *certReq;
+
+		ASN1_TYPE *other;
+		} value;
+	} CRMF_ATTRIBUTETYPEANDVALUE;
+CRMF_ATTRIBUTETYPEANDVALUE *CRMF_ATTRIBUTETYPEANDVALUE_new(void);
+void CRMF_ATTRIBUTETYPEANDVALUE_free(CRMF_ATTRIBUTETYPEANDVALUE *a);
+CRMF_ATTRIBUTETYPEANDVALUE *d2i_CRMF_ATTRIBUTETYPEANDVALUE(CRMF_ATTRIBUTETYPEANDVALUE **a, const unsigned char **in, long len);
+int i2d_CRMF_ATTRIBUTETYPEANDVALUE(CRMF_ATTRIBUTETYPEANDVALUE *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_ATTRIBUTETYPEANDVALUE_it;
+DECLARE_STACK_OF(CRMF_ATTRIBUTETYPEANDVALUE)
+CRMF_ATTRIBUTETYPEANDVALUE *CRMF_ATTRIBUTETYPEANDVALUE_dup( CRMF_ATTRIBUTETYPEANDVALUE *atav);
+
+/*
+CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
+
+CertReqMsg ::= SEQUENCE {
+ certReq   CertRequest,
+ popo		ProofOfPossession  OPTIONAL,
+ -- content depends upon key type
+ regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
+ */
+typedef struct crmf_certreqmsg_st
+	{
+	CRMF_CERTREQUEST		   *certReq;
+	CRMF_PROOFOFPOSSESION	   *popo;	 /* 0 */
+	STACK_OF(CRMF_ATTRIBUTETYPEANDVALUE) *regInfo; /* 1 */
+	} CRMF_CERTREQMSG;
+CRMF_CERTREQMSG *CRMF_CERTREQMSG_new(void);
+void CRMF_CERTREQMSG_free(CRMF_CERTREQMSG *a);
+CRMF_CERTREQMSG *d2i_CRMF_CERTREQMSG(CRMF_CERTREQMSG **a, const unsigned char **in, long len);
+int i2d_CRMF_CERTREQMSG(CRMF_CERTREQMSG *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_CERTREQMSG_it;
+
+typedef STACK_OF(CRMF_CERTREQMSG) CRMF_CERTREQMESSAGES;
+CRMF_CERTREQMESSAGES *CRMF_CERTREQMESSAGES_new(void);
+void CRMF_CERTREQMESSAGES_free(CRMF_CERTREQMESSAGES *a);
+CRMF_CERTREQMESSAGES *d2i_CRMF_CERTREQMESSAGES(CRMF_CERTREQMESSAGES **a, const unsigned char **in, long len);
+int i2d_CRMF_CERTREQMESSAGES(CRMF_CERTREQMESSAGES *a, unsigned char **out);
+extern const ASN1_ITEM CRMF_CERTREQMESSAGES_it;
+
+DECLARE_STACK_OF(CRMF_CERTREQMSG) /* CertReqMessages */
+DECLARE_ASN1_SET_OF(CRMF_CERTREQMSG) /* CertReqMessages */
+
+
+/* ########################################################################## *
+ * function DECLARATIONS
+ * ########################################################################## */
+/* crmf_msg.c */
+CRMF_CERTREQMSG * CRMF_cr_new( const long certReqId, const EVP_PKEY *pkey, const X509_NAME *subject, X509_EXTENSIONS *extensions);
+
+/* crmf_pbm.c */
+CRMF_PBMPARAMETER * CRMF_pbm_new(void);
+int CRMF_passwordBasedMac_new( const CRMF_PBMPARAMETER *pbm, const unsigned char* msg, size_t msgLen, const unsigned char* secret, size_t secretLen, unsigned char** mac, unsigned int* macLen);
+
+/* crmf_lib.c */
+int CRMF_CERTREQMSG_push0_control( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *control);
+int CRMF_CERTREQMSG_set1_control_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok);
+int CRMF_CERTREQMSG_set1_control_authenticator( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *auth);
+int CRMF_CERTREQMSG_push0_regInfo( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *regInfo);
+int CRMF_CERTREQMSG_set1_regInfo_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok);
+
+int CRMF_CERTREQMSG_set_version2( CRMF_CERTREQMSG *certReqMsg);
+int CRMF_CERTREQMSG_set_validity( CRMF_CERTREQMSG *certReqMsg, time_t notBefore, time_t notAfter);
+int CRMF_CERTREQMSG_set_certReqId( CRMF_CERTREQMSG *certReqMsg, const long certReqId);
+int CRMF_CERTREQMSG_set1_publicKey( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey);
+int CRMF_CERTREQMSG_set1_subject( CRMF_CERTREQMSG *certReqMsg, const X509_NAME *subject);
+int CRMF_CERTREQMSG_push0_extension( CRMF_CERTREQMSG *certReqMsg, X509_EXTENSION *ext);
+
+#define CRMF_POPO_NONE		0
+#define CRMF_POPO_SIGNATURE 1
+#define CRMF_POPO_ENCRCERT	2
+#define CRMF_POPO_RAVERIFIED	3
+int CRMF_CERTREQMSG_calc_and_set_popo( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey, int popoMethod);
+
+CRMF_POPOSIGNINGKEY * CRMF_poposigningkey_new( CRMF_CERTREQUEST *certReq, const EVP_PKEY *pkey);
+
+int CRMF_CERTREQMSG_set1_control_oldCertId( CRMF_CERTREQMSG *certReqMsg, X509 *oldCert);
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_CRMF_strings(void);
+
+/* Error codes for the CRMF functions. */
+
+/* Function codes. */
+#define CRMF_F_CRMF_CERTREQMSG_CALC_AND_SET_POPO	 107
+#define CRMF_F_CRMF_CERTREQMSG_PUSH0_CONTROL		 100
+#define CRMF_F_CRMF_CERTREQMSG_PUSH0_EXTENSION		 101
+#define CRMF_F_CRMF_CERTREQMSG_PUSH0_REGINFO		 102
+#define CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_AUTHENTICATOR 121
+#define CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_OLDCERTID	 122
+#define CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PKIARCHIVEOPTIONS 131
+#define CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PKIPUBLICATIONINFO 123
+#define CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PROTOCOLENCRKEY 124
+#define CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_REGTOKEN	 108
+#define CRMF_F_CRMF_CERTREQMSG_SET1_PUBLICKEY		 103
+#define CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_CERTREQ	 125
+#define CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_REGTOKEN	 126
+#define CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_UTF8PAIRS	 127
+#define CRMF_F_CRMF_CERTREQMSG_SET1_SUBJECT		 128
+#define CRMF_F_CRMF_CERTREQMSG_SET_CERTREQID		 129
+#define CRMF_F_CRMF_CERTREQMSG_SET_VALIDITY		 104
+#define CRMF_F_CRMF_CERTREQMSG_SET_VERSION2		 130
+#define CRMF_F_CRMF_CR_NEW				 105
+#define CRMF_F_CRMF_PASSWORDBASEDMAC_NEW		 106
+#define CRMF_F_CRMF_POPOSIGNINGKEY_NEW			 109
+#define CRMF_F_CRMF_SET1_CONTROL_AUTHENTICATOR		 110
+#define CRMF_F_CRMF_SET1_CONTROL_OLDCERTID		 111
+#define CRMF_F_CRMF_SET1_CONTROL_PKIARCHIVEOPTIONS	 112
+#define CRMF_F_CRMF_SET1_CONTROL_PKIPUBLICATIONINFO	 113
+#define CRMF_F_CRMF_SET1_CONTROL_PROTOCOLENCRKEY	 114
+#define CRMF_F_CRMF_SET1_REGINFO_CERTREQ		 115
+#define CRMF_F_CRMF_SET1_REGINFO_UTF8PAIRS		 116
+#define CRMF_F_CRMF_SET1_REGTOKEN_CERTREQ		 117
+#define CRMF_F_CRMF_SET1_SUBJECT			 118
+#define CRMF_F_CRMF_SET_CERTREQID			 119
+#define CRMF_F_CRMF_SET_VERSION2			 120
+
+/* Reason codes. */
+#define CRMF_R_CRMFERROR				 100
+#define CRMF_R_ERROR_CALCULATING_AND_SETTING_POPO	 103
+#define CRMF_R_ERROR_SETTING_CONTROL_AUTHENTICATOR_ATAV	 104
+#define CRMF_R_ERROR_SETTING_CONTROL_OLDCERTID_ATAV	 105
+#define CRMF_R_ERROR_SETTING_CONTROL_PKIARCHIVEOPTIONS_ATAV 106
+#define CRMF_R_ERROR_SETTING_CONTROL_PKIPUBLICATIONINFO_ATAV 107
+#define CRMF_R_ERROR_SETTING_CONTROL_PROTOCOLENCRKEY_ATAV 108
+#define CRMF_R_ERROR_SETTING_POPSIGNINGKEY		 109
+#define CRMF_R_ERROR_SETTING_PUBLIC_KEY			 101
+#define CRMF_R_ERROR_SETTING_REGINFO_CERTREQ_ATAV	 110
+#define CRMF_R_ERROR_SETTING_REGINFO_UTF8PAIRS_ATAV	 111
+#define CRMF_R_ERROR_SETTING_REGTOKEN_ATAV		 112
+#define CRMF_R_ERROR_SETTING_REGTOKEN_CERTREQ_ATAV	 113
+#define CRMF_R_ERROR_SETTING_VERSION_2			 114
+#define CRMF_R_UNSUPPORTED_ALGORITHM			 102
+#define CRMF_R_UNSUPPORTED_ALG_FOR_POPSIGNINGKEY	 115
+#define CRMF_R_UNSUPPORTED_METHOD_FOR_CREATING_POPO	 116
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Naur include/openssl/err.h include-/openssl/err.h
--- includeold/openssl/err.h	2017-04-20 16:15:38.523001201 +0700
+++ include/openssl/err.h	2017-04-20 21:54:06.998967576 +0700
@@ -196,6 +196,8 @@
 #define ERR_LIB_HMAC		48
 #define ERR_LIB_JPAKE		49
 #define ERR_LIB_GOST		50
+#define ERR_LIB_CMP		51
+#define ERR_LIB_CRMF		52
 
 #define ERR_LIB_USER		128
 
@@ -236,6 +238,8 @@
 #define SSLerr(f,r)  ERR_PUT_error(ERR_LIB_SSL,(f),(r),__FILE__,__LINE__)
 #endif
 
+#define CMPerr(f,r) ERR_PUT_error(ERR_LIB_CMP,(f),(r),__FILE__,__LINE__)
+#define CRMFerr(f,r) ERR_PUT_error(ERR_LIB_CRMF,(f),(r),__FILE__,__LINE__)
 #ifdef LIBRESSL_INTERNAL
 #define SYSerror(r)  ERR_PUT_error(ERR_LIB_SYS,(0xfff),(r),__FILE__,__LINE__)
 #define BNerror(r)   ERR_PUT_error(ERR_LIB_BN,(0xfff),(r),__FILE__,__LINE__)
@@ -325,6 +329,8 @@
 #define ERR_R_ECDH_LIB  ERR_LIB_ECDH	 /* 43 */
 #define ERR_R_STORE_LIB ERR_LIB_STORE    /* 44 */
 #define ERR_R_TS_LIB	ERR_LIB_TS       /* 45 */
+#define ERR_R_CMP_LIB	ERR_LIB_CMP      /* 51 */
+#define ERR_R_CRMF_LIB	ERR_LIB_CRMF     /* 52 */
 
 #define ERR_R_NESTED_ASN1_ERROR			58
 #define ERR_R_BAD_ASN1_OBJECT_HEADER		59
diff -Naur include/openssl/safestack.h include-/openssl/safestack.h
--- includeold/openssl/safestack.h	2017-04-20 16:15:38.578999713 +0700
+++ include/openssl/safestack.h	2017-04-20 22:05:23.038813941 +0700
@@ -7,7 +7,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -65,7 +65,7 @@
 
 /* In C++ we get problems because an explicit cast is needed from (void *)
  * we use CHECKED_STACK_OF to ensure the correct type is passed in the macros
- * below. 
+ * below.
  */
 
 #define CHECKED_STACK_OF(type, p) \
@@ -179,6 +179,11 @@
 #define SKM_sk_is_sorted(type, st) \
 	sk_is_sorted(CHECKED_STACK_OF(type, st))
 
+#define	SKM_ASN1_seq_pack(type, st, i2d_func, buf, len) \
+	ASN1_seq_pack(CHECKED_PTR_OF(STACK_OF(type), st), \
+			CHECKED_I2D_OF(type, i2d_func), buf, len)
+
+
 #ifndef LIBRESSL_INTERNAL
 #define	SKM_ASN1_SET_OF_d2i(type, st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
   (STACK_OF(type) *)d2i_ASN1_SET( \
@@ -406,6 +411,318 @@
 #define sk_ASN1_VALUE_sort(st) SKM_sk_sort(ASN1_VALUE, (st))
 #define sk_ASN1_VALUE_is_sorted(st) SKM_sk_is_sorted(ASN1_VALUE, (st))
 
+
+/* CMP */
+
+#define ASN1_seq_pack_GENERAL_NAME(st, i2d_func, buf, len) \
+	SKM_ASN1_seq_pack(GENERAL_NAME, (st), (i2d_func), (buf), (len))
+#define sk_CMP_CERTRESPONSE_new(cmp) SKM_sk_new(CMP_CERTRESPONSE, (cmp))
+#define sk_CMP_CERTRESPONSE_new_null() SKM_sk_new_null(CMP_CERTRESPONSE)
+#define sk_CMP_CERTRESPONSE_free(st) SKM_sk_free(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_num(st) SKM_sk_num(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_value(st, i) SKM_sk_value(CMP_CERTRESPONSE, (st), (i))
+#define sk_CMP_CERTRESPONSE_set(st, i, val) SKM_sk_set(CMP_CERTRESPONSE, (st), (i), (val))
+#define sk_CMP_CERTRESPONSE_zero(st) SKM_sk_zero(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_push(st, val) SKM_sk_push(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_unshift(st, val) SKM_sk_unshift(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_find(st, val) SKM_sk_find(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_find_ex(st, val) SKM_sk_find_ex(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_delete(st, i) SKM_sk_delete(CMP_CERTRESPONSE, (st), (i))
+#define sk_CMP_CERTRESPONSE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CERTRESPONSE, (st), (ptr))
+#define sk_CMP_CERTRESPONSE_insert(st, val, i) SKM_sk_insert(CMP_CERTRESPONSE, (st), (val), (i))
+#define sk_CMP_CERTRESPONSE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CERTRESPONSE, (st), (cmp))
+#define sk_CMP_CERTRESPONSE_dup(st) SKM_sk_dup(CMP_CERTRESPONSE, st)
+#define sk_CMP_CERTRESPONSE_pop_free(st, free_func) SKM_sk_pop_free(CMP_CERTRESPONSE, (st), (free_func))
+#define sk_CMP_CERTRESPONSE_shift(st) SKM_sk_shift(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_pop(st) SKM_sk_pop(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_sort(st) SKM_sk_sort(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_is_sorted(st) SKM_sk_is_sorted(CMP_CERTRESPONSE, (st))
+
+#define sk_CMP_CERTSTATUS_new(cmp) SKM_sk_new(CMP_CERTSTATUS, (cmp))
+#define sk_CMP_CERTSTATUS_new_null() SKM_sk_new_null(CMP_CERTSTATUS)
+#define sk_CMP_CERTSTATUS_free(st) SKM_sk_free(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_num(st) SKM_sk_num(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_value(st, i) SKM_sk_value(CMP_CERTSTATUS, (st), (i))
+#define sk_CMP_CERTSTATUS_set(st, i, val) SKM_sk_set(CMP_CERTSTATUS, (st), (i), (val))
+#define sk_CMP_CERTSTATUS_zero(st) SKM_sk_zero(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_push(st, val) SKM_sk_push(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_unshift(st, val) SKM_sk_unshift(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_find(st, val) SKM_sk_find(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_find_ex(st, val) SKM_sk_find_ex(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_delete(st, i) SKM_sk_delete(CMP_CERTSTATUS, (st), (i))
+#define sk_CMP_CERTSTATUS_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CERTSTATUS, (st), (ptr))
+#define sk_CMP_CERTSTATUS_insert(st, val, i) SKM_sk_insert(CMP_CERTSTATUS, (st), (val), (i))
+#define sk_CMP_CERTSTATUS_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CERTSTATUS, (st), (cmp))
+#define sk_CMP_CERTSTATUS_dup(st) SKM_sk_dup(CMP_CERTSTATUS, st)
+#define sk_CMP_CERTSTATUS_pop_free(st, free_func) SKM_sk_pop_free(CMP_CERTSTATUS, (st), (free_func))
+#define sk_CMP_CERTSTATUS_shift(st) SKM_sk_shift(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_pop(st) SKM_sk_pop(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_sort(st) SKM_sk_sort(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_is_sorted(st) SKM_sk_is_sorted(CMP_CERTSTATUS, (st))
+
+#define sk_CMP_CHALLENGE_new(cmp) SKM_sk_new(CMP_CHALLENGE, (cmp))
+#define sk_CMP_CHALLENGE_new_null() SKM_sk_new_null(CMP_CHALLENGE)
+#define sk_CMP_CHALLENGE_free(st) SKM_sk_free(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_num(st) SKM_sk_num(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_value(st, i) SKM_sk_value(CMP_CHALLENGE, (st), (i))
+#define sk_CMP_CHALLENGE_set(st, i, val) SKM_sk_set(CMP_CHALLENGE, (st), (i), (val))
+#define sk_CMP_CHALLENGE_zero(st) SKM_sk_zero(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_push(st, val) SKM_sk_push(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_unshift(st, val) SKM_sk_unshift(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_find(st, val) SKM_sk_find(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_find_ex(st, val) SKM_sk_find_ex(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_delete(st, i) SKM_sk_delete(CMP_CHALLENGE, (st), (i))
+#define sk_CMP_CHALLENGE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CHALLENGE, (st), (ptr))
+#define sk_CMP_CHALLENGE_insert(st, val, i) SKM_sk_insert(CMP_CHALLENGE, (st), (val), (i))
+#define sk_CMP_CHALLENGE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CHALLENGE, (st), (cmp))
+#define sk_CMP_CHALLENGE_dup(st) SKM_sk_dup(CMP_CHALLENGE, st)
+#define sk_CMP_CHALLENGE_pop_free(st, free_func) SKM_sk_pop_free(CMP_CHALLENGE, (st), (free_func))
+#define sk_CMP_CHALLENGE_shift(st) SKM_sk_shift(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_pop(st) SKM_sk_pop(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_sort(st) SKM_sk_sort(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_is_sorted(st) SKM_sk_is_sorted(CMP_CHALLENGE, (st))
+
+#define sk_CMP_CMPCERTIFICATE_new(cmp) SKM_sk_new(CMP_CMPCERTIFICATE, (cmp))
+#define sk_CMP_CMPCERTIFICATE_new_null() SKM_sk_new_null(CMP_CMPCERTIFICATE)
+#define sk_CMP_CMPCERTIFICATE_free(st) SKM_sk_free(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_num(st) SKM_sk_num(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_value(st, i) SKM_sk_value(CMP_CMPCERTIFICATE, (st), (i))
+#define sk_CMP_CMPCERTIFICATE_set(st, i, val) SKM_sk_set(CMP_CMPCERTIFICATE, (st), (i), (val))
+#define sk_CMP_CMPCERTIFICATE_zero(st) SKM_sk_zero(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_push(st, val) SKM_sk_push(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_unshift(st, val) SKM_sk_unshift(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_find(st, val) SKM_sk_find(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_find_ex(st, val) SKM_sk_find_ex(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_delete(st, i) SKM_sk_delete(CMP_CMPCERTIFICATE, (st), (i))
+#define sk_CMP_CMPCERTIFICATE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CMPCERTIFICATE, (st), (ptr))
+#define sk_CMP_CMPCERTIFICATE_insert(st, val, i) SKM_sk_insert(CMP_CMPCERTIFICATE, (st), (val), (i))
+#define sk_CMP_CMPCERTIFICATE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CMPCERTIFICATE, (st), (cmp))
+#define sk_CMP_CMPCERTIFICATE_dup(st) SKM_sk_dup(CMP_CMPCERTIFICATE, st)
+#define sk_CMP_CMPCERTIFICATE_pop_free(st, free_func) SKM_sk_pop_free(CMP_CMPCERTIFICATE, (st), (free_func))
+#define sk_CMP_CMPCERTIFICATE_shift(st) SKM_sk_shift(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_pop(st) SKM_sk_pop(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_sort(st) SKM_sk_sort(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_is_sorted(st) SKM_sk_is_sorted(CMP_CMPCERTIFICATE, (st))
+
+#define sk_CMP_INFOTYPEANDVALUE_new(cmp) SKM_sk_new(CMP_INFOTYPEANDVALUE, (cmp))
+#define sk_CMP_INFOTYPEANDVALUE_new_null() SKM_sk_new_null(CMP_INFOTYPEANDVALUE)
+#define sk_CMP_INFOTYPEANDVALUE_free(st) SKM_sk_free(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_num(st) SKM_sk_num(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_value(st, i) SKM_sk_value(CMP_INFOTYPEANDVALUE, (st), (i))
+#define sk_CMP_INFOTYPEANDVALUE_set(st, i, val) SKM_sk_set(CMP_INFOTYPEANDVALUE, (st), (i), (val))
+#define sk_CMP_INFOTYPEANDVALUE_zero(st) SKM_sk_zero(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_push(st, val) SKM_sk_push(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_unshift(st, val) SKM_sk_unshift(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_find(st, val) SKM_sk_find(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_find_ex(st, val) SKM_sk_find_ex(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_delete(st, i) SKM_sk_delete(CMP_INFOTYPEANDVALUE, (st), (i))
+#define sk_CMP_INFOTYPEANDVALUE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_INFOTYPEANDVALUE, (st), (ptr))
+#define sk_CMP_INFOTYPEANDVALUE_insert(st, val, i) SKM_sk_insert(CMP_INFOTYPEANDVALUE, (st), (val), (i))
+#define sk_CMP_INFOTYPEANDVALUE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_INFOTYPEANDVALUE, (st), (cmp))
+#define sk_CMP_INFOTYPEANDVALUE_dup(st) SKM_sk_dup(CMP_INFOTYPEANDVALUE, st)
+#define sk_CMP_INFOTYPEANDVALUE_pop_free(st, free_func) SKM_sk_pop_free(CMP_INFOTYPEANDVALUE, (st), (free_func))
+#define sk_CMP_INFOTYPEANDVALUE_shift(st) SKM_sk_shift(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_pop(st) SKM_sk_pop(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_sort(st) SKM_sk_sort(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_is_sorted(st) SKM_sk_is_sorted(CMP_INFOTYPEANDVALUE, (st))
+
+#define sk_CMP_PKIMESSAGE_new(cmp) SKM_sk_new(CMP_PKIMESSAGE, (cmp))
+#define sk_CMP_PKIMESSAGE_new_null() SKM_sk_new_null(CMP_PKIMESSAGE)
+#define sk_CMP_PKIMESSAGE_free(st) SKM_sk_free(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_num(st) SKM_sk_num(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_value(st, i) SKM_sk_value(CMP_PKIMESSAGE, (st), (i))
+#define sk_CMP_PKIMESSAGE_set(st, i, val) SKM_sk_set(CMP_PKIMESSAGE, (st), (i), (val))
+#define sk_CMP_PKIMESSAGE_zero(st) SKM_sk_zero(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_push(st, val) SKM_sk_push(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_unshift(st, val) SKM_sk_unshift(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_find(st, val) SKM_sk_find(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_find_ex(st, val) SKM_sk_find_ex(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_delete(st, i) SKM_sk_delete(CMP_PKIMESSAGE, (st), (i))
+#define sk_CMP_PKIMESSAGE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_PKIMESSAGE, (st), (ptr))
+#define sk_CMP_PKIMESSAGE_insert(st, val, i) SKM_sk_insert(CMP_PKIMESSAGE, (st), (val), (i))
+#define sk_CMP_PKIMESSAGE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_PKIMESSAGE, (st), (cmp))
+#define sk_CMP_PKIMESSAGE_dup(st) SKM_sk_dup(CMP_PKIMESSAGE, st)
+#define sk_CMP_PKIMESSAGE_pop_free(st, free_func) SKM_sk_pop_free(CMP_PKIMESSAGE, (st), (free_func))
+#define sk_CMP_PKIMESSAGE_shift(st) SKM_sk_shift(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_pop(st) SKM_sk_pop(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_sort(st) SKM_sk_sort(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_is_sorted(st) SKM_sk_is_sorted(CMP_PKIMESSAGE, (st))
+
+#define sk_CMP_PKISTATUSINFO_new(cmp) SKM_sk_new(CMP_PKISTATUSINFO, (cmp))
+#define sk_CMP_PKISTATUSINFO_new_null() SKM_sk_new_null(CMP_PKISTATUSINFO)
+#define sk_CMP_PKISTATUSINFO_free(st) SKM_sk_free(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_num(st) SKM_sk_num(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_value(st, i) SKM_sk_value(CMP_PKISTATUSINFO, (st), (i))
+#define sk_CMP_PKISTATUSINFO_set(st, i, val) SKM_sk_set(CMP_PKISTATUSINFO, (st), (i), (val))
+#define sk_CMP_PKISTATUSINFO_zero(st) SKM_sk_zero(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_push(st, val) SKM_sk_push(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_unshift(st, val) SKM_sk_unshift(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_find(st, val) SKM_sk_find(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_find_ex(st, val) SKM_sk_find_ex(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_delete(st, i) SKM_sk_delete(CMP_PKISTATUSINFO, (st), (i))
+#define sk_CMP_PKISTATUSINFO_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_PKISTATUSINFO, (st), (ptr))
+#define sk_CMP_PKISTATUSINFO_insert(st, val, i) SKM_sk_insert(CMP_PKISTATUSINFO, (st), (val), (i))
+#define sk_CMP_PKISTATUSINFO_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_PKISTATUSINFO, (st), (cmp))
+#define sk_CMP_PKISTATUSINFO_dup(st) SKM_sk_dup(CMP_PKISTATUSINFO, st)
+#define sk_CMP_PKISTATUSINFO_pop_free(st, free_func) SKM_sk_pop_free(CMP_PKISTATUSINFO, (st), (free_func))
+#define sk_CMP_PKISTATUSINFO_shift(st) SKM_sk_shift(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_pop(st) SKM_sk_pop(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_sort(st) SKM_sk_sort(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_is_sorted(st) SKM_sk_is_sorted(CMP_PKISTATUSINFO, (st))
+
+#define sk_CMP_POLLREP_new(cmp) SKM_sk_new(CMP_POLLREP, (cmp))
+#define sk_CMP_POLLREP_new_null() SKM_sk_new_null(CMP_POLLREP)
+#define sk_CMP_POLLREP_free(st) SKM_sk_free(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_num(st) SKM_sk_num(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_value(st, i) SKM_sk_value(CMP_POLLREP, (st), (i))
+#define sk_CMP_POLLREP_set(st, i, val) SKM_sk_set(CMP_POLLREP, (st), (i), (val))
+#define sk_CMP_POLLREP_zero(st) SKM_sk_zero(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_push(st, val) SKM_sk_push(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_unshift(st, val) SKM_sk_unshift(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_find(st, val) SKM_sk_find(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_find_ex(st, val) SKM_sk_find_ex(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_delete(st, i) SKM_sk_delete(CMP_POLLREP, (st), (i))
+#define sk_CMP_POLLREP_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_POLLREP, (st), (ptr))
+#define sk_CMP_POLLREP_insert(st, val, i) SKM_sk_insert(CMP_POLLREP, (st), (val), (i))
+#define sk_CMP_POLLREP_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_POLLREP, (st), (cmp))
+#define sk_CMP_POLLREP_dup(st) SKM_sk_dup(CMP_POLLREP, st)
+#define sk_CMP_POLLREP_pop_free(st, free_func) SKM_sk_pop_free(CMP_POLLREP, (st), (free_func))
+#define sk_CMP_POLLREP_shift(st) SKM_sk_shift(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_pop(st) SKM_sk_pop(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_sort(st) SKM_sk_sort(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_is_sorted(st) SKM_sk_is_sorted(CMP_POLLREP, (st))
+
+#define sk_CMP_POLLREQ_new(cmp) SKM_sk_new(CMP_POLLREQ, (cmp))
+#define sk_CMP_POLLREQ_new_null() SKM_sk_new_null(CMP_POLLREQ)
+#define sk_CMP_POLLREQ_free(st) SKM_sk_free(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_num(st) SKM_sk_num(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_value(st, i) SKM_sk_value(CMP_POLLREQ, (st), (i))
+#define sk_CMP_POLLREQ_set(st, i, val) SKM_sk_set(CMP_POLLREQ, (st), (i), (val))
+#define sk_CMP_POLLREQ_zero(st) SKM_sk_zero(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_push(st, val) SKM_sk_push(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_unshift(st, val) SKM_sk_unshift(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_find(st, val) SKM_sk_find(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_find_ex(st, val) SKM_sk_find_ex(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_delete(st, i) SKM_sk_delete(CMP_POLLREQ, (st), (i))
+#define sk_CMP_POLLREQ_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_POLLREQ, (st), (ptr))
+#define sk_CMP_POLLREQ_insert(st, val, i) SKM_sk_insert(CMP_POLLREQ, (st), (val), (i))
+#define sk_CMP_POLLREQ_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_POLLREQ, (st), (cmp))
+#define sk_CMP_POLLREQ_dup(st) SKM_sk_dup(CMP_POLLREQ, st)
+#define sk_CMP_POLLREQ_pop_free(st, free_func) SKM_sk_pop_free(CMP_POLLREQ, (st), (free_func))
+#define sk_CMP_POLLREQ_shift(st) SKM_sk_shift(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_pop(st) SKM_sk_pop(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_sort(st) SKM_sk_sort(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_is_sorted(st) SKM_sk_is_sorted(CMP_POLLREQ, (st))
+
+#define sk_CMP_REVDETAILS_new(cmp) SKM_sk_new(CMP_REVDETAILS, (cmp))
+#define sk_CMP_REVDETAILS_new_null() SKM_sk_new_null(CMP_REVDETAILS)
+#define sk_CMP_REVDETAILS_free(st) SKM_sk_free(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_num(st) SKM_sk_num(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_value(st, i) SKM_sk_value(CMP_REVDETAILS, (st), (i))
+#define sk_CMP_REVDETAILS_set(st, i, val) SKM_sk_set(CMP_REVDETAILS, (st), (i), (val))
+#define sk_CMP_REVDETAILS_zero(st) SKM_sk_zero(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_push(st, val) SKM_sk_push(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_unshift(st, val) SKM_sk_unshift(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_find(st, val) SKM_sk_find(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_find_ex(st, val) SKM_sk_find_ex(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_delete(st, i) SKM_sk_delete(CMP_REVDETAILS, (st), (i))
+#define sk_CMP_REVDETAILS_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_REVDETAILS, (st), (ptr))
+#define sk_CMP_REVDETAILS_insert(st, val, i) SKM_sk_insert(CMP_REVDETAILS, (st), (val), (i))
+#define sk_CMP_REVDETAILS_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_REVDETAILS, (st), (cmp))
+#define sk_CMP_REVDETAILS_dup(st) SKM_sk_dup(CMP_REVDETAILS, st)
+#define sk_CMP_REVDETAILS_pop_free(st, free_func) SKM_sk_pop_free(CMP_REVDETAILS, (st), (free_func))
+#define sk_CMP_REVDETAILS_shift(st) SKM_sk_shift(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_pop(st) SKM_sk_pop(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_sort(st) SKM_sk_sort(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_is_sorted(st) SKM_sk_is_sorted(CMP_REVDETAILS, (st))
+
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_new(cmp) SKM_sk_new(CRMF_ATTRIBUTETYPEANDVALUE, (cmp))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_new_null() SKM_sk_new_null(CRMF_ATTRIBUTETYPEANDVALUE)
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_free(st) SKM_sk_free(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_num(st) SKM_sk_num(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_value(st, i) SKM_sk_value(CRMF_ATTRIBUTETYPEANDVALUE, (st), (i))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_set(st, i, val) SKM_sk_set(CRMF_ATTRIBUTETYPEANDVALUE, (st), (i), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_zero(st) SKM_sk_zero(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_push(st, val) SKM_sk_push(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_unshift(st, val) SKM_sk_unshift(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_find(st, val) SKM_sk_find(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_find_ex(st, val) SKM_sk_find_ex(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_delete(st, i) SKM_sk_delete(CRMF_ATTRIBUTETYPEANDVALUE, (st), (i))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CRMF_ATTRIBUTETYPEANDVALUE, (st), (ptr))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_insert(st, val, i) SKM_sk_insert(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val), (i))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CRMF_ATTRIBUTETYPEANDVALUE, (st), (cmp))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_dup(st) SKM_sk_dup(CRMF_ATTRIBUTETYPEANDVALUE, st)
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_pop_free(st, free_func) SKM_sk_pop_free(CRMF_ATTRIBUTETYPEANDVALUE, (st), (free_func))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_shift(st) SKM_sk_shift(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_pop(st) SKM_sk_pop(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_sort(st) SKM_sk_sort(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_is_sorted(st) SKM_sk_is_sorted(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+
+#define sk_CRMF_CERTID_new(cmp) SKM_sk_new(CRMF_CERTID, (cmp))
+#define sk_CRMF_CERTID_new_null() SKM_sk_new_null(CRMF_CERTID)
+#define sk_CRMF_CERTID_free(st) SKM_sk_free(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_num(st) SKM_sk_num(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_value(st, i) SKM_sk_value(CRMF_CERTID, (st), (i))
+#define sk_CRMF_CERTID_set(st, i, val) SKM_sk_set(CRMF_CERTID, (st), (i), (val))
+#define sk_CRMF_CERTID_zero(st) SKM_sk_zero(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_push(st, val) SKM_sk_push(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_unshift(st, val) SKM_sk_unshift(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_find(st, val) SKM_sk_find(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_find_ex(st, val) SKM_sk_find_ex(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_delete(st, i) SKM_sk_delete(CRMF_CERTID, (st), (i))
+#define sk_CRMF_CERTID_delete_ptr(st, ptr) SKM_sk_delete_ptr(CRMF_CERTID, (st), (ptr))
+#define sk_CRMF_CERTID_insert(st, val, i) SKM_sk_insert(CRMF_CERTID, (st), (val), (i))
+#define sk_CRMF_CERTID_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CRMF_CERTID, (st), (cmp))
+#define sk_CRMF_CERTID_dup(st) SKM_sk_dup(CRMF_CERTID, st)
+#define sk_CRMF_CERTID_pop_free(st, free_func) SKM_sk_pop_free(CRMF_CERTID, (st), (free_func))
+#define sk_CRMF_CERTID_shift(st) SKM_sk_shift(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_pop(st) SKM_sk_pop(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_sort(st) SKM_sk_sort(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_is_sorted(st) SKM_sk_is_sorted(CRMF_CERTID, (st))
+
+#define sk_CRMF_CERTREQMSG_new(cmp) SKM_sk_new(CRMF_CERTREQMSG, (cmp))
+#define sk_CRMF_CERTREQMSG_new_null() SKM_sk_new_null(CRMF_CERTREQMSG)
+#define sk_CRMF_CERTREQMSG_free(st) SKM_sk_free(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_num(st) SKM_sk_num(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_value(st, i) SKM_sk_value(CRMF_CERTREQMSG, (st), (i))
+#define sk_CRMF_CERTREQMSG_set(st, i, val) SKM_sk_set(CRMF_CERTREQMSG, (st), (i), (val))
+#define sk_CRMF_CERTREQMSG_zero(st) SKM_sk_zero(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_push(st, val) SKM_sk_push(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_unshift(st, val) SKM_sk_unshift(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_find(st, val) SKM_sk_find(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_find_ex(st, val) SKM_sk_find_ex(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_delete(st, i) SKM_sk_delete(CRMF_CERTREQMSG, (st), (i))
+#define sk_CRMF_CERTREQMSG_delete_ptr(st, ptr) SKM_sk_delete_ptr(CRMF_CERTREQMSG, (st), (ptr))
+#define sk_CRMF_CERTREQMSG_insert(st, val, i) SKM_sk_insert(CRMF_CERTREQMSG, (st), (val), (i))
+#define sk_CRMF_CERTREQMSG_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CRMF_CERTREQMSG, (st), (cmp))
+#define sk_CRMF_CERTREQMSG_dup(st) SKM_sk_dup(CRMF_CERTREQMSG, st)
+#define sk_CRMF_CERTREQMSG_pop_free(st, free_func) SKM_sk_pop_free(CRMF_CERTREQMSG, (st), (free_func))
+#define sk_CRMF_CERTREQMSG_shift(st) SKM_sk_shift(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_pop(st) SKM_sk_pop(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_sort(st) SKM_sk_sort(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_is_sorted(st) SKM_sk_is_sorted(CRMF_CERTREQMSG, (st))
+
+#define d2i_ASN1_SET_OF_CMP_CERTSTATUS(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
+	SKM_ASN1_SET_OF_d2i(CMP_CERTSTATUS, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
+#define i2d_ASN1_SET_OF_CMP_CERTSTATUS(st, pp, i2d_func, ex_tag, ex_class, is_set) \
+	SKM_ASN1_SET_OF_i2d(CMP_CERTSTATUS, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
+#define ASN1_seq_pack_CMP_CERTSTATUS(st, i2d_func, buf, len) \
+	SKM_ASN1_seq_pack(CMP_CERTSTATUS, (st), (i2d_func), (buf), (len))
+#define ASN1_seq_unpack_CMP_CERTSTATUS(buf, len, d2i_func, free_func) \
+	SKM_ASN1_seq_unpack(CMP_CERTSTATUS, (buf), (len), (d2i_func), (free_func))
+
+#define d2i_ASN1_SET_OF_CRMF_CERTREQMSG(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
+	SKM_ASN1_SET_OF_d2i(CRMF_CERTREQMSG, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
+#define i2d_ASN1_SET_OF_CRMF_CERTREQMSG(st, pp, i2d_func, ex_tag, ex_class, is_set) \
+	SKM_ASN1_SET_OF_i2d(CRMF_CERTREQMSG, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
+#define ASN1_seq_pack_CRMF_CERTREQMSG(st, i2d_func, buf, len) \
+	SKM_ASN1_seq_pack(CRMF_CERTREQMSG, (st), (i2d_func), (buf), (len))
+#define ASN1_seq_unpack_CRMF_CERTREQMSG(buf, len, d2i_func, free_func) \
+	SKM_ASN1_seq_unpack(CRMF_CERTREQMSG, (buf), (len), (d2i_func), (free_func))
+
+
+
+
 #define sk_BIO_new(cmp) SKM_sk_new(BIO, (cmp))
 #define sk_BIO_new_null() SKM_sk_new_null(BIO)
 #define sk_BIO_free(st) SKM_sk_free(BIO, (st))
@@ -2198,7 +2515,7 @@
 
 #ifndef LIBRESSL_INTERNAL
 #define d2i_ASN1_SET_OF_ACCESS_DESCRIPTION(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(ACCESS_DESCRIPTION, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(ACCESS_DESCRIPTION, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_ACCESS_DESCRIPTION(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(ACCESS_DESCRIPTION, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_ACCESS_DESCRIPTION(st, i2d_func, buf, len) \
@@ -2207,7 +2524,7 @@
 	SKM_ASN1_seq_unpack(ACCESS_DESCRIPTION, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_ASN1_INTEGER(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(ASN1_INTEGER, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(ASN1_INTEGER, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_ASN1_INTEGER(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(ASN1_INTEGER, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_ASN1_INTEGER(st, i2d_func, buf, len) \
@@ -2216,7 +2533,7 @@
 	SKM_ASN1_seq_unpack(ASN1_INTEGER, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_ASN1_OBJECT(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(ASN1_OBJECT, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(ASN1_OBJECT, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_ASN1_OBJECT(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(ASN1_OBJECT, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_ASN1_OBJECT(st, i2d_func, buf, len) \
@@ -2225,7 +2542,7 @@
 	SKM_ASN1_seq_unpack(ASN1_OBJECT, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_ASN1_TYPE(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(ASN1_TYPE, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(ASN1_TYPE, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_ASN1_TYPE(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(ASN1_TYPE, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_ASN1_TYPE(st, i2d_func, buf, len) \
@@ -2234,7 +2551,7 @@
 	SKM_ASN1_seq_unpack(ASN1_TYPE, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_ASN1_UTF8STRING(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(ASN1_UTF8STRING, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(ASN1_UTF8STRING, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_ASN1_UTF8STRING(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(ASN1_UTF8STRING, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_ASN1_UTF8STRING(st, i2d_func, buf, len) \
@@ -2243,7 +2560,7 @@
 	SKM_ASN1_seq_unpack(ASN1_UTF8STRING, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_DIST_POINT(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(DIST_POINT, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(DIST_POINT, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_DIST_POINT(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(DIST_POINT, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_DIST_POINT(st, i2d_func, buf, len) \
@@ -2252,7 +2569,7 @@
 	SKM_ASN1_seq_unpack(DIST_POINT, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_ESS_CERT_ID(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(ESS_CERT_ID, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(ESS_CERT_ID, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_ESS_CERT_ID(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(ESS_CERT_ID, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_ESS_CERT_ID(st, i2d_func, buf, len) \
@@ -2261,7 +2578,7 @@
 	SKM_ASN1_seq_unpack(ESS_CERT_ID, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_EVP_MD(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(EVP_MD, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(EVP_MD, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_EVP_MD(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(EVP_MD, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_EVP_MD(st, i2d_func, buf, len) \
@@ -2270,7 +2587,7 @@
 	SKM_ASN1_seq_unpack(EVP_MD, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_GENERAL_NAME(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(GENERAL_NAME, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(GENERAL_NAME, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_GENERAL_NAME(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(GENERAL_NAME, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_GENERAL_NAME(st, i2d_func, buf, len) \
@@ -2279,7 +2596,7 @@
 	SKM_ASN1_seq_unpack(GENERAL_NAME, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_OCSP_ONEREQ(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(OCSP_ONEREQ, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(OCSP_ONEREQ, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_OCSP_ONEREQ(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(OCSP_ONEREQ, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_OCSP_ONEREQ(st, i2d_func, buf, len) \
@@ -2288,7 +2605,7 @@
 	SKM_ASN1_seq_unpack(OCSP_ONEREQ, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_OCSP_SINGLERESP(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(OCSP_SINGLERESP, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(OCSP_SINGLERESP, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_OCSP_SINGLERESP(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(OCSP_SINGLERESP, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_OCSP_SINGLERESP(st, i2d_func, buf, len) \
@@ -2297,7 +2614,7 @@
 	SKM_ASN1_seq_unpack(OCSP_SINGLERESP, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_PKCS12_SAFEBAG(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(PKCS12_SAFEBAG, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(PKCS12_SAFEBAG, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_PKCS12_SAFEBAG(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(PKCS12_SAFEBAG, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_PKCS12_SAFEBAG(st, i2d_func, buf, len) \
@@ -2306,7 +2623,7 @@
 	SKM_ASN1_seq_unpack(PKCS12_SAFEBAG, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_PKCS7(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(PKCS7, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(PKCS7, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_PKCS7(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(PKCS7, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_PKCS7(st, i2d_func, buf, len) \
@@ -2315,7 +2632,7 @@
 	SKM_ASN1_seq_unpack(PKCS7, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_PKCS7_RECIP_INFO(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(PKCS7_RECIP_INFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(PKCS7_RECIP_INFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_PKCS7_RECIP_INFO(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(PKCS7_RECIP_INFO, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_PKCS7_RECIP_INFO(st, i2d_func, buf, len) \
@@ -2324,7 +2641,7 @@
 	SKM_ASN1_seq_unpack(PKCS7_RECIP_INFO, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_PKCS7_SIGNER_INFO(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(PKCS7_SIGNER_INFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(PKCS7_SIGNER_INFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_PKCS7_SIGNER_INFO(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(PKCS7_SIGNER_INFO, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_PKCS7_SIGNER_INFO(st, i2d_func, buf, len) \
@@ -2333,7 +2650,7 @@
 	SKM_ASN1_seq_unpack(PKCS7_SIGNER_INFO, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_POLICYINFO(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(POLICYINFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(POLICYINFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_POLICYINFO(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(POLICYINFO, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_POLICYINFO(st, i2d_func, buf, len) \
@@ -2342,7 +2659,7 @@
 	SKM_ASN1_seq_unpack(POLICYINFO, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_POLICYQUALINFO(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(POLICYQUALINFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(POLICYQUALINFO, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_POLICYQUALINFO(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(POLICYQUALINFO, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_POLICYQUALINFO(st, i2d_func, buf, len) \
@@ -2351,7 +2668,7 @@
 	SKM_ASN1_seq_unpack(POLICYQUALINFO, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_SXNETID(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(SXNETID, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(SXNETID, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_SXNETID(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(SXNETID, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_SXNETID(st, i2d_func, buf, len) \
@@ -2360,7 +2677,7 @@
 	SKM_ASN1_seq_unpack(SXNETID, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509(st, i2d_func, buf, len) \
@@ -2369,7 +2686,7 @@
 	SKM_ASN1_seq_unpack(X509, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509_ALGOR(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509_ALGOR, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509_ALGOR, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509_ALGOR(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509_ALGOR, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509_ALGOR(st, i2d_func, buf, len) \
@@ -2378,7 +2695,7 @@
 	SKM_ASN1_seq_unpack(X509_ALGOR, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509_ATTRIBUTE(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509_ATTRIBUTE, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509_ATTRIBUTE, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509_ATTRIBUTE(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509_ATTRIBUTE, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509_ATTRIBUTE(st, i2d_func, buf, len) \
@@ -2387,7 +2704,7 @@
 	SKM_ASN1_seq_unpack(X509_ATTRIBUTE, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509_CRL(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509_CRL, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509_CRL, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509_CRL(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509_CRL, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509_CRL(st, i2d_func, buf, len) \
@@ -2396,7 +2713,7 @@
 	SKM_ASN1_seq_unpack(X509_CRL, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509_EXTENSION(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509_EXTENSION, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509_EXTENSION, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509_EXTENSION(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509_EXTENSION, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509_EXTENSION(st, i2d_func, buf, len) \
@@ -2405,7 +2722,7 @@
 	SKM_ASN1_seq_unpack(X509_EXTENSION, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509_NAME_ENTRY(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509_NAME_ENTRY, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509_NAME_ENTRY, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509_NAME_ENTRY(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509_NAME_ENTRY, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509_NAME_ENTRY(st, i2d_func, buf, len) \
@@ -2414,7 +2731,7 @@
 	SKM_ASN1_seq_unpack(X509_NAME_ENTRY, (buf), (len), (d2i_func), (free_func))
 
 #define d2i_ASN1_SET_OF_X509_REVOKED(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
-	SKM_ASN1_SET_OF_d2i(X509_REVOKED, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+	SKM_ASN1_SET_OF_d2i(X509_REVOKED, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class))
 #define i2d_ASN1_SET_OF_X509_REVOKED(st, pp, i2d_func, ex_tag, ex_class, is_set) \
 	SKM_ASN1_SET_OF_i2d(X509_REVOKED, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
 #define ASN1_seq_pack_X509_REVOKED(st, i2d_func, buf, len) \
diff -Naur crypto/Makefile.am crypto-/Makefile.am
--- cryptoold/Makefile.am	2017-04-20 22:53:24.674503173 +0700
+++ crypto/Makefile.am	2017-04-20 16:50:26.933043478 +0700
@@ -341,6 +341,26 @@
 libcrypto_la_SOURCES += cmac/cm_pmeth.c
 libcrypto_la_SOURCES += cmac/cmac.c
 
+# crmf
+libcrypto_la_SOURCES += crmf/crmf_asn.c
+libcrypto_la_SOURCES += crmf/crmf_err.c
+libcrypto_la_SOURCES += crmf/crmf_lib.c
+libcrypto_la_SOURCES += crmf/crmf_msg.c
+libcrypto_la_SOURCES += crmf/crmf_pbm.c
+
+
+# cmp
+libcrypto_la_SOURCES += cmp/cmp_asn.c
+libcrypto_la_SOURCES += cmp/cmp_ctx.c
+libcrypto_la_SOURCES += cmp/cmp_err.c
+libcrypto_la_SOURCES += cmp/cmp_http.c
+libcrypto_la_SOURCES += cmp/cmp_lib.c
+libcrypto_la_SOURCES += cmp/cmp_msg.c
+libcrypto_la_SOURCES += cmp/cmp_ses.c
+libcrypto_la_SOURCES += cmp/cmp_vfy.c
+
+
+
 # comp
 libcrypto_la_SOURCES += comp/c_rle.c
 libcrypto_la_SOURCES += comp/c_zlib.c
diff -Naur crypto/cmp/cmp_asn.c crypto-/cmp/cmp_asn.c
--- cryptoold/cmp/cmp_asn.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_asn.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,2110 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* cmp_asn.c
+ * OpenSSL ASN.1 definitions for CMP (RFC 4210)
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *   software must display the following acknowledgment:
+ *   "This product includes software developed by the OpenSSL Project
+ *   for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *   endorse or promote products derived from this software without
+ *   prior written permission. For written permission, please contact
+ *   openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *   nor may "OpenSSL" appear in their names without prior written
+ *   permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *   acknowledgment:
+ *   "This product includes software developed by the OpenSSL Project
+ *   for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+
+static const ASN1_TEMPLATE CMP_REVANNCONTENT_seq_tt[] = {
+	/* CMP_PKISTATUS is effectively ASN1_INTEGER so it is used directly */
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_REVANNCONTENT, status),
+		.field_name = "status",
+		.item = &ASN1_INTEGER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_REVANNCONTENT, certId),
+			.field_name = "certId",
+			.item = &CRMF_CERTID_it,
+		}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_REVANNCONTENT, willBeRevokedAt),
+			.field_name = "willBeRevokedAt",
+			.item = &ASN1_GENERALIZEDTIME_it,
+		}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_REVANNCONTENT, badSinceDate),
+			.field_name = "badSinceDate",
+			.item = &ASN1_GENERALIZEDTIME_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_REVANNCONTENT, crlDetails),
+			.field_name = "crlDetails",
+			.item = &X509_EXTENSIONS_it,
+		}
+};
+const ASN1_ITEM CMP_REVANNCONTENT_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_REVANNCONTENT_seq_tt,
+	.tcount = sizeof(CMP_REVANNCONTENT_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_REVANNCONTENT),
+	.sname = "CMP_REVANNCONTENT",
+};
+
+
+	CMP_REVANNCONTENT *
+d2i_CMP_REVANNCONTENT(CMP_REVANNCONTENT **a, const unsigned char **in, long len)
+{
+	return (CMP_REVANNCONTENT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_REVANNCONTENT_it);
+}
+	int
+i2d_CMP_REVANNCONTENT(CMP_REVANNCONTENT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_REVANNCONTENT_it);
+}
+
+	CMP_REVANNCONTENT *
+CMP_REVANNCONTENT_new(void)
+{
+	return (CMP_REVANNCONTENT *)ASN1_item_new(&CMP_REVANNCONTENT_it);
+}
+
+void CMP_REVANNCONTENT_free(CMP_REVANNCONTENT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_REVANNCONTENT_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_CHALLENGE_seq_tt[] = {
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CHALLENGE, owf),
+		.field_name = "owf",
+		.item = &X509_ALGOR_it,
+	},
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_CHALLENGE, whitness),
+		.field_name = "whitness",
+		.item = &ASN1_OCTET_STRING_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_CHALLENGE, challenge),
+			.field_name = "challenge",
+			.item = &ASN1_OCTET_STRING_it,
+		}
+
+};
+const ASN1_ITEM CMP_CHALLENGE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_CHALLENGE_seq_tt,
+	.tcount = sizeof(CMP_CHALLENGE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CHALLENGE),
+	.sname = "CMP_CHALLENGE",
+};
+
+
+	CMP_CHALLENGE *
+d2i_CMP_CHALLENGE(CMP_CHALLENGE **a, const unsigned char **in, long len)
+{
+	return (CMP_CHALLENGE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CHALLENGE_it);
+}
+	int
+i2d_CMP_CHALLENGE(CMP_CHALLENGE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CHALLENGE_it);
+}
+
+	CMP_CHALLENGE *
+CMP_CHALLENGE_new(void)
+{
+	return (CMP_CHALLENGE *)ASN1_item_new(&CMP_CHALLENGE_it);
+}
+
+void CMP_CHALLENGE_free(CMP_CHALLENGE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CHALLENGE_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_POPODECKEYCHALLCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_POPODECKEYCHALLCONTENT",
+	.item = &CMP_CHALLENGE_it,
+};
+
+const ASN1_ITEM CMP_POPODECKEYCHALLCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_POPODECKEYCHALLCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_POPODECKEYCHALLCONTENT",
+};
+
+
+static const ASN1_TEMPLATE CMP_POPODECKEYRESPCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_POPODECKEYRESPCONTENT",
+	.item = &ASN1_INTEGER_it,
+};
+
+const ASN1_ITEM CMP_POPODECKEYRESPCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_POPODECKEYRESPCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_POPODECKEYRESPCONTENT",
+};
+
+
+static const ASN1_TEMPLATE CMP_CAKEYUPDANNCONTENT_seq_tt[] = {
+	/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_CAKEYUPDANNCONTENT, oldWithNew),
+		.field_name = "oldWithNew",
+		.item = &X509_it,
+	}
+	,
+		/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_CAKEYUPDANNCONTENT, newWithOld),
+			.field_name = "newWithOld",
+			.item = &X509_it,
+		}
+	,
+		/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_CAKEYUPDANNCONTENT, newWithNew),
+			.field_name = "newWithNew",
+			.item = &X509_it,
+		}
+
+};
+const ASN1_ITEM CMP_CAKEYUPDANNCONTENT_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_CAKEYUPDANNCONTENT_seq_tt,
+	.tcount = sizeof(CMP_CAKEYUPDANNCONTENT_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CAKEYUPDANNCONTENT),
+	.sname = "CMP_CAKEYUPDANNCONTENT",
+};
+
+
+	CMP_CAKEYUPDANNCONTENT *
+d2i_CMP_CAKEYUPDANNCONTENT(CMP_CAKEYUPDANNCONTENT **a, const unsigned char **in, long len)
+{
+	return (CMP_CAKEYUPDANNCONTENT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CAKEYUPDANNCONTENT_it);
+}
+	int
+i2d_CMP_CAKEYUPDANNCONTENT(CMP_CAKEYUPDANNCONTENT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CAKEYUPDANNCONTENT_it);
+}
+
+	CMP_CAKEYUPDANNCONTENT *
+CMP_CAKEYUPDANNCONTENT_new(void)
+{
+	return (CMP_CAKEYUPDANNCONTENT *)ASN1_item_new(&CMP_CAKEYUPDANNCONTENT_it);
+}
+
+void CMP_CAKEYUPDANNCONTENT_free(CMP_CAKEYUPDANNCONTENT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CAKEYUPDANNCONTENT_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_ERRORMSGCONTENT_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_ERRORMSGCONTENT, pKIStatusInfo),
+		.field_name = "pKIStatusInfo",
+		.item = &CMP_PKISTATUSINFO_it,
+	}
+	,
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_ERRORMSGCONTENT, errorCode),
+			.field_name = "errorCode",
+			.item = &ASN1_INTEGER_it,
+		},
+		/* CMP_PKIFREETEXT is effectively a sequence of ASN1_UTF8STRING so it is used directly */
+		{
+			.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_ERRORMSGCONTENT, errorDetails),
+			.field_name = "errorDetails",
+			.item = &ASN1_UTF8STRING_it,
+		}
+};
+const ASN1_ITEM CMP_ERRORMSGCONTENT_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_ERRORMSGCONTENT_seq_tt,
+	.tcount = sizeof(CMP_ERRORMSGCONTENT_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_ERRORMSGCONTENT),
+	.sname = "CMP_ERRORMSGCONTENT",
+};
+
+
+	CMP_ERRORMSGCONTENT *
+d2i_CMP_ERRORMSGCONTENT(CMP_ERRORMSGCONTENT **a, const unsigned char **in, long len)
+{
+	return (CMP_ERRORMSGCONTENT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_ERRORMSGCONTENT_it);
+}
+	int
+i2d_CMP_ERRORMSGCONTENT(CMP_ERRORMSGCONTENT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_ERRORMSGCONTENT_it);
+}
+
+	CMP_ERRORMSGCONTENT *
+CMP_ERRORMSGCONTENT_new(void)
+{
+	return (CMP_ERRORMSGCONTENT *)ASN1_item_new(&CMP_ERRORMSGCONTENT_it);
+}
+
+void CMP_ERRORMSGCONTENT_free(CMP_ERRORMSGCONTENT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_ERRORMSGCONTENT_it);
+}
+
+
+
+static const ASN1_TEMPLATE infotypeandvalue_default_tt = {
+	.flags = ASN1_TFLG_OPTIONAL,
+	.tag = 0,
+	.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.other),
+	.field_name = "infoValue.other",
+	.item = &ASN1_ANY_it,
+};
+static const ASN1_ADB_TABLE CMP_INFOTYPEANDVALUE_adbtbl[] = {
+	/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+	{
+		.value = NID_id_it_caProtEncCert,
+		.tt = {
+
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.caProtEncCert),
+			.field_name = "infoValue.caProtEncCert",
+			.item = &X509_it,
+		},
+	},
+	{
+		.value = NID_id_it_signKeyPairTypes,
+		.tt = {
+
+			.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.signKeyPairTypes),
+			.field_name = "infoValue.signKeyPairTypes",
+			.item = &X509_ALGOR_it,
+		}
+	},
+		{
+			.value = NID_id_it_encKeyPairTypes,
+			.tt = {
+
+				.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.encKeyPairTypes),
+				.field_name = "infoValue.encKeyPairTypes",
+				.item = &X509_ALGOR_it,
+			}
+		},
+		{
+			.value = NID_id_it_preferredSymmAlg,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.preferredSymmAlg),
+				.field_name = "infoValue.preferredSymmAlg",
+				.item = &X509_ALGOR_it,
+			}
+		},
+		{
+			.value = NID_id_it_caKeyUpdateInfo,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.caKeyUpdateInfo),
+				.field_name = "infoValue.caKeyUpdateInfo",
+				.item = &CMP_CAKEYUPDANNCONTENT_it,
+			}
+		},
+		{
+			.value = NID_id_it_currentCRL,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.currentCRL),
+				.field_name = "infoValue.currentCRL",
+				.item = &X509_CRL_it,
+			}
+		},
+		{
+			.value = NID_id_it_unsupportedOIDs,
+			.tt = {
+
+				.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.unsupportedOIDs),
+				.field_name = "infoValue.unsupportedOIDs",
+				.item = &ASN1_OBJECT_it,
+			}
+		},
+		{
+			.value = NID_id_it_keyPairParamReq,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.keyPairParamReq),
+				.field_name = "infoValue.keyPairParamReq",
+				.item = &ASN1_OBJECT_it,
+			}
+		},
+		{
+			.value = NID_id_it_keyPairParamRep,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.keyPairParamRep),
+				.field_name = "infoValue.keyPairParamRep",
+				.item = &X509_ALGOR_it,
+			}
+		},
+		{
+			.value = NID_id_it_revPassphrase,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.revPassphrase),
+				.field_name = "infoValue.revPassphrase",
+				.item = &CRMF_ENCRYPTEDVALUE_it,
+			}
+		},
+		{
+			.value = NID_id_it_implicitConfirm,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.implicitConfirm),
+				.field_name = "infoValue.implicitConfirm",
+				.item = &ASN1_NULL_it,
+			}
+		},
+		{
+			.value = NID_id_it_confirmWaitTime,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.confirmWaitTime),
+				.field_name = "infoValue.confirmWaitTime",
+				.item = &ASN1_GENERALIZEDTIME_it,
+			}
+		},
+		{
+			.value = NID_id_it_origPKIMessage,
+			.tt = {
+
+				.flags = ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.origPKIMessage),
+				.field_name = "infoValue.origPKIMessage",
+				.item = &CMP_PKIMESSAGES_it,
+			}
+		},
+		{
+			.value = NID_id_it_suppLangTags,
+			.tt = {
+
+				.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+				.tag = 0,
+				.offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.suppLangTagsValue),
+				.field_name = "infoValue.suppLangTagsValue",
+				.item = &ASN1_UTF8STRING_it,
+			}
+		},
+#if 0
+		/* this is what CL likes for KUR - not in the RFC */
+		ADB_ENTRY(NID_id_smime_aa_signingCertificate, ASN1_SET_OF(CMP_INFOTYPEANDVALUE, infoValue.signingCertificate, ESS_SIGNING_CERT))
+			/* this is how signingCertificate should probably be actually used */
+			/* {
+			   .value = NID_id_smime_aa_signingCertificate,
+			   .tt = {
+
+			   .flags = 0,
+			   .tag = 0,
+			   .offset = offsetof(CMP_INFOTYPEANDVALUE, infoValue.signingCertificate),
+			   .field_name = "infoValue.signingCertificate",
+			   .item = &ESS_SIGNING_CERT_it,
+			   }
+			   */
+#endif
+};
+static const ASN1_ADB CMP_INFOTYPEANDVALUE_adb = {
+	.flags = 0,
+	.offset = offsetof(CMP_INFOTYPEANDVALUE, infoType),
+	.app_items = 0,
+	.tbl = CMP_INFOTYPEANDVALUE_adbtbl,
+	.tblcount = sizeof(CMP_INFOTYPEANDVALUE_adbtbl) / sizeof(ASN1_ADB_TABLE),
+	.default_tt = &infotypeandvalue_default_tt,
+	.null_tt = NULL,
+};
+
+
+
+static const ASN1_TEMPLATE CMP_INFOTYPEANDVALUE_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_INFOTYPEANDVALUE, infoType),
+		.field_name = "infoType",
+		.item = &ASN1_OBJECT_it,
+	}
+	,
+		{
+			.flags = ASN1_TFLG_ADB_OID,
+			.tag = -1,
+			.offset = 0,
+			.field_name = "CMP_INFOTYPEANDVALUE",
+			.item = (const ASN1_ITEM*)&CMP_INFOTYPEANDVALUE_adb,
+		}
+
+};
+const ASN1_ITEM CMP_INFOTYPEANDVALUE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_INFOTYPEANDVALUE_seq_tt,
+	.tcount = sizeof(CMP_INFOTYPEANDVALUE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_INFOTYPEANDVALUE),
+	.sname = "CMP_INFOTYPEANDVALUE",
+};
+
+
+	CMP_INFOTYPEANDVALUE *
+d2i_CMP_INFOTYPEANDVALUE(CMP_INFOTYPEANDVALUE **a, const unsigned char **in, long len)
+{
+	return (CMP_INFOTYPEANDVALUE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_INFOTYPEANDVALUE_it);
+}
+	int
+i2d_CMP_INFOTYPEANDVALUE(CMP_INFOTYPEANDVALUE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_INFOTYPEANDVALUE_it);
+}
+
+	CMP_INFOTYPEANDVALUE *
+CMP_INFOTYPEANDVALUE_new(void)
+{
+	return (CMP_INFOTYPEANDVALUE *)ASN1_item_new(&CMP_INFOTYPEANDVALUE_it);
+}
+
+void CMP_INFOTYPEANDVALUE_free(CMP_INFOTYPEANDVALUE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_INFOTYPEANDVALUE_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_CERTORENCCERT_ch_tt[] = {
+	/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 0,
+		.offset = offsetof(CMP_CERTORENCCERT, value.certificate),
+		.field_name = "value.certificate",
+		.item = &X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 1,
+		.offset = offsetof(CMP_CERTORENCCERT, value.encryptedCert),
+		.field_name = "value.encryptedCert",
+		.item = &CRMF_ENCRYPTEDVALUE_it,
+	},
+};
+
+const ASN1_ITEM CMP_CERTORENCCERT_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CMP_CERTORENCCERT, type),
+	.templates = CMP_CERTORENCCERT_ch_tt,
+	.tcount = sizeof(CMP_CERTORENCCERT_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CERTORENCCERT),
+	.sname = "CMP_CERTORENCCERT",
+};
+
+	CMP_CERTORENCCERT *
+d2i_CMP_CERTORENCCERT(CMP_CERTORENCCERT **a, const unsigned char **in, long len)
+{
+	return (CMP_CERTORENCCERT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CERTORENCCERT_it);
+}
+	int
+i2d_CMP_CERTORENCCERT(CMP_CERTORENCCERT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CERTORENCCERT_it);
+}
+
+	CMP_CERTORENCCERT *
+CMP_CERTORENCCERT_new(void)
+{
+	return (CMP_CERTORENCCERT *)ASN1_item_new(&CMP_CERTORENCCERT_it);
+}
+
+void CMP_CERTORENCCERT_free(CMP_CERTORENCCERT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CERTORENCCERT_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_CERTIFIEDKEYPAIR_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_CERTIFIEDKEYPAIR, certOrEncCert),
+		.field_name = "certOrEncCert",
+		.item = &CMP_CERTORENCCERT_it,
+	}
+	,
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_CERTIFIEDKEYPAIR, privateKey),
+			.field_name = "privateKey",
+			.item = &CRMF_ENCRYPTEDVALUE_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 1,
+			.offset = offsetof(CMP_CERTIFIEDKEYPAIR, failInfo),
+			.field_name = "failInfo",
+			.item = &CRMF_PKIPUBLICATIONINFO_it,
+		}
+};
+const ASN1_ITEM CMP_CERTIFIEDKEYPAIR_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_CERTIFIEDKEYPAIR_seq_tt,
+	.tcount = sizeof(CMP_CERTIFIEDKEYPAIR_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CERTIFIEDKEYPAIR),
+	.sname = "CMP_CERTIFIEDKEYPAIR",
+};
+
+
+	CMP_CERTIFIEDKEYPAIR *
+d2i_CMP_CERTIFIEDKEYPAIR(CMP_CERTIFIEDKEYPAIR **a, const unsigned char **in, long len)
+{
+	return (CMP_CERTIFIEDKEYPAIR*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CERTIFIEDKEYPAIR_it);
+}
+	int
+i2d_CMP_CERTIFIEDKEYPAIR(CMP_CERTIFIEDKEYPAIR *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CERTIFIEDKEYPAIR_it);
+}
+
+	CMP_CERTIFIEDKEYPAIR *
+CMP_CERTIFIEDKEYPAIR_new(void)
+{
+	return (CMP_CERTIFIEDKEYPAIR *)ASN1_item_new(&CMP_CERTIFIEDKEYPAIR_it);
+}
+
+void CMP_CERTIFIEDKEYPAIR_free(CMP_CERTIFIEDKEYPAIR *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CERTIFIEDKEYPAIR_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_REVDETAILS_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_REVDETAILS, certDetails),
+		.field_name = "certDetails",
+		.item = &CRMF_CERTTEMPLATE_it,
+	}
+	,
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_REVDETAILS, crlEntryDetails),
+			.field_name = "crlEntryDetails",
+			.item = &X509_EXTENSIONS_it,
+		}
+};
+const ASN1_ITEM CMP_REVDETAILS_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_REVDETAILS_seq_tt,
+	.tcount = sizeof(CMP_REVDETAILS_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_REVDETAILS),
+	.sname = "CMP_REVDETAILS",
+};
+
+
+	CMP_REVDETAILS *
+d2i_CMP_REVDETAILS(CMP_REVDETAILS **a, const unsigned char **in, long len)
+{
+	return (CMP_REVDETAILS*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_REVDETAILS_it);
+}
+	int
+i2d_CMP_REVDETAILS(CMP_REVDETAILS *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_REVDETAILS_it);
+}
+
+	CMP_REVDETAILS *
+CMP_REVDETAILS_new(void)
+{
+	return (CMP_REVDETAILS *)ASN1_item_new(&CMP_REVDETAILS_it);
+}
+
+void CMP_REVDETAILS_free(CMP_REVDETAILS *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_REVDETAILS_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_REVREQCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_REVREQCONTENT",
+	.item = &CMP_REVDETAILS_it,
+};
+
+const ASN1_ITEM CMP_REVREQCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_REVREQCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_REVREQCONTENT",
+};
+
+
+static const ASN1_TEMPLATE CMP_REVREPCONTENT_seq_tt[] = {
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF,
+		.tag = 0,
+		.offset = offsetof(CMP_REVREPCONTENT, status),
+		.field_name = "status",
+		.item = & CMP_PKISTATUSINFO_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_REVREPCONTENT, certId),
+		.field_name = "certId",
+		.item = &CRMF_CERTID_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 1,
+		.offset = offsetof(CMP_REVREPCONTENT, crls),
+		.field_name = "crls",
+		.item = &X509_it,
+	}
+};
+const ASN1_ITEM CMP_REVREPCONTENT_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_REVREPCONTENT_seq_tt,
+	.tcount = sizeof(CMP_REVREPCONTENT_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_REVREPCONTENT),
+	.sname = "CMP_REVREPCONTENT",
+};
+
+
+	CMP_REVREPCONTENT *
+d2i_CMP_REVREPCONTENT(CMP_REVREPCONTENT **a, const unsigned char **in, long len)
+{
+	return (CMP_REVREPCONTENT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_REVREPCONTENT_it);
+}
+	int
+i2d_CMP_REVREPCONTENT(CMP_REVREPCONTENT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_REVREPCONTENT_it);
+}
+
+	CMP_REVREPCONTENT *
+CMP_REVREPCONTENT_new(void)
+{
+	return (CMP_REVREPCONTENT *)ASN1_item_new(&CMP_REVREPCONTENT_it);
+}
+
+void CMP_REVREPCONTENT_free(CMP_REVREPCONTENT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_REVREPCONTENT_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_KEYRECREPCONTENT_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_KEYRECREPCONTENT, status),
+		.field_name = "status",
+		.item = &CMP_PKISTATUSINFO_it,
+	}
+	,
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_KEYRECREPCONTENT, newSigCert),
+			.field_name = "newSigCert",
+			.item = &X509_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 1,
+			.offset = offsetof(CMP_KEYRECREPCONTENT, caCerts),
+			.field_name = "caCerts",
+			.item = &X509_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 2,
+			.offset = offsetof(CMP_KEYRECREPCONTENT, keyPairHist),
+			.field_name = "keyPairHist",
+			.item = &X509_it,
+		}
+};
+const ASN1_ITEM CMP_KEYRECREPCONTENT_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_KEYRECREPCONTENT_seq_tt,
+	.tcount = sizeof(CMP_KEYRECREPCONTENT_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_KEYRECREPCONTENT),
+	.sname = "CMP_KEYRECREPCONTENT",
+};
+
+
+	CMP_KEYRECREPCONTENT *
+d2i_CMP_KEYRECREPCONTENT(CMP_KEYRECREPCONTENT **a, const unsigned char **in, long len)
+{
+	return (CMP_KEYRECREPCONTENT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_KEYRECREPCONTENT_it);
+}
+	int
+i2d_CMP_KEYRECREPCONTENT(CMP_KEYRECREPCONTENT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_KEYRECREPCONTENT_it);
+}
+
+	CMP_KEYRECREPCONTENT *
+CMP_KEYRECREPCONTENT_new(void)
+{
+	return (CMP_KEYRECREPCONTENT *)ASN1_item_new(&CMP_KEYRECREPCONTENT_it);
+}
+
+void CMP_KEYRECREPCONTENT_free(CMP_KEYRECREPCONTENT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_KEYRECREPCONTENT_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_PKISTATUS_item_tt =
+{
+	.flags = ASN1_TFLG_UNIVERSAL,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "status",
+	.item = &ASN1_INTEGER_it,
+};
+
+const ASN1_ITEM CMP_PKISTATUS_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_PKISTATUS_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_PKISTATUS",
+};
+
+static const ASN1_TEMPLATE CMP_PKISTATUSINFO_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_PKISTATUSINFO, status),
+		.field_name = "status",
+		.item = &CMP_PKISTATUS_it,
+	}
+	,
+		/* CMP_PKIFREETEXT is effectively a sequence of ASN1_UTF8STRING so it is used directly */
+		{
+			.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_PKISTATUSINFO, statusString),
+			.field_name = "statusString",
+			.item = &ASN1_UTF8STRING_it,
+		},
+		/* CMP_PKIFAILUREINFO is effectively ASN1_BIT_STRING so it is used directly */
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_PKISTATUSINFO, failInfo),
+			.field_name = "failInfo",
+			.item = &ASN1_BIT_STRING_it,
+		}
+};
+const ASN1_ITEM CMP_PKISTATUSINFO_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_PKISTATUSINFO_seq_tt,
+	.tcount = sizeof(CMP_PKISTATUSINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_PKISTATUSINFO),
+	.sname = "CMP_PKISTATUSINFO",
+};
+
+
+	CMP_PKISTATUSINFO *
+d2i_CMP_PKISTATUSINFO(CMP_PKISTATUSINFO **a, const unsigned char **in, long len)
+{
+	return (CMP_PKISTATUSINFO*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_PKISTATUSINFO_it);
+}
+	int
+i2d_CMP_PKISTATUSINFO(CMP_PKISTATUSINFO *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_PKISTATUSINFO_it);
+}
+
+	CMP_PKISTATUSINFO *
+CMP_PKISTATUSINFO_new(void)
+{
+	return (CMP_PKISTATUSINFO *)ASN1_item_new(&CMP_PKISTATUSINFO_it);
+}
+
+void CMP_PKISTATUSINFO_free(CMP_PKISTATUSINFO *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_PKISTATUSINFO_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CMP_CERTSTATUS_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_CERTSTATUS, certHash),
+		.field_name = "certHash",
+		.item = &ASN1_OCTET_STRING_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_CERTSTATUS, certReqId),
+			.field_name = "certReqId",
+			.item = &ASN1_INTEGER_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_CERTSTATUS, statusInfo),
+			.field_name = "statusInfo",
+			.item = &CMP_PKISTATUSINFO_it,
+		}
+};
+const ASN1_ITEM CMP_CERTSTATUS_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_CERTSTATUS_seq_tt,
+	.tcount = sizeof(CMP_CERTSTATUS_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CERTSTATUS),
+	.sname = "CMP_CERTSTATUS",
+};
+
+
+	CMP_CERTSTATUS *
+d2i_CMP_CERTSTATUS(CMP_CERTSTATUS **a, const unsigned char **in, long len)
+{
+	return (CMP_CERTSTATUS*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CERTSTATUS_it);
+}
+	int
+i2d_CMP_CERTSTATUS(CMP_CERTSTATUS *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CERTSTATUS_it);
+}
+
+	CMP_CERTSTATUS *
+CMP_CERTSTATUS_new(void)
+{
+	return (CMP_CERTSTATUS *)ASN1_item_new(&CMP_CERTSTATUS_it);
+}
+
+void CMP_CERTSTATUS_free(CMP_CERTSTATUS *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CERTSTATUS_it);
+}
+
+
+
+/* the PKCS10 structures are untested */
+static const ASN1_TEMPLATE PKCS10_ATTRIBUTE_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(PKCS10_ATTRIBUTE, id),
+		.field_name = "id",
+		.item = &ASN1_OBJECT_it,
+	}
+	,
+		{
+		.flags = ASN1_TFLG_SEQUENCE_OF,
+		.tag = 0,
+		.offset = offsetof(PKCS10_ATTRIBUTE, values),
+		.field_name = "values",
+		.item = & ASN1_ANY_it,
+	},
+};
+const ASN1_ITEM PKCS10_ATTRIBUTE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = PKCS10_ATTRIBUTE_seq_tt,
+	.tcount = sizeof(PKCS10_ATTRIBUTE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(PKCS10_ATTRIBUTE),
+	.sname = "PKCS10_ATTRIBUTE",
+};
+
+
+	PKCS10_ATTRIBUTE *
+d2i_PKCS10_ATTRIBUTE(PKCS10_ATTRIBUTE **a, const unsigned char **in, long len)
+{
+	return (PKCS10_ATTRIBUTE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&PKCS10_ATTRIBUTE_it);
+}
+	int
+i2d_PKCS10_ATTRIBUTE(PKCS10_ATTRIBUTE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS10_ATTRIBUTE_it);
+}
+
+	PKCS10_ATTRIBUTE *
+PKCS10_ATTRIBUTE_new(void)
+{
+	return (PKCS10_ATTRIBUTE *)ASN1_item_new(&PKCS10_ATTRIBUTE_it);
+}
+
+void PKCS10_ATTRIBUTE_free(PKCS10_ATTRIBUTE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &PKCS10_ATTRIBUTE_it);
+}
+
+
+
+static const ASN1_TEMPLATE PKCS10_CERTIFICATIONREQUESTINFO_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(PKCS10_CERTIFICATIONREQUESTINFO, version),
+		.field_name = "version",
+		.item = &ASN1_INTEGER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(PKCS10_CERTIFICATIONREQUESTINFO, subject),
+			.field_name = "subject",
+			.item = &X509_NAME_it,
+		}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(PKCS10_CERTIFICATIONREQUESTINFO, subjectPKInfo),
+			.field_name = "subjectPKInfo",
+			.item = &X509_PUBKEY_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF,
+			.tag = 0,
+			.offset = offsetof(PKCS10_CERTIFICATIONREQUESTINFO, attributes),
+			.field_name = "attributes",
+			.item = &PKCS10_ATTRIBUTE_it,
+		},
+};
+const ASN1_ITEM PKCS10_CERTIFICATIONREQUESTINFO_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = PKCS10_CERTIFICATIONREQUESTINFO_seq_tt,
+	.tcount = sizeof(PKCS10_CERTIFICATIONREQUESTINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(PKCS10_CERTIFICATIONREQUESTINFO),
+	.sname = "PKCS10_CERTIFICATIONREQUESTINFO",
+};
+
+
+	PKCS10_CERTIFICATIONREQUESTINFO *
+d2i_PKCS10_CERTIFICATIONREQUESTINFO(PKCS10_CERTIFICATIONREQUESTINFO **a, const unsigned char **in, long len)
+{
+	return (PKCS10_CERTIFICATIONREQUESTINFO*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&PKCS10_CERTIFICATIONREQUESTINFO_it);
+}
+	int
+i2d_PKCS10_CERTIFICATIONREQUESTINFO(PKCS10_CERTIFICATIONREQUESTINFO *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS10_CERTIFICATIONREQUESTINFO_it);
+}
+
+	PKCS10_CERTIFICATIONREQUESTINFO *
+PKCS10_CERTIFICATIONREQUESTINFO_new(void)
+{
+	return (PKCS10_CERTIFICATIONREQUESTINFO *)ASN1_item_new(&PKCS10_CERTIFICATIONREQUESTINFO_it);
+}
+
+void PKCS10_CERTIFICATIONREQUESTINFO_free(PKCS10_CERTIFICATIONREQUESTINFO *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &PKCS10_CERTIFICATIONREQUESTINFO_it);
+}
+
+
+
+static const ASN1_TEMPLATE PKCS10_CERTIFICATIONREQUEST_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(PKCS10_CERTIFICATIONREQUEST, certificationRequestInfo),
+		.field_name = "certificationRequestInfo",
+		.item = &PKCS10_CERTIFICATIONREQUESTINFO_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(PKCS10_CERTIFICATIONREQUEST, signatureAlgorithm),
+			.field_name = "signatureAlgorithm",
+			.item = &X509_ALGOR_it,
+		}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(PKCS10_CERTIFICATIONREQUEST, signature),
+			.field_name = "signature",
+			.item = &ASN1_BIT_STRING_it,
+		}
+	,
+};
+const ASN1_ITEM PKCS10_CERTIFICATIONREQUEST_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = PKCS10_CERTIFICATIONREQUEST_seq_tt,
+	.tcount = sizeof(PKCS10_CERTIFICATIONREQUEST_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(PKCS10_CERTIFICATIONREQUEST),
+	.sname = "PKCS10_CERTIFICATIONREQUEST",
+};
+
+
+	PKCS10_CERTIFICATIONREQUEST *
+d2i_PKCS10_CERTIFICATIONREQUEST(PKCS10_CERTIFICATIONREQUEST **a, const unsigned char **in, long len)
+{
+	return (PKCS10_CERTIFICATIONREQUEST*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&PKCS10_CERTIFICATIONREQUEST_it);
+}
+	int
+i2d_PKCS10_CERTIFICATIONREQUEST(PKCS10_CERTIFICATIONREQUEST *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS10_CERTIFICATIONREQUEST_it);
+}
+
+	PKCS10_CERTIFICATIONREQUEST *
+PKCS10_CERTIFICATIONREQUEST_new(void)
+{
+	return (PKCS10_CERTIFICATIONREQUEST *)ASN1_item_new(&PKCS10_CERTIFICATIONREQUEST_it);
+}
+
+void PKCS10_CERTIFICATIONREQUEST_free(PKCS10_CERTIFICATIONREQUEST *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &PKCS10_CERTIFICATIONREQUEST_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_CERTCONFIRMCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_CERTCONFIRMCONTENT",
+	.item = &CMP_CERTSTATUS_it,
+};
+
+const ASN1_ITEM CMP_CERTCONFIRMCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_CERTCONFIRMCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_CERTCONFIRMCONTENT",
+};
+
+static const ASN1_TEMPLATE CMP_CERTRESPONSE_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_CERTRESPONSE, certReqId),
+		.field_name = "certReqId",
+		.item = &ASN1_INTEGER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_CERTRESPONSE, status),
+			.field_name = "status",
+			.item = &CMP_PKISTATUSINFO_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_CERTRESPONSE, certifiedKeyPair),
+			.field_name = "certifiedKeyPair",
+			.item = &CMP_CERTIFIEDKEYPAIR_it,
+		},
+		{
+			.flags = ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_CERTRESPONSE, rspInfo),
+			.field_name = "rspInfo",
+			.item = &ASN1_OCTET_STRING_it,
+		}
+};
+const ASN1_ITEM CMP_CERTRESPONSE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_CERTRESPONSE_seq_tt,
+	.tcount = sizeof(CMP_CERTRESPONSE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CERTRESPONSE),
+	.sname = "CMP_CERTRESPONSE",
+};
+
+
+	CMP_CERTRESPONSE *
+d2i_CMP_CERTRESPONSE(CMP_CERTRESPONSE **a, const unsigned char **in, long len)
+{
+	return (CMP_CERTRESPONSE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CERTRESPONSE_it);
+}
+	int
+i2d_CMP_CERTRESPONSE(CMP_CERTRESPONSE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CERTRESPONSE_it);
+}
+
+	CMP_CERTRESPONSE *
+CMP_CERTRESPONSE_new(void)
+{
+	return (CMP_CERTRESPONSE *)ASN1_item_new(&CMP_CERTRESPONSE_it);
+}
+
+void CMP_CERTRESPONSE_free(CMP_CERTRESPONSE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CERTRESPONSE_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_POLLREQ_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_POLLREQ, certReqId),
+		.field_name = "certReqId",
+		.item = &ASN1_INTEGER_it,
+	}
+
+};
+const ASN1_ITEM CMP_POLLREQ_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_POLLREQ_seq_tt,
+	.tcount = sizeof(CMP_POLLREQ_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_POLLREQ),
+	.sname = "CMP_POLLREQ",
+};
+
+
+	CMP_POLLREQ *
+d2i_CMP_POLLREQ(CMP_POLLREQ **a, const unsigned char **in, long len)
+{
+	return (CMP_POLLREQ*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_POLLREQ_it);
+}
+	int
+i2d_CMP_POLLREQ(CMP_POLLREQ *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_POLLREQ_it);
+}
+
+	CMP_POLLREQ *
+CMP_POLLREQ_new(void)
+{
+	return (CMP_POLLREQ *)ASN1_item_new(&CMP_POLLREQ_it);
+}
+
+void CMP_POLLREQ_free(CMP_POLLREQ *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_POLLREQ_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_POLLREQCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_POLLREQCONTENT",
+	.item = &CMP_POLLREQ_it,
+};
+
+const ASN1_ITEM CMP_POLLREQCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_POLLREQCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_POLLREQCONTENT",
+};
+
+static const ASN1_TEMPLATE CMP_POLLREP_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_POLLREP, certReqId),
+		.field_name = "certReqId",
+		.item = &ASN1_INTEGER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_POLLREP, checkAfter),
+			.field_name = "checkAfter",
+			.item = &ASN1_INTEGER_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_POLLREP, reason),
+			.field_name = "reason",
+			.item = &ASN1_UTF8STRING_it,
+		},
+};
+const ASN1_ITEM CMP_POLLREP_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_POLLREP_seq_tt,
+	.tcount = sizeof(CMP_POLLREP_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_POLLREP),
+	.sname = "CMP_POLLREP",
+};
+
+
+	CMP_POLLREP *
+d2i_CMP_POLLREP(CMP_POLLREP **a, const unsigned char **in, long len)
+{
+	return (CMP_POLLREP*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_POLLREP_it);
+}
+	int
+i2d_CMP_POLLREP(CMP_POLLREP *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_POLLREP_it);
+}
+
+	CMP_POLLREP *
+CMP_POLLREP_new(void)
+{
+	return (CMP_POLLREP *)ASN1_item_new(&CMP_POLLREP_it);
+}
+
+void CMP_POLLREP_free(CMP_POLLREP *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_POLLREP_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_POLLREPCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_POLLREPCONTENT",
+	.item = &CMP_POLLREP_it,
+};
+
+const ASN1_ITEM CMP_POLLREPCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_POLLREPCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_POLLREPCONTENT",
+};
+
+static const ASN1_TEMPLATE CMP_CERTREPMESSAGE_seq_tt[] = {
+	/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+	{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 1,
+		.offset = offsetof(CMP_CERTREPMESSAGE, caPubs),
+		.field_name = "caPubs",
+		.item = &X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF,
+		.tag = 0,
+		.offset = offsetof(CMP_CERTREPMESSAGE, response),
+		.field_name = "response",
+		.item = & CMP_CERTRESPONSE_it,
+	}
+};
+const ASN1_ITEM CMP_CERTREPMESSAGE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_CERTREPMESSAGE_seq_tt,
+	.tcount = sizeof(CMP_CERTREPMESSAGE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_CERTREPMESSAGE),
+	.sname = "CMP_CERTREPMESSAGE",
+};
+
+
+	CMP_CERTREPMESSAGE *
+d2i_CMP_CERTREPMESSAGE(CMP_CERTREPMESSAGE **a, const unsigned char **in, long len)
+{
+	return (CMP_CERTREPMESSAGE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_CERTREPMESSAGE_it);
+}
+	int
+i2d_CMP_CERTREPMESSAGE(CMP_CERTREPMESSAGE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_CERTREPMESSAGE_it);
+}
+
+	CMP_CERTREPMESSAGE *
+CMP_CERTREPMESSAGE_new(void)
+{
+	return (CMP_CERTREPMESSAGE *)ASN1_item_new(&CMP_CERTREPMESSAGE_it);
+}
+
+void CMP_CERTREPMESSAGE_free(CMP_CERTREPMESSAGE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_CERTREPMESSAGE_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_GENMSGCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_GENMSGCONTENT",
+	.item = &CMP_INFOTYPEANDVALUE_it,
+};
+
+const ASN1_ITEM CMP_GENMSGCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_GENMSGCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_GENMSGCONTENT",
+};
+
+static const ASN1_TEMPLATE CMP_GENREPCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_GENREPCONTENT",
+	.item = &CMP_INFOTYPEANDVALUE_it,
+};
+
+const ASN1_ITEM CMP_GENREPCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_GENREPCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_GENREPCONTENT",
+};
+
+static const ASN1_TEMPLATE CMP_CRLANNCONTENT_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_CRLANNCONTENT",
+	.item = &X509_CRL_it,
+};
+
+const ASN1_ITEM CMP_CRLANNCONTENT_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_CRLANNCONTENT_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_CRLANNCONTENT",
+};
+
+static const ASN1_TEMPLATE CMP_PKIBODY_ch_tt[] = {
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 0,
+		.offset = offsetof(CMP_PKIBODY, value.ir),
+		.field_name = "value.ir",
+		.item = &CRMF_CERTREQMESSAGES_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 1,
+		.offset = offsetof(CMP_PKIBODY, value.ip),
+		.field_name = "value.ip",
+		.item = &CMP_CERTREPMESSAGE_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 2,
+		.offset = offsetof(CMP_PKIBODY, value.cr),
+		.field_name = "value.cr",
+		.item = &CRMF_CERTREQMESSAGES_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 3,
+		.offset = offsetof(CMP_PKIBODY, value.cp),
+		.field_name = "value.cp",
+		.item = &CMP_CERTREPMESSAGE_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 4,
+		.offset = offsetof(CMP_PKIBODY, value.p10cr),
+		.field_name = "value.p10cr",
+		.item = &PKCS10_CERTIFICATIONREQUEST_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 5,
+		.offset = offsetof(CMP_PKIBODY, value.popdecc),
+		.field_name = "value.popdecc",
+		.item = &CMP_POPODECKEYCHALLCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 6,
+		.offset = offsetof(CMP_PKIBODY, value.popdecr),
+		.field_name = "value.popdecr",
+		.item = &CMP_POPODECKEYRESPCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 7,
+		.offset = offsetof(CMP_PKIBODY, value.kur),
+		.field_name = "value.kur",
+		.item = &CRMF_CERTREQMESSAGES_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 8,
+		.offset = offsetof(CMP_PKIBODY, value.kup),
+		.field_name = "value.kup",
+		.item = &CMP_CERTREPMESSAGE_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 9,
+		.offset = offsetof(CMP_PKIBODY, value.krr),
+		.field_name = "value.krr",
+		.item = &CRMF_CERTREQMESSAGES_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 10,
+		.offset = offsetof(CMP_PKIBODY, value.krp),
+		.field_name = "value.krp",
+		.item = &CMP_KEYRECREPCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 11,
+		.offset = offsetof(CMP_PKIBODY, value.rr),
+		.field_name = "value.rr",
+		.item = &CMP_REVREQCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 12,
+		.offset = offsetof(CMP_PKIBODY, value.rp),
+		.field_name = "value.rp",
+		.item = &CMP_REVREPCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 13,
+		.offset = offsetof(CMP_PKIBODY, value.ccr),
+		.field_name = "value.ccr",
+		.item = &CRMF_CERTREQMESSAGES_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 14,
+		.offset = offsetof(CMP_PKIBODY, value.ccp),
+		.field_name = "value.ccp",
+		.item = &CMP_CERTREPMESSAGE_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 15,
+		.offset = offsetof(CMP_PKIBODY, value.ckuann),
+		.field_name = "value.ckuann",
+		.item = &CMP_CAKEYUPDANNCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 16,
+		.offset = offsetof(CMP_PKIBODY, value.cann),
+		.field_name = "value.cann",
+		.item = &X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 17,
+		.offset = offsetof(CMP_PKIBODY, value.rann),
+		.field_name = "value.rann",
+		.item = &CMP_REVANNCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 18,
+		.offset = offsetof(CMP_PKIBODY, value.crlann),
+		.field_name = "value.crlann",
+		.item = &CMP_CRLANNCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 19,
+		.offset = offsetof(CMP_PKIBODY, value.pkiconf),
+		.field_name = "value.pkiconf",
+		.item = &ASN1_ANY_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 20,
+		.offset = offsetof(CMP_PKIBODY, value.nested),
+		.field_name = "value.nested",
+		.item = &CMP_PKIMESSAGES_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 21,
+		.offset = offsetof(CMP_PKIBODY, value.genm),
+		.field_name = "value.genm",
+		.item = &CMP_GENMSGCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 22,
+		.offset = offsetof(CMP_PKIBODY, value.genp),
+		.field_name = "value.genp",
+		.item = &CMP_GENREPCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 23,
+		.offset = offsetof(CMP_PKIBODY, value.error),
+		.field_name = "value.error",
+		.item = &CMP_ERRORMSGCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 24,
+		.offset = offsetof(CMP_PKIBODY, value.certConf),
+		.field_name = "value.certConf",
+		.item = &CMP_CERTCONFIRMCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 25,
+		.offset = offsetof(CMP_PKIBODY, value.pollReq),
+		.field_name = "value.pollReq",
+		.item = &CMP_POLLREQCONTENT_it,
+	},
+	{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 26,
+		.offset = offsetof(CMP_PKIBODY, value.pollRep),
+		.field_name = "value.pollRep",
+		.item = &CMP_POLLREPCONTENT_it,
+	},
+};
+const ASN1_ITEM CMP_PKIBODY_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CMP_PKIBODY, type),
+	.templates = CMP_PKIBODY_ch_tt,
+	.tcount = sizeof(CMP_PKIBODY_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_PKIBODY),
+	.sname = "CMP_PKIBODY",
+};
+
+	CMP_PKIBODY *
+d2i_CMP_PKIBODY(CMP_PKIBODY **a, const unsigned char **in, long len)
+{
+	return (CMP_PKIBODY*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_PKIBODY_it);
+}
+	int
+i2d_CMP_PKIBODY(CMP_PKIBODY *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_PKIBODY_it);
+}
+
+	CMP_PKIBODY *
+CMP_PKIBODY_new(void)
+{
+	return (CMP_PKIBODY *)ASN1_item_new(&CMP_PKIBODY_it);
+}
+
+void CMP_PKIBODY_free(CMP_PKIBODY *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_PKIBODY_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_PKIHEADER_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_PKIHEADER, pvno),
+		.field_name = "pvno",
+		.item = &ASN1_INTEGER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_PKIHEADER, sender),
+			.field_name = "sender",
+			.item = &GENERAL_NAME_it,
+		}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_PKIHEADER, recipient),
+			.field_name = "recipient",
+			.item = &GENERAL_NAME_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_PKIHEADER, messageTime),
+			.field_name = "messageTime",
+			.item = &ASN1_GENERALIZEDTIME_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 1,
+			.offset = offsetof(CMP_PKIHEADER, protectionAlg),
+			.field_name = "protectionAlg",
+			.item = &X509_ALGOR_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 2,
+			.offset = offsetof(CMP_PKIHEADER, senderKID),
+			.field_name = "senderKID",
+			.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 3,
+			.offset = offsetof(CMP_PKIHEADER, recipKID),
+			.field_name = "recipKID",
+			.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 4,
+			.offset = offsetof(CMP_PKIHEADER, transactionID),
+			.field_name = "transactionID",
+			.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 5,
+			.offset = offsetof(CMP_PKIHEADER, senderNonce),
+			.field_name = "senderNonce",
+			.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 6,
+			.offset = offsetof(CMP_PKIHEADER, recipNonce),
+			.field_name = "recipNonce",
+			.item = &ASN1_OCTET_STRING_it,
+		},
+		/* CMP_PKIFREETEXT is effectively a sequence of ASN1_UTF8STRING so it is used directly */
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 7,
+			.offset = offsetof(CMP_PKIHEADER, freeText),
+			.field_name = "freeText",
+			.item = &ASN1_UTF8STRING_it,
+		},
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 8,
+			.offset = offsetof(CMP_PKIHEADER, generalInfo),
+			.field_name = "generalInfo",
+			.item = &CMP_INFOTYPEANDVALUE_it,
+		}
+};
+const ASN1_ITEM CMP_PKIHEADER_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_PKIHEADER_seq_tt,
+	.tcount = sizeof(CMP_PKIHEADER_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_PKIHEADER),
+	.sname = "CMP_PKIHEADER",
+};
+
+
+	CMP_PKIHEADER *
+d2i_CMP_PKIHEADER(CMP_PKIHEADER **a, const unsigned char **in, long len)
+{
+	return (CMP_PKIHEADER*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_PKIHEADER_it);
+}
+	int
+i2d_CMP_PKIHEADER(CMP_PKIHEADER *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_PKIHEADER_it);
+}
+
+	CMP_PKIHEADER *
+CMP_PKIHEADER_new(void)
+{
+	return (CMP_PKIHEADER *)ASN1_item_new(&CMP_PKIHEADER_it);
+}
+
+void CMP_PKIHEADER_free(CMP_PKIHEADER *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_PKIHEADER_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_PROTECTEDPART_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_PKIMESSAGE, header),
+		.field_name = "header",
+		.item = &CMP_PKIHEADER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_PKIMESSAGE, body),
+			.field_name = "body",
+			.item = &CMP_PKIBODY_it,
+		}
+
+};
+const ASN1_ITEM CMP_PROTECTEDPART_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_PROTECTEDPART_seq_tt,
+	.tcount = sizeof(CMP_PROTECTEDPART_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_PROTECTEDPART),
+	.sname = "CMP_PROTECTEDPART",
+};
+
+
+	CMP_PROTECTEDPART *
+d2i_CMP_PROTECTEDPART(CMP_PROTECTEDPART **a, const unsigned char **in, long len)
+{
+	return (CMP_PROTECTEDPART*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_PROTECTEDPART_it);
+}
+	int
+i2d_CMP_PROTECTEDPART(CMP_PROTECTEDPART *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_PROTECTEDPART_it);
+}
+
+	CMP_PROTECTEDPART *
+CMP_PROTECTEDPART_new(void)
+{
+	return (CMP_PROTECTEDPART *)ASN1_item_new(&CMP_PROTECTEDPART_it);
+}
+
+void CMP_PROTECTEDPART_free(CMP_PROTECTEDPART *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_PROTECTEDPART_it);
+}
+
+;
+
+static const ASN1_TEMPLATE CMP_PKIMESSAGE_seq_tt[] = {
+	{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CMP_PKIMESSAGE, header),
+		.field_name = "header",
+		.item = &CMP_PKIHEADER_it,
+	}
+	,
+		{
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CMP_PKIMESSAGE, body),
+			.field_name = "body",
+			.item = &CMP_PKIBODY_it,
+		}
+	,
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+			.tag = 0,
+			.offset = offsetof(CMP_PKIMESSAGE, protection),
+			.field_name = "protection",
+			.item = &ASN1_BIT_STRING_it,
+		},
+		/* CMP_CMPCERTIFICATE is effectively X509 so it is used directly */
+		{
+			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+			.tag = 1,
+			.offset = offsetof(CMP_PKIMESSAGE, extraCerts),
+			.field_name = "extraCerts",
+			.item = &X509_it,
+		}
+};
+const ASN1_ITEM CMP_PKIMESSAGE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CMP_PKIMESSAGE_seq_tt,
+	.tcount = sizeof(CMP_PKIMESSAGE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CMP_PKIMESSAGE),
+	.sname = "CMP_PKIMESSAGE",
+};
+
+
+	CMP_PKIMESSAGE *
+d2i_CMP_PKIMESSAGE(CMP_PKIMESSAGE **a, const unsigned char **in, long len)
+{
+	return (CMP_PKIMESSAGE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CMP_PKIMESSAGE_it);
+}
+	int
+i2d_CMP_PKIMESSAGE(CMP_PKIMESSAGE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CMP_PKIMESSAGE_it);
+}
+
+	CMP_PKIMESSAGE *
+CMP_PKIMESSAGE_new(void)
+{
+	return (CMP_PKIMESSAGE *)ASN1_item_new(&CMP_PKIMESSAGE_it);
+}
+
+void CMP_PKIMESSAGE_free(CMP_PKIMESSAGE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CMP_PKIMESSAGE_it);
+}
+
+
+
+static const ASN1_TEMPLATE CMP_PKIMESSAGES_item_tt =
+{
+	.flags = ASN1_TFLG_SEQUENCE_OF,
+	.tag = 0,
+	.offset = 0,
+	.field_name = "CMP_PKIMESSAGES",
+	.item = &CMP_PKIMESSAGE_it,
+};
+
+const ASN1_ITEM CMP_PKIMESSAGES_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CMP_PKIMESSAGES_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CMP_PKIMESSAGES",
+};
+
diff -Naur crypto/cmp/cmp_ctx.c crypto-/cmp/cmp_ctx.c
--- cryptoold/cmp/cmp_ctx.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_ctx.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,1376 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* crypto/cmp/cmp_ctx.c
+ * CMP (RFC 4210) context functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <openssl/opensslconf.h>
+#include <openssl/crypto.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/cmp.h>
+#include <openssl/crmf.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/err.h>
+#include <string.h>
+#include <dirent.h>
+
+/* NAMING
+ * The 0 version uses the supplied structure pointer directly in the parent and
+ * it will be freed up when the parent is freed. In the above example crl would
+ * be freed but rev would not.
+ *
+ * The 1 function uses a copy of the supplied structure pointer (or in some
+ * cases increases its link count) in the parent and so both (x and obj above)
+ * should be freed up.
+ */
+
+/* OpenSSL ASN.1 macros in CTX struct */
+static const ASN1_TEMPLATE CMP_CTX_seq_tt[] = {
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, referenceValue),
+		.field_name = "referenceValue",
+		.item = & ASN1_OCTET_STRING_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, secretValue),
+		.field_name = "secretValue",
+		.item = & ASN1_OCTET_STRING_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, regToken),
+		.field_name = "regToken",
+		.item = & ASN1_UTF8STRING_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, srvCert),
+		.field_name = "srvCert",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, clCert),
+		.field_name = "clCert",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, oldClCert),
+		.field_name = "oldClCert",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, subjectName),
+		.field_name = "subjectName",
+		.item = & X509_NAME_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, subjectAltNames),
+		.field_name = "subjectAltNames",
+		.item = & GENERAL_NAME_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, recipient),
+		.field_name = "recipient",
+		.item = & X509_NAME_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, caPubs),
+		.field_name = "caPubs",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, extraCertsOut),
+		.field_name = "extraCertsOut",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, extraCertsIn),
+		.field_name = "extraCertsIn",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, newClCert),
+		.field_name = "newClCert",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, transactionID),
+		.field_name = "transactionID",
+		.item = & ASN1_OCTET_STRING_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, recipNonce),
+		.field_name = "recipNonce",
+		.item = & ASN1_OCTET_STRING_it,
+	},
+	{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, validatedSrvCert),
+		.field_name = "validatedSrvCert",
+		.item = & X509_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, lastStatusString),
+		.field_name = "lastStatusString",
+		.item = & ASN1_UTF8STRING_it,
+	},
+	{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CMP_CTX, policies),
+		.field_name = "policies",
+		.item = & POLICYINFO_it,
+	},
+};
+const ASN1_ITEM CMP_CTX_it = {
+  .itype = ASN1_ITYPE_SEQUENCE,
+  .utype = V_ASN1_SEQUENCE,
+  .templates = CMP_CTX_seq_tt,
+  .tcount = sizeof(CMP_CTX_seq_tt) / sizeof(ASN1_TEMPLATE),
+  .funcs = NULL,
+  .size = sizeof(CMP_CTX),
+  .sname = "CMP_CTX",
+};
+CMP_CTX *
+d2i_CMP_CTX(CMP_CTX **a, const unsigned char **in, long len) {
+  return (CMP_CTX*) ASN1_item_d2i((ASN1_VALUE **)a, in, len, &CMP_CTX_it);
+}
+
+int i2d_CMP_CTX(CMP_CTX*a, unsigned char **out) {
+  return ASN1_item_i2d((ASN1_VALUE*) a, out, &CMP_CTX_it);
+}
+
+CMP_CTX*
+CMP_CTX_new(void) {
+  return (CMP_CTX *) ASN1_item_new(&CMP_CTX_it);
+}
+
+void CMP_CTX_free(CMP_CTX *a) {
+  ASN1_item_free((ASN1_VALUE *)a, &CMP_CTX_it);
+}
+
+
+/* ############################################################################ *
+ * Returns a duplicate of the given stack of X509 certificates.
+ * ############################################################################ */
+static STACK_OF(X509)* X509_stack_dup(const STACK_OF(X509)* stack)
+	{
+	STACK_OF(X509) *newsk = NULL;
+	int i;
+
+	if (!stack) goto err;
+	if (!(newsk = sk_X509_new_null())) goto err;
+
+	for (i = 0; i < sk_X509_num(stack); i++)
+		sk_X509_push(newsk, X509_dup(sk_X509_value(stack, i)));
+
+	return newsk;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * Creates a copy of the given EVP_PKEY.
+ * TODO: is there really no other already existing way to do that?
+ * returns ptr to duplicated EVP_PKEY on success, NULL on error
+ * ############################################################################ */
+static EVP_PKEY *pkey_dup(const EVP_PKEY *pkey)
+	{
+	EVP_PKEY *pkeyDup = EVP_PKEY_new();
+	if (!pkeyDup) goto err;
+
+	switch (pkey->type)
+		{
+#ifndef OPENSSL_NO_RSA
+		case EVP_PKEY_RSA:
+			EVP_PKEY_set1_RSA(pkeyDup, pkey->pkey.rsa);
+			break;
+#endif
+#ifndef OPENSSL_NO_DSA
+		case EVP_PKEY_DSA:
+			EVP_PKEY_set1_DSA(pkeyDup, pkey->pkey.dsa);
+			break;
+#endif
+#ifndef OPENSSL_NO_DH
+		case EVP_PKEY_DH:
+			EVP_PKEY_set1_DH(pkeyDup, pkey->pkey.dh);
+			break;
+#endif
+#ifndef OPENSSL_NO_EC
+		case EVP_PKEY_EC:
+			EVP_PKEY_set1_EC_KEY(pkeyDup, pkey->pkey.ec);
+			break;
+#endif
+		default:
+			CMPerr(CMP_F_PKEY_DUP, CMP_R_UNSUPPORTED_KEY_TYPE);
+			goto err;
+		}
+	return pkeyDup;
+
+err:
+	if (pkeyDup) EVP_PKEY_free(pkeyDup);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Set certificate store containing root CA certs.
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_CTX_set0_trustedStore( CMP_CTX *ctx, X509_STORE *store)
+	{
+	if (!store) return 0;
+	if (ctx->trusted_store)
+		X509_STORE_free(ctx->trusted_store);
+	ctx->trusted_store = store;
+	return 1;
+	}
+
+/* ############################################################################ *
+ * Set certificate store containing intermediate certificates (for building
+ * our own cert chain to send in extraCerts).
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_CTX_set0_untrustedStore( CMP_CTX *ctx, X509_STORE *store)
+	{
+	if (!store) return 0;
+	if (ctx->untrusted_store)
+		X509_STORE_free(ctx->untrusted_store);
+	ctx->untrusted_store = store;
+	return 1;
+	}
+
+/* ################################################################ *
+ * Allocates and initializes a CMP_CTX context structure with some
+ * default values.
+ * OpenSSL ASN.1 types are initialized to NULL by the call to CMP_CTX_new()
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_init( CMP_CTX *ctx)
+	{
+	if (!ctx)
+		{
+		CMPerr(CMP_F_CMP_CTX_INIT, CMP_R_INVALID_CONTEXT);
+		goto err;
+		}
+
+	/* all other elements are initialized through ASN1 macros */
+	ctx->pkey			 = NULL;
+	ctx->newPkey		 = NULL;
+	ctx->serverName		 = NULL;
+	/* serverPath has to be an empty sting if not set since it is not mandatory */
+	/* this will be freed by CMP_CTX_delete() */
+	ctx->serverPath		 = OPENSSL_malloc(1);
+	ctx->serverPath[0]	 = 0;
+	ctx->serverPort		 = 0;
+	ctx->proxyName		 = NULL;
+	ctx->proxyPort		 = 0;
+	ctx->implicitConfirm = 0;
+	ctx->popoMethod		 = CRMF_POPO_SIGNATURE;
+	ctx->HttpTimeOut	 = 2*60;
+	ctx->setSubjectAltNameCritical = 0;
+	ctx->sourceAddress   = NULL;
+	ctx->lastHTTPCode    = 0;
+	ctx->useTLS    = 0;
+
+	ctx->error_cb = NULL;
+	ctx->debug_cb = (cmp_logfn_t) puts;
+	ctx->certConf_cb = NULL;
+
+	ctx->trusted_store	 = X509_STORE_new();
+	ctx->untrusted_store = X509_STORE_new();
+
+	ctx->maxPollTime = 0;
+
+	ctx->lastPKIStatus = 0;
+	ctx->failInfoCode = 0;
+
+	ctx->permitTAInExtraCertsForIR = 0;
+	ctx->validatedSrvCert = NULL;
+
+	/* initialize OpenSSL */
+	OpenSSL_add_all_ciphers();
+	OpenSSL_add_all_digests();
+	ERR_load_crypto_strings();
+
+	return 1;
+
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * frees CMP_CTX variables allocated in CMP_CTX_init and calls CMP_CTX_free
+ * ################################################################ */
+void CMP_CTX_delete(CMP_CTX *ctx)
+	{
+	if (!ctx) return;
+	if (ctx->pkey) EVP_PKEY_free(ctx->pkey);
+	if (ctx->newPkey) EVP_PKEY_free(ctx->newPkey);
+
+	if (ctx->serverName) OPENSSL_free(ctx->serverName);
+	if (ctx->serverPath) OPENSSL_free(ctx->serverPath);
+	if (ctx->proxyName) OPENSSL_free(ctx->proxyName);
+	if (ctx->trusted_store) X509_STORE_free(ctx->trusted_store);
+	if (ctx->untrusted_store) X509_STORE_free(ctx->untrusted_store);
+
+	CMP_CTX_free(ctx);
+	}
+
+/* ################################################################ *
+ * creates and initializes a CMP_CTX structure
+ * returns pointer to created CMP_CTX on success, NULL on error
+ * ################################################################ */
+CMP_CTX *CMP_CTX_create(void)
+	{
+	CMP_CTX *ctx=NULL;
+
+	if( !(ctx = CMP_CTX_new())) goto err;
+	if( !(CMP_CTX_init(ctx))) goto err;
+
+	return ctx;
+err:
+	CMPerr(CMP_F_CMP_CTX_CREATE, CMP_R_UNABLE_TO_CREATE_CONTEXT);
+	if (ctx) CMP_CTX_free(ctx);
+	return NULL;
+	}
+
+/* ################################################################ *
+ * returns latest failInfoCode, -1 on error
+ * ################################################################ */
+unsigned long CMP_CTX_get_failInfoCode( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	return ctx->failInfoCode;
+err:
+	return -1;
+	}
+
+/* ################################################################ *
+ * returns the statusString from the last CertRepMessage, NULL on error
+ * ################################################################ */
+STACK_OF(ASN1_UTF8STRING) *CMP_CTX_statusString_get( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	return ctx->lastStatusString;
+err:
+	return NULL;
+	}
+
+/* ################################################################ *
+ * Set callback function for checking if the cert is ok or should
+ * it be rejected.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set_certConf_callback( CMP_CTX *ctx, cmp_certConfFn_t cb)
+	{
+	if (!ctx) goto err;
+	ctx->certConf_cb = cb;
+	return 1;
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set a callback function which will receive debug messages.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set_error_callback( CMP_CTX *ctx, cmp_logfn_t cb)
+	{
+	if (!ctx) goto err;
+	ctx->error_cb = cb;
+	return 1;
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set a callback function which will receive error messages.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set_debug_callback( CMP_CTX *ctx, cmp_logfn_t cb)
+	{
+	if (!ctx) goto err;
+	ctx->debug_cb = cb;
+	return 1;
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the reference value to be used for identification (i.e. the
+ * username) when using PBMAC.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len)
+	{
+	if (!ctx || !ref)
+		{
+		CMPerr(CMP_F_CMP_CTX_SET1_REFERENCEVALUE, CMP_R_INVALID_PARAMETERS);
+		goto err;
+		}
+
+	if (!ctx->referenceValue)
+		ctx->referenceValue = ASN1_OCTET_STRING_new();
+
+	return (ASN1_OCTET_STRING_set(ctx->referenceValue, ref, len));
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the password to be used for protecting messages with PBMAC
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len)
+	{
+	if (!ctx) goto err;
+	if (!sec) goto err;
+
+	if (!ctx->secretValue)
+		ctx->secretValue = ASN1_OCTET_STRING_new();
+
+	return (ASN1_OCTET_STRING_set(ctx->secretValue, sec, len));
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SECRETVALUE, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the registration token value (the password for EJBCA for example)
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_regToken( CMP_CTX *ctx, const char *regtoken, const size_t len)
+	{
+	if (!ctx) goto err;
+	if (!regtoken) goto err;
+
+	if (!ctx->regToken)
+		ctx->regToken = ASN1_UTF8STRING_new();
+
+	return (ASN1_STRING_set(ctx->regToken, regtoken, len));
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_REGTOKEN, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Returns the stack of certificates received in a response message.
+ * The stack is duplicated so the caller must handle freeing it!
+ * returns pointer to created stack on success, NULL on error
+ * ################################################################ */
+STACK_OF(X509)* CMP_CTX_extraCertsIn_get1( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsIn) return 0;
+	return X509_stack_dup(ctx->extraCertsIn);
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSIN_GET1, CMP_R_NULL_ARGUMENT);
+	return NULL;
+	}
+
+/* ################################################################ *
+ * Pops and returns one certificate from the received extraCerts field
+ * returns pointer certificate on success, NULL on error
+ * ################################################################ */
+X509 *CMP_CTX_extraCertsIn_pop( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsIn) return NULL;
+	return sk_X509_pop(ctx->extraCertsIn);
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSIN_POP, CMP_R_NULL_ARGUMENT);
+	return NULL;
+	}
+
+/* ################################################################ *
+ * Returns the number of extraCerts received in a response, 0 on error
+ * TODO: should that return something else on error?
+ * ################################################################ */
+int CMP_CTX_extraCertsIn_num( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsIn) return 0;
+	return sk_X509_num(ctx->extraCertsIn);
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSIN_NUM, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Copies the given stack of inbound X509 certificates to extraCertsIn of
+ * the CMP_CTX structure so that they may be retrieved later.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_extraCertsIn( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsIn)
+	{
+	if (!ctx) goto err;
+	if (!extraCertsIn) goto err;
+
+	/* if there are already inbound extraCerts on the stack delete them */
+	if (ctx->extraCertsIn)
+		{
+		sk_X509_pop_free(ctx->extraCertsIn, X509_free);
+		ctx->extraCertsIn = NULL;
+		}
+
+	if (!(ctx->extraCertsIn = X509_stack_dup(extraCertsIn))) goto err;
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_EXTRACERTSIN, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Duplicate and push the given X509 certificate to the stack of
+ * outbound certificates to send in the extraCerts field.
+ * returns number of pushed certificates on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_extraCertsOut_push1( CMP_CTX *ctx, const X509 *val)
+	{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsOut && !(ctx->extraCertsOut = sk_X509_new_null())) return 0;
+	return sk_X509_push(ctx->extraCertsOut, X509_dup((X509*)val));
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSOUT_PUSH1, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * load all the intermediate certificates from the given stack into untrusted_store
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_CTX_loadUntrustedStack(CMP_CTX *ctx, STACK_OF(X509) *stack)
+	{
+	int i;
+	EVP_PKEY *pubkey;
+	X509 *cert;
+
+	if (!stack) goto err;
+	if (!ctx->untrusted_store && !( ctx->untrusted_store = X509_STORE_new() ))
+		goto err;
+
+	for (i = 0; i < sk_X509_num(stack); i++)
+		{
+		if(!(cert = sk_X509_value(stack, i))) goto err;
+		if(!(pubkey = X509_get_pubkey(cert))) continue;
+
+		/* don't add self-signed certs here */
+		if (!X509_verify(cert, pubkey))
+			X509_STORE_add_cert(ctx->untrusted_store, cert);  /* don't fail as adding existing certificate to store would cause error */
+		EVP_PKEY_free(pubkey);
+		}
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * Return the number of certificates we have in the outbound
+ * extraCerts stack, 0 on error
+ * TODO: should that return something else on error?
+ * ################################################################ */
+int CMP_CTX_extraCertsOut_num( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsOut) return 0;
+	return sk_X509_num(ctx->extraCertsOut);
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSOUT_NUM, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Duplicate and set the given stack as the new stack of X509
+ * certificates to send out in the extraCerts field.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_extraCertsOut( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsOut)
+	{
+	if (!ctx) goto err;
+	if (!extraCertsOut) goto err;
+
+	if (ctx->extraCertsOut)
+		{
+		sk_X509_pop_free(ctx->extraCertsOut, X509_free);
+		ctx->extraCertsOut = NULL;
+		}
+
+	if (!(ctx->extraCertsOut = X509_stack_dup(extraCertsOut))) goto err;
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_EXTRACERTSOUT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * CMP_CTX_policyOID_push1() adds the certificate policy OID given by the
+ * string to the X509_EXTENSIONS of the certificate template we are
+ * requesting.
+ * ################################################################ */
+int CMP_CTX_policyOID_push1( CMP_CTX *ctx, const char *policyOID)
+{
+	if (!ctx || !policyOID) goto err;
+
+	if (!ctx->policies)
+		ctx->policies = CERTIFICATEPOLICIES_new();
+	if (!ctx->policies) goto err;
+
+	POLICYINFO *pol = POLICYINFO_new();
+	if (!pol) goto err;
+
+	pol->policyid = OBJ_txt2obj(policyOID, 1);
+	sk_POLICYINFO_push(ctx->policies, pol);
+
+	return 1;
+
+err:
+	return 0;
+}
+
+
+/* ################################################################ *
+ * Returns a duplicate of the stack received X509 certificates that
+ * were received in the caPubs field of the last response message.
+ * returns NULL on error
+ * ################################################################ */
+STACK_OF(X509)* CMP_CTX_caPubs_get1( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->caPubs) return NULL;
+	return X509_stack_dup(ctx->caPubs);
+err:
+	CMPerr(CMP_F_CMP_CTX_CAPUBS_GET1, CMP_R_NULL_ARGUMENT);
+	return NULL;
+	}
+
+/* ################################################################ *
+ * Pop one certificate out of the list of certificates received in
+ * the caPubs field, returns NULL on errror or when the stack is empty
+ * ################################################################ */
+X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->caPubs) return NULL;
+	return sk_X509_pop(ctx->caPubs);
+err:
+	CMPerr(CMP_F_CMP_CTX_CAPUBS_POP, CMP_R_NULL_ARGUMENT);
+	return NULL;
+	}
+
+/* ################################################################ *
+ * Return the number of certificates received in the caPubs field
+ * of the last response message, 0 on error
+ * TODO: should that return something else on error?
+ * ################################################################ */
+int CMP_CTX_caPubs_num( CMP_CTX *ctx)
+	{
+	if (!ctx) goto err;
+	if (!ctx->caPubs) return 0;
+	return sk_X509_num(ctx->caPubs);
+err:
+	CMPerr(CMP_F_CMP_CTX_CAPUBS_NUM, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Duplciate and copy the given stack of certificates to the given
+ * CMP_CTX structure so that they may be retrieved later.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs)
+	{
+	if (!ctx) goto err;
+	if (!caPubs) goto err;
+
+	if (ctx->caPubs)
+		{
+		sk_X509_pop_free(ctx->caPubs, X509_free);
+		ctx->caPubs = NULL;
+		}
+
+	if (!(ctx->caPubs = X509_stack_dup(caPubs))) goto err;
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_CAPUBS, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Sets the CA certificate that is to be used for verifying response
+ * messages. Pointer is not consumed.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_srvCert( CMP_CTX *ctx, const X509 *cert)
+	{
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->srvCert)
+		{
+		X509_free(ctx->srvCert);
+		ctx->srvCert = NULL;
+		}
+
+	if (!(ctx->srvCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SRVCERT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the X509 name of the recipient. Set in the PKIHeader.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_recipient( CMP_CTX *ctx, const X509_NAME *name)
+	{
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->recipient)
+		{
+		X509_NAME_free(ctx->recipient);
+		ctx->recipient = NULL;
+		}
+
+	if (!(ctx->recipient = X509_NAME_dup( (X509_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_RECIPIENT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the subject name that will be placed in the certificate
+ * request. This will be the subject name on the received certificate.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name)
+	{
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->subjectName)
+		{
+		X509_NAME_free(ctx->subjectName);
+		ctx->subjectName = NULL;
+		}
+
+	if (!(ctx->subjectName = X509_NAME_dup( (X509_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SUBJECTNAME, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Push a GENERAL_NAME structure that will be added to the CRMF
+ * request's extensions field to request subject alternative names.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_subjectAltName_push1( CMP_CTX *ctx, const GENERAL_NAME *name)
+	{
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (!ctx->subjectAltNames && !(ctx->subjectAltNames = sk_GENERAL_NAME_new_null()))
+		goto err;
+
+	if (!sk_GENERAL_NAME_push(ctx->subjectAltNames, GENERAL_NAME_dup( (GENERAL_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SUBJECTALTNAME_PUSH1, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set our own client certificate, used for example in KUR and when
+ * doing the IR with existing certificate.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert)
+	{
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->clCert)
+		{
+		X509_free(ctx->clCert);
+		ctx->clCert = NULL;
+		}
+
+	if (!(ctx->clCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_CLCERT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the old certificate that we are updating in KUR
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_oldClCert( CMP_CTX *ctx, const X509 *cert)
+	{
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->oldClCert)
+		{
+		X509_free(ctx->oldClCert);
+		ctx->oldClCert = NULL;
+		}
+
+	if (!(ctx->oldClCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_OLDCLCERT, CMP_R_NULL_ARGUMENT);
+ 	return 0;
+ 	}
+
+/* ################################################################ *
+ * sets the (newly received in IP/KUP/CP) client Certificate to the context
+ * returns 1 on success, 0 on error
+ * TODO: this only permits for one client cert to be received...
+ * ################################################################ */
+int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert)
+	{
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->newClCert)
+		{
+		X509_free(ctx->newClCert);
+		ctx->newClCert = NULL;
+		}
+
+	if (!(ctx->newClCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_NEWCLCERT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the client's private key. This creates a duplicate of the key
+ * so the given pointer is not used directly.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey)
+	{
+	EVP_PKEY *pkeyDup = NULL;
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	pkeyDup = pkey_dup(pkey);;
+	return CMP_CTX_set0_pkey(ctx, pkeyDup);
+
+err:
+	if (pkeyDup) EVP_PKEY_free(pkeyDup);
+	CMPerr(CMP_F_CMP_CTX_SET1_PKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the client's current private key. NOTE: this version uses
+ * the given pointer directly!
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey)
+	{
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	if (ctx->pkey)
+		{
+		EVP_PKEY_free(ctx->pkey);
+		ctx->pkey = NULL;
+		}
+
+	ctx->pkey = (EVP_PKEY*) pkey;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET0_PKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set new key pa8r. Used for example when doing Key Update.
+ * The key is duplicated so the original pointer is not directly used.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey)
+	{
+	EVP_PKEY *pkeyDup = NULL;
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	pkeyDup = pkey_dup(pkey);
+	return CMP_CTX_set0_newPkey(ctx, pkeyDup);
+
+err:
+	if (pkeyDup) EVP_PKEY_free(pkeyDup);
+	CMPerr(CMP_F_CMP_CTX_SET1_NEWPKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set new key pair. Used e.g. when doing Key Update.
+ * NOTE: uses the pointer directly!
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey)
+	{
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	if (ctx->newPkey)
+		{
+		EVP_PKEY_free(ctx->newPkey);
+		ctx->newPkey = NULL;
+		}
+
+	ctx->newPkey = (EVP_PKEY*) pkey;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET0_NEWPKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * sets the given transactionID to the context
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id)
+	{
+	if (!ctx) goto err;
+	if (!id) goto err;
+
+	if (ctx->transactionID)
+		{
+		ASN1_OCTET_STRING_free(ctx->transactionID);
+		ctx->transactionID = NULL;
+		}
+
+	if (!(ctx->transactionID = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)id)))
+		return 0;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_TRANSACTIONID, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+
+/* ################################################################ *
+ * sets the given nonce to be used for the recipNonce in the next message to be
+ * created.
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce)
+	{
+	if (!ctx) goto err;
+	if (!nonce) goto err;
+
+	if (ctx->recipNonce)
+		{
+		ASN1_OCTET_STRING_free(ctx->recipNonce);
+		ctx->recipNonce = NULL;
+		}
+
+	if (!(ctx->recipNonce = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)nonce)))
+		return 0;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_RECIPNONCE, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the hostname of the (HTTP) proxy server to use for all connections
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_proxyName( CMP_CTX *ctx, const char *name)
+	{
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->proxyName)
+		{
+		OPENSSL_free( ctx->proxyName);
+		ctx->proxyName = NULL;
+		}
+
+	ctx->proxyName = OPENSSL_malloc( strlen(name)+1);
+	strcpy( ctx->proxyName, name);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_PROXYNAME, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the (HTTP) hostname of the CA server
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name)
+	{
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->serverName)
+		{
+		OPENSSL_free( ctx->serverName);
+		ctx->serverName = NULL;
+		}
+
+	ctx->serverName = OPENSSL_malloc( strlen(name)+1);
+	strcpy( ctx->serverName, name);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SERVERNAME, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Sets the proof of possession method to be used when creating a certTemplate
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_popoMethod( CMP_CTX *ctx, int method)
+	{
+	if (!ctx) goto err;
+
+	ctx->popoMethod = method;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_POPOMETHOD, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * sets the timeout for the (HTTP) transport mechanism
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set_HttpTimeOut( CMP_CTX *ctx, int time)
+	{
+	if (!ctx) goto err;
+
+	ctx->HttpTimeOut = time;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET_HTTPTIMEOUT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * sets the (HTTP) proxy port to be used
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_proxyPort( CMP_CTX *ctx, int port)
+	{
+	if (!ctx) goto err;
+
+	ctx->proxyPort = port;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_PROXYPORT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * sets the (HTTP) server port to be used
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_sourceAddress( CMP_CTX *ctx, const char *ip)
+	{
+	if (!ctx) goto err;
+	if (!ip) goto err;
+
+	if (ctx->sourceAddress)
+		{
+		OPENSSL_free( ctx->sourceAddress);
+		ctx->sourceAddress = NULL;
+		}
+
+	ctx->sourceAddress = OPENSSL_malloc( strlen(ip)+1);
+	strcpy( ctx->sourceAddress, ip);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SOURCEADDRESS, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * sets the (HTTP) server port to be used
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port)
+	{
+	if (!ctx) goto err;
+
+	ctx->serverPort = port;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SERVERPORT, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Sets the HTTP path to be used on the server (e.g "pkix/")
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set1_serverPath( CMP_CTX *ctx, const char *path)
+	{
+	if (!ctx) goto err;
+
+	if (ctx->serverPath)
+		{
+		/* clear the old value */
+		OPENSSL_free( ctx->serverPath);
+		ctx->serverPath = 0;
+		}
+
+	if (!path)
+		{
+		/* clear the serverPath */
+		ctx->serverPath = OPENSSL_malloc(1);
+		ctx->serverPath[0] = 0;
+		return 1;
+		}
+
+	ctx->serverPath = OPENSSL_malloc( strlen(path)+1);
+	strcpy( ctx->serverPath, path);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SERVERPATH, CMP_R_NULL_ARGUMENT);
+	return 0;
+	}
+
+/* ################################################################ *
+ * Set the failinfo error code bits in CMP_CTX based on the given
+ * CMP_PKIFAILUREINFO structure
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set_failInfoCode(CMP_CTX *ctx, CMP_PKIFAILUREINFO *failInfo)
+	{
+	int i;
+
+	if (!ctx || !failInfo) return 0;
+
+	ctx->failInfoCode = 0;
+	for ( i=0; i <= CMP_PKIFAILUREINFO_MAX; i++)
+		if( ASN1_BIT_STRING_get_bit(failInfo, i))
+			ctx->failInfoCode |= 1 << i;
+
+	return 1;
+	}
+
+/* ################################################################ *
+ * Get the failinfo error code bits in CMP_CTX
+ * returns bitstring in ulong on success, -1 on error
+ * ################################################################ */
+unsigned long CMP_CTX_failInfoCode_get(CMP_CTX *ctx)
+	{
+	if (!ctx) return -1;
+	return ctx->failInfoCode;
+	}
+
+#if 0
+/* ################################################################ *
+ * pushes a given 0-terminated character string to ctx->freeText
+ * this is inteded for human consumption
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_push_freeText( CMP_CTX *ctx, const char *text)
+	{
+	ASN1_UTF8STRING *utf8string=NULL;
+
+	if (!ctx) goto err;
+	if (!text) goto err;
+
+	if (!ctx->freeText)
+		if( !(ctx->freeText = sk_ASN1_UTF8STRING_new())) goto err;
+
+	if( !(utf8string = ASN1_UTF8STRING_new())) goto err;
+	ASN1_UTF8STRING_set(utf8string, text, strlen(text));
+	if( !(sk_ASN1_UTF8STRING_push(ctx->freeText, utf8string) goto err;
+	return 1;/
+err:
+	CMP_printf( "ERROR in FILE: %s, LINE: %d\n", __FILE__, __LINE__);
+	if (utf8string) ASN1_UTF8STRING_free(utf8string);
+	return 0;
+	}
+#endif
+
+/* ################################################################ *
+ * sets a BOOLEAN option of the context to the "val" arg
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val)
+	{
+	if (!ctx) goto err;
+
+	switch (opt)
+		{
+		case CMP_CTX_OPT_IMPLICITCONFIRM:
+			ctx->implicitConfirm = val;
+			break;
+		case CMP_CTX_OPT_POPMETHOD:
+			ctx->popoMethod = val;
+			break;
+		case CMP_CTX_OPT_MAXPOLLTIME:
+			ctx->maxPollTime = val;
+			break;
+		case CMP_CTX_PERMIT_TA_IN_EXTRACERTS_FOR_IR:
+			ctx->permitTAInExtraCertsForIR = val;
+			break;
+		case CMP_CTX_SET_SUBJECTALTNAME_CRITICAL:
+			ctx->setSubjectAltNameCritical = val;
+			break;
+		case CMP_CTX_USE_TLS:
+			ctx->useTLS = val;
+			break;
+		default:
+			goto err;
+		}
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ################################################################ *
+ * Function used for printing debug messages if debug_cb is set
+ * (CMP_CTX_INIT defaults to puts)
+ * ################################################################ */
+void CMP_printf(const CMP_CTX *ctx, const char *fmt, ...)
+	{
+#ifdef CMP_DEBUG
+	va_list arg_ptr;
+	char buf[1024];
+
+	if (!ctx || !ctx->debug_cb) return;
+
+	va_start(arg_ptr, fmt);
+
+	vsnprintf(buf, sizeof(buf), fmt, arg_ptr);
+	ctx->debug_cb(buf);
+
+	va_end(arg_ptr);
+#endif
+	}
+
+/* ############################################################################ *
+ * This callback is used to print out the OpenSSL error queue via'
+ * ERR_print_errors_cb() to the ctx->error_cb() function set by the user
+ * returns always 1
+ * ############################################################################ */
+int CMP_CTX_error_callback(const char *str, size_t len, void *u)
+	{
+	CMP_CTX *ctx = (CMP_CTX*) u;
+	if (ctx && ctx->error_cb)
+		ctx->error_cb(str);
+	return 1;
+	}
+
diff -Naur crypto/cmp/cmp_err.c crypto-/cmp/cmp_err.c
--- cryptoold/cmp/cmp_err.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_err.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,221 @@
+/* crypto/cmp/cmp_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/cmp.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_CMP,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_CMP,0,reason)
+
+static ERR_STRING_DATA CMP_str_functs[]=
+	{
+{ERR_FUNC(CMP_F_CMP_CALC_PROTECTION_PBMAC),	"CMP_calc_protection_pbmac"},
+{ERR_FUNC(CMP_F_CMP_CALC_PROTECTION_SIG),	"CMP_CALC_PROTECTION_SIG"},
+{ERR_FUNC(CMP_F_CMP_CERTCONF_NEW),	"CMP_certConf_new"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1),	"CMP_CERTREPMESSAGE_ENCCERT_GET1"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE),	"CMP_CERTREPMESSAGE_get_certificate"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_PKIFAILUREINFOSTRING_GET0),	"CMP_CERTREPMESSAGE_PKIFailureInfoString_get0"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_PKIFAILUREINFO_GET0),	"CMP_CERTREPMESSAGE_PKIFailureInfo_get0"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_PKISTATUSSTRING_GET0),	"CMP_CERTREPMESSAGE_PKIStatusString_get0"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_PKISTATUS_GET),	"CMP_CERTREPMESSAGE_PKIStatus_get"},
+{ERR_FUNC(CMP_F_CMP_CERTSTATUS_SET_CERTHASH),	"CMP_CERTSTATUS_set_certHash"},
+{ERR_FUNC(CMP_F_CMP_CR_NEW),	"CMP_cr_new"},
+{ERR_FUNC(CMP_F_CMP_CTX_CAPUBS_GET1),	"CMP_CTX_caPubs_get1"},
+{ERR_FUNC(CMP_F_CMP_CTX_CAPUBS_NUM),	"CMP_CTX_caPubs_num"},
+{ERR_FUNC(CMP_F_CMP_CTX_CAPUBS_POP),	"CMP_CTX_caPubs_pop"},
+{ERR_FUNC(CMP_F_CMP_CTX_CREATE),	"CMP_CTX_create"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSIN_GET1),	"CMP_CTX_extraCertsIn_get1"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSIN_NUM),	"CMP_CTX_extraCertsIn_num"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSIN_POP),	"CMP_CTX_extraCertsIn_pop"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSOUT_NUM),	"CMP_CTX_extraCertsOut_num"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSOUT_PUSH1),	"CMP_CTX_extraCertsOut_push1"},
+{ERR_FUNC(CMP_F_CMP_CTX_INIT),	"CMP_CTX_init"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET0_NEWPKEY),	"CMP_CTX_set0_newPkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET0_PKEY),	"CMP_CTX_set0_pkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_CAPUBS),	"CMP_CTX_set1_caPubs"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_CLCERT),	"CMP_CTX_set1_clCert"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_EXTRACERTSIN),	"CMP_CTX_set1_extraCertsIn"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_EXTRACERTSOUT),	"CMP_CTX_set1_extraCertsOut"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_NEWCLCERT),	"CMP_CTX_set1_newClCert"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_NEWPKEY),	"CMP_CTX_set1_newPkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_OLDCLCERT),	"CMP_CTX_SET1_OLDCLCERT"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PKEY),	"CMP_CTX_set1_pkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_POPOMETHOD),	"CMP_CTX_set1_popoMethod"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PROXYNAME),	"CMP_CTX_set1_proxyName"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PROXYPORT),	"CMP_CTX_set1_proxyPort"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_RECIPIENT),	"CMP_CTX_set1_recipient"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_RECIPNONCE),	"CMP_CTX_set1_recipNonce"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_REFERENCEVALUE),	"CMP_CTX_set1_referenceValue"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_REGTOKEN),	"CMP_CTX_set1_regToken"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SECRETVALUE),	"CMP_CTX_set1_secretValue"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SERVERNAME),	"CMP_CTX_set1_serverName"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SERVERPATH),	"CMP_CTX_set1_serverPath"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SERVERPORT),	"CMP_CTX_set1_serverPort"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SOURCEADDRESS),	"CMP_CTX_set1_sourceAddress"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SRVCERT),	"CMP_CTX_set1_srvCert"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SUBJECTNAME),	"CMP_CTX_set1_subjectName"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_TRANSACTIONID),	"CMP_CTX_set1_transactionID"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET_HTTPTIMEOUT),	"CMP_CTX_SET_HTTPTIMEOUT"},
+{ERR_FUNC(CMP_F_CMP_CTX_SUBJECTALTNAME_PUSH1),	"CMP_CTX_subjectAltName_push1"},
+{ERR_FUNC(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ),	"CMP_doCertificateRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_DOGENERALMESSAGESEQ),	"CMP_doGeneralMessageSeq"},
+{ERR_FUNC(CMP_F_CMP_DOINITIALREQUESTSEQ),	"CMP_doInitialRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ),	"CMP_doKeyUpdateRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_DOREVOCATIONREQUESTSEQ),	"CMP_doRevocationRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_GENM_NEW),	"CMP_genm_new"},
+{ERR_FUNC(CMP_F_CMP_IR_NEW),	"CMP_ir_new"},
+{ERR_FUNC(CMP_F_CMP_KUR_NEW),	"CMP_kur_new"},
+{ERR_FUNC(CMP_F_CMP_NEW_HTTP_BIO),	"CMP_NEW_HTTP_BIO"},
+{ERR_FUNC(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM),	"CMP_PKIMESSAGE_http_perform"},
+{ERR_FUNC(CMP_F_CMP_PKIMESSAGE_PARSE_ERROR_MSG),	"CMP_PKIMESSAGE_parse_error_msg"},
+{ERR_FUNC(CMP_F_CMP_PKIMESSAGE_PROTECT),	"CMP_PKIMESSAGE_protect"},
+{ERR_FUNC(CMP_F_CMP_PKISTATUSINFO_PKISTATUS_GET_STRING),	"CMP_PKISTATUSINFO_PKISTATUS_GET_STRING"},
+{ERR_FUNC(CMP_F_CMP_POLLREQ_NEW),	"CMP_pollReq_new"},
+{ERR_FUNC(CMP_F_CMP_REVREPCONTENT_PKISTATUS_GET),	"CMP_REVREPCONTENT_PKIStatus_get"},
+{ERR_FUNC(CMP_F_CMP_RR_NEW),	"CMP_rr_new"},
+{ERR_FUNC(CMP_F_CMP_VALIDATE_CERT_PATH),	"CMP_VALIDATE_CERT_PATH"},
+{ERR_FUNC(CMP_F_CMP_VALIDATE_MSG),	"CMP_validate_msg"},
+{ERR_FUNC(CMP_F_CMP_VERIFY_SIGNATURE),	"CMP_VERIFY_SIGNATURE"},
+{ERR_FUNC(CMP_F_PARSE_HTTP_LINE1),	"PARSE_HTTP_LINE1"},
+{ERR_FUNC(CMP_F_PKEY_DUP),	"PKEY_DUP"},
+{ERR_FUNC(CMP_F_POLLFORRESPONSE),	"POLLFORRESPONSE"},
+{ERR_FUNC(CMP_F_SENDCERTCONF),	"SENDCERTCONF"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA CMP_str_reasons[]=
+	{
+{ERR_REASON(CMP_R_ALGORITHM_NOT_SUPPORTED),"algorithm not supported"},
+{ERR_REASON(CMP_R_CERTIFICATE_NOT_FOUND) ,"certificate not found"},
+{ERR_REASON(CMP_R_CP_NOT_RECEIVED)       ,"cp not received"},
+{ERR_REASON(CMP_R_CURL_ERROR)            ,"curl error"},
+{ERR_REASON(CMP_R_ERROR_CALCULATING_PROTECTION),"error calculating protection"},
+{ERR_REASON(CMP_R_ERROR_CREATING_CERTCONF),"error creating certconf"},
+{ERR_REASON(CMP_R_ERROR_CREATING_CR)     ,"error creating cr"},
+{ERR_REASON(CMP_R_ERROR_CREATING_GENM)   ,"error creating genm"},
+{ERR_REASON(CMP_R_ERROR_CREATING_IR)     ,"error creating ir"},
+{ERR_REASON(CMP_R_ERROR_CREATING_KUR)    ,"error creating kur"},
+{ERR_REASON(CMP_R_ERROR_CREATING_POLLREQ),"error creating pollreq"},
+{ERR_REASON(CMP_R_ERROR_CREATING_RR)     ,"error creating rr"},
+{ERR_REASON(CMP_R_ERROR_DECODING_CERTIFICATE),"error decoding certificate"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_CERTIFICATE),"error decrypting certificate"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_ENCCERT),"error decrypting enccert"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_KEY)  ,"error decrypting key"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_SYMMETRIC_KEY),"error decrypting symmetric key"},
+{ERR_REASON(CMP_R_ERROR_NONCES_DO_NOT_MATCH),"error nonces do not match"},
+{ERR_REASON(CMP_R_ERROR_PARSING_ERROR_MESSAGE),"error parsing error message"},
+{ERR_REASON(CMP_R_ERROR_PARSING_PKISTATUS),"error parsing pkistatus"},
+{ERR_REASON(CMP_R_ERROR_PROTECTING_MESSAGE),"error protecting message"},
+{ERR_REASON(CMP_R_ERROR_REQID_NOT_FOUND) ,"error reqid not found"},
+{ERR_REASON(CMP_R_ERROR_SETTING_CERTHASH),"error setting certhash"},
+{ERR_REASON(CMP_R_ERROR_VALIDATING_PROTECTION),"error validating protection"},
+{ERR_REASON(CMP_R_FAILED_TO_DECODE_PKIMESSAGE),"failed to decode pkimessage"},
+{ERR_REASON(CMP_R_GENP_NOT_RECEIVED)     ,"genp not received"},
+{ERR_REASON(CMP_R_INVALID_ARGS)          ,"invalid args"},
+{ERR_REASON(CMP_R_INVALID_CONTENT_TYPE)  ,"invalid content type"},
+{ERR_REASON(CMP_R_INVALID_CONTEXT)       ,"invalid context"},
+{ERR_REASON(CMP_R_INVALID_KEY)           ,"invalid key"},
+{ERR_REASON(CMP_R_INVALID_PARAMETERS)    ,"invalid parameters"},
+{ERR_REASON(CMP_R_IP_NOT_RECEIVED)       ,"ip not received"},
+{ERR_REASON(CMP_R_KUP_NOT_RECEIVED)      ,"kup not received"},
+{ERR_REASON(CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION),"missing key input for creating protection"},
+{ERR_REASON(CMP_R_NO_CERTIFICATE_RECEIVED),"no certificate received"},
+{ERR_REASON(CMP_R_NO_SECRET_VALUE_GIVEN_FOR_PBMAC),"no secret value given for pbmac"},
+{ERR_REASON(CMP_R_NO_TRUSTED_CERTIFICATES_SET),"no trusted certificates set"},
+{ERR_REASON(CMP_R_NO_VALID_SRVCERT_FOUND),"no valid srvcert found"},
+{ERR_REASON(CMP_R_NULL_ARGUMENT)         ,"null argument"},
+{ERR_REASON(CMP_R_PKIBODY_ERROR)         ,"pkibody error"},
+{ERR_REASON(CMP_R_PKICONF_NOT_RECEIVED)  ,"pkiconf not received"},
+{ERR_REASON(CMP_R_POLLREP_NOT_RECEIVED)  ,"pollrep not received"},
+{ERR_REASON(CMP_R_REQUEST_REJECTED_BY_CA),"request rejected by ca"},
+{ERR_REASON(CMP_R_RP_NOT_RECEIVED)       ,"rp not received"},
+{ERR_REASON(CMP_R_SERVER_NOT_REACHABLE)  ,"server not reachable"},
+{ERR_REASON(CMP_R_SERVER_RESPONSE_ERROR) ,"server response error"},
+{ERR_REASON(CMP_R_SERVER_RESPONSE_PARSE_ERROR),"server response parse error"},
+{ERR_REASON(CMP_R_UNABLE_TO_CREATE_CONTEXT),"unable to create context"},
+{ERR_REASON(CMP_R_UNEXPECTED_PKISTATUS)  ,"unexpected pkistatus"},
+{ERR_REASON(CMP_R_UNKNOWN_ALGORITHM_ID)  ,"unknown algorithm id"},
+{ERR_REASON(CMP_R_UNKNOWN_CERTTYPE)      ,"unknown certtype"},
+{ERR_REASON(CMP_R_UNKNOWN_PKISTATUS)     ,"unknown pkistatus"},
+{ERR_REASON(CMP_R_UNSUPPORTED_ALGORITHM) ,"unsupported algorithm"},
+{ERR_REASON(CMP_R_UNSUPPORTED_CIPHER)    ,"unsupported cipher"},
+{ERR_REASON(CMP_R_UNSUPPORTED_KEY_TYPE)  ,"unsupported key type"},
+{ERR_REASON(CMP_R_UNSUPPORTED_PROTECTION_ALG_DHBASEDMAC),"unsupported protection alg dhbasedmac"},
+{ERR_REASON(CMP_R_WRONG_ALGORITHM_OID)   ,"wrong algorithm oid"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_CMP_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(CMP_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,CMP_str_functs);
+		ERR_load_strings(0,CMP_str_reasons);
+		}
+#endif
+	}
diff -Naur crypto/cmp/cmp_http.c crypto-/cmp/cmp_http.c
--- cryptoold/cmp/cmp_http.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_http.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,945 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* crypto/cmp/cmp_http.c
+ * HTTP functions for CMP (RFC 4210) for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2013 Miikka Viljanen <mviljane@users.sourceforge.net>
+ * 
+ * HTTP code taken from crypto/ocsp/ocsp_ht.c, written by 
+ * Dr Stephen N Henson (steve@openssl.org)
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include "e_os.h"
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/cmp.h>
+#include <openssl/err.h>
+#include <openssl/bio.h>
+#include <openssl/buffer.h>
+#include <openssl/ssl.h>
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#ifdef OPENSSL_SYS_SUNOS
+#define strtoul (unsigned long)strtol
+#endif /* OPENSSL_SYS_SUNOS */
+
+
+#ifndef HAVE_CURL /* NO curl support, so we use HTTP code from OCSP */
+
+typedef BIO CMPBIO;
+
+/* This code for HTTP was adapted from crypto/ocsp/ocsp_ht.c, OpenSSL version
+ * 1.0.1e, originally written by Dr Stephen N Henson (steve@openssl.org) for
+ * the OpenSSL project 2006.
+ */
+
+/* Stateful CMP request code, supporting non-blocking I/O */
+
+/* Opaque CMP request status structure */
+
+typedef struct cmp_req_ctx_st CMP_REQ_CTX;
+struct cmp_req_ctx_st {
+	int state;		/* Current I/O state */
+	unsigned char *iobuf;	/* Line buffer */
+	int iobuflen;		/* Line buffer length */
+	BIO *io;		/* BIO to perform I/O with */
+	BIO *mem;		/* Memory BIO response is built into */
+	unsigned long asn1_len;	/* ASN1 length of response */
+	};
+
+#define CMP_MAX_REQUEST_LENGTH	(100 * 1024)
+#define CMP_MAX_LINE_LEN	4096;
+
+/* CMP states */
+
+/* If set no reading should be performed */
+#define OHS_NOREAD		0x1000
+/* Error condition */
+#define OHS_ERROR		(0 | OHS_NOREAD)
+/* First line being read */
+#define OHS_FIRSTLINE		1
+/* MIME headers being read */
+#define OHS_HEADERS		2
+/* CMP initial header (tag + length) being read */
+#define OHS_ASN1_HEADER		3
+/* CMP content octets being read */
+#define OHS_ASN1_CONTENT	4
+/* Request being sent */
+#define OHS_ASN1_WRITE		(6 | OHS_NOREAD)
+/* Request being flushed */
+#define OHS_ASN1_FLUSH		(7 | OHS_NOREAD)
+/* Completed */
+#define OHS_DONE		(8 | OHS_NOREAD)
+
+/* from apps.h */
+#ifndef openssl_fdset
+#ifdef OPENSSL_SYSNAME_WIN32
+#  define openssl_fdset(a,b) FD_SET((unsigned int)a, b)
+#else
+#  define openssl_fdset(a,b) FD_SET(a, b)
+#endif
+#endif
+
+
+static int parse_http_line1(char *line);
+
+void CMP_REQ_CTX_free(CMP_REQ_CTX *rctx)
+	{
+	if (rctx->mem)
+		BIO_free(rctx->mem);
+	if (rctx->iobuf)
+		OPENSSL_free(rctx->iobuf);
+	OPENSSL_free(rctx);
+	}
+
+int CMP_REQ_CTX_set1_req(CMP_REQ_CTX *rctx, CMP_PKIMESSAGE *req)
+	{
+	static const char req_hdr[] =
+	"Content-Type: application/pkixcmp\r\n"
+	"Cache-control: no-cache\r\n"
+	"Content-Length: %d\r\n\r\n";
+        if (BIO_printf(rctx->mem, req_hdr, i2d_CMP_PKIMESSAGE(req, NULL)) <= 0)
+		return 0;
+        if (i2d_CMP_PKIMESSAGE_bio(rctx->mem, req) <= 0)
+		return 0;
+	rctx->state = OHS_ASN1_WRITE;
+	rctx->asn1_len = BIO_get_mem_data(rctx->mem, NULL);
+	return 1;
+	}
+
+int CMP_REQ_CTX_add1_header(CMP_REQ_CTX *rctx,
+		const char *name, const char *value)
+	{
+	if (!name)
+		return 0;
+	if (BIO_puts(rctx->mem, name) <= 0)
+		return 0;
+	if (value)
+		{
+		if (BIO_write(rctx->mem, ": ", 2) != 2)
+			return 0;
+		if (BIO_puts(rctx->mem, value) <= 0)
+			return 0;
+		}
+	if (BIO_write(rctx->mem, "\r\n", 2) != 2)
+		return 0;
+	return 1;
+	}
+
+CMP_REQ_CTX *CMP_sendreq_new(BIO *io, char *path, CMP_PKIMESSAGE *req,
+								int maxline)
+	{
+	static const char post_hdr[] = "POST %s HTTP/1.0\r\n";
+
+	CMP_REQ_CTX *rctx;
+	rctx = OPENSSL_malloc(sizeof(CMP_REQ_CTX));
+	rctx->state = OHS_ERROR;
+	rctx->mem = BIO_new(BIO_s_mem());
+	rctx->io = io;
+	rctx->asn1_len = 0;
+	if (maxline > 0)
+		rctx->iobuflen = maxline;
+	else
+		rctx->iobuflen = CMP_MAX_LINE_LEN;
+	rctx->iobuf = OPENSSL_malloc(rctx->iobuflen);
+	if (!rctx->iobuf)
+		return 0;
+	if (!path)
+		path = "/";
+
+        if (BIO_printf(rctx->mem, post_hdr, path) <= 0)
+		return 0;
+
+	if (req && !CMP_REQ_CTX_set1_req(rctx, req))
+		return 0;
+
+	return rctx;
+	}
+
+/* Parse the HTTP response. This will look like this:
+ * "HTTP/1.0 200 OK". We need to obtain the numeric code and
+ * (optional) informational message.
+ */
+
+static int parse_http_line1(char *line)
+	{
+	int retcode;
+	char *p, *q, *r;
+	/* Skip to first white space (passed protocol info) */
+
+	for(p = line; *p && !isspace((unsigned char)*p); p++)
+		continue;
+	if(!*p)
+		{
+		CMPerr(CMP_F_PARSE_HTTP_LINE1,
+					CMP_R_SERVER_RESPONSE_PARSE_ERROR);
+		return 0;
+		}
+
+	/* Skip past white space to start of response code */
+	while(*p && isspace((unsigned char)*p))
+		p++;
+
+	if(!*p)
+		{
+		CMPerr(CMP_F_PARSE_HTTP_LINE1,
+					CMP_R_SERVER_RESPONSE_PARSE_ERROR);
+		return 0;
+		}
+
+	/* Find end of response code: first whitespace after start of code */
+	for(q = p; *q && !isspace((unsigned char)*q); q++)
+		continue;
+
+	if(!*q)
+		{
+		CMPerr(CMP_F_PARSE_HTTP_LINE1,
+					CMP_R_SERVER_RESPONSE_PARSE_ERROR);
+		return 0;
+		}
+
+	/* Set end of response code and start of message */ 
+	*q++ = 0;
+
+	/* Attempt to parse numeric code */
+	retcode = strtoul(p, &r, 10);
+
+	if(*r)
+		return 0;
+
+	/* Skip over any leading white space in message */
+	while(*q && isspace((unsigned char)*q))
+		q++;
+
+	if(*q)
+		{
+		/* Finally zap any trailing white space in message (include
+		 * CRLF) */
+
+		/* We know q has a non white space character so this is OK */
+		for(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)
+			*r = 0;
+		}
+	if(retcode != 200)
+		{
+		CMPerr(CMP_F_PARSE_HTTP_LINE1, CMP_R_SERVER_RESPONSE_ERROR);
+		if(!*q)
+			ERR_add_error_data(2, "Code=", p);
+		else
+			ERR_add_error_data(4, "Code=", p, ",Reason=", q);
+		return 0;
+		}
+
+
+	return 1;
+
+	}
+
+int CMP_sendreq_nbio(CMP_PKIMESSAGE **presp, CMP_REQ_CTX *rctx)
+	{
+	int i, n;
+	const unsigned char *p;
+	next_io:
+	if (!(rctx->state & OHS_NOREAD))
+		{
+		n = BIO_read(rctx->io, rctx->iobuf, rctx->iobuflen);
+
+		if (n <= 0)
+			{
+			if (BIO_should_retry(rctx->io))
+				return -1;
+			return 0;
+			}
+
+		/* Write data to memory BIO */
+
+		if (BIO_write(rctx->mem, rctx->iobuf, n) != n)
+			return 0;
+		}
+
+	switch(rctx->state)
+		{
+
+		case OHS_ASN1_WRITE:
+		n = BIO_get_mem_data(rctx->mem, &p);
+
+		i = BIO_write(rctx->io,
+			p + (n - rctx->asn1_len), rctx->asn1_len);
+
+		if (i <= 0)
+			{
+			if (BIO_should_retry(rctx->io))
+				return -1;
+			rctx->state = OHS_ERROR;
+			return 0;
+			}
+
+		rctx->asn1_len -= i;
+
+		if (rctx->asn1_len > 0)
+			goto next_io;
+
+		rctx->state = OHS_ASN1_FLUSH;
+
+		(void)BIO_reset(rctx->mem);
+
+		case OHS_ASN1_FLUSH:
+
+		i = BIO_flush(rctx->io);
+
+		if (i > 0)
+			{
+			rctx->state = OHS_FIRSTLINE;
+			goto next_io;
+			}
+
+		if (BIO_should_retry(rctx->io))
+			return -1;
+
+		rctx->state = OHS_ERROR;
+		return 0;
+
+		case OHS_ERROR:
+		return 0;
+
+		case OHS_FIRSTLINE:
+		case OHS_HEADERS:
+
+		/* Attempt to read a line in */
+
+		next_line:
+		/* Due to &%^*$" memory BIO behaviour with BIO_gets we
+		 * have to check there's a complete line in there before
+		 * calling BIO_gets or we'll just get a partial read.
+		 */
+		n = BIO_get_mem_data(rctx->mem, &p);
+		if ((n <= 0) || !memchr(p, '\n', n))
+			{
+			if (n >= rctx->iobuflen)
+				{
+				rctx->state = OHS_ERROR;
+				return 0;
+				}
+			goto next_io;
+			}
+		n = BIO_gets(rctx->mem, (char *)rctx->iobuf, rctx->iobuflen);
+
+		if (n <= 0)
+			{
+			if (BIO_should_retry(rctx->mem))
+				goto next_io;
+			rctx->state = OHS_ERROR;
+			return 0;
+			}
+
+		/* Don't allow excessive lines */
+		if (n == rctx->iobuflen)
+			{
+			rctx->state = OHS_ERROR;
+			return 0;
+			}
+
+		/* First line */
+		if (rctx->state == OHS_FIRSTLINE)
+			{
+			if (parse_http_line1((char *)rctx->iobuf))
+				{
+				rctx->state = OHS_HEADERS;
+				goto next_line;
+				}
+			else
+				{
+				rctx->state = OHS_ERROR;
+				return 0;
+				}
+			}
+		else
+			{
+			/* Look for blank line: end of headers */
+			for (p = rctx->iobuf; *p; p++)
+				{
+				if ((*p != '\r') && (*p != '\n'))
+					break;
+				}
+			if (*p)
+				goto next_line;
+
+			rctx->state = OHS_ASN1_HEADER;
+
+			}
+ 
+		/* Fall thru */
+
+
+		case OHS_ASN1_HEADER:
+		/* Now reading ASN1 header: can read at least 2 bytes which
+		 * is enough for ASN1 SEQUENCE header and either length field
+		 * or at least the length of the length field.
+		 */
+		n = BIO_get_mem_data(rctx->mem, &p);
+		if (n < 2)
+			goto next_io;
+
+		/* Check it is an ASN1 SEQUENCE */
+		if (*p++ != (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED))
+			{
+			rctx->state = OHS_ERROR;
+			return 0;
+			}
+
+		/* Check out length field */
+		if (*p & 0x80)
+			{
+			/* If MSB set on initial length octet we can now
+			 * always read 6 octets: make sure we have them.
+			 */
+			if (n < 6)
+				goto next_io;
+			n = *p & 0x7F;
+			/* Not NDEF or excessive length */
+			if (!n || (n > 4))
+				{
+				rctx->state = OHS_ERROR;
+				return 0;
+				}
+			p++;
+			rctx->asn1_len = 0;
+			for (i = 0; i < n; i++)
+				{
+				rctx->asn1_len <<= 8;
+				rctx->asn1_len |= *p++;
+				}
+
+			if (rctx->asn1_len > CMP_MAX_REQUEST_LENGTH)
+				{
+				rctx->state = OHS_ERROR;
+				return 0;
+				}
+
+			rctx->asn1_len += n + 2;
+			}
+		else
+			rctx->asn1_len = *p + 2;
+
+		rctx->state = OHS_ASN1_CONTENT;
+
+		/* Fall thru */
+		
+		case OHS_ASN1_CONTENT:
+		n = BIO_get_mem_data(rctx->mem, &p);
+		if (n < (int)rctx->asn1_len)
+			goto next_io;
+
+
+		*presp = d2i_CMP_PKIMESSAGE(NULL, &p, rctx->asn1_len);
+		if (*presp)
+			{
+			rctx->state = OHS_DONE;
+			return 1;
+			}
+
+		rctx->state = OHS_ERROR;
+		return 0;
+
+		break;
+
+		case OHS_DONE:
+		return 1;
+
+		}
+
+	return 0;
+	}
+
+/* Blocking CMP request handler: now a special case of non-blocking I/O */
+
+CMP_PKIMESSAGE *CMP_sendreq_bio(BIO *b, char *path, CMP_PKIMESSAGE *req)
+	{
+	CMP_PKIMESSAGE *resp = NULL;
+	CMP_REQ_CTX *ctx;
+	int rv;
+
+	ctx = CMP_sendreq_new(b, path, req, -1);
+	if (!ctx) return NULL;
+
+	do
+		{
+		rv = CMP_sendreq_nbio(&resp, ctx);
+		} while ((rv == -1) && BIO_should_retry(b));
+
+	CMP_REQ_CTX_free(ctx);
+
+	if (rv)
+		return resp;
+
+	return NULL;
+	}
+
+
+#else /* HAVE_CURL */
+
+typedef CURL CMPBIO;
+
+/* If libcurl is available, we use this code. */
+
+typedef struct rdata_s
+	{
+	char *memory;
+	size_t size;
+	} rdata_t;
+
+/* ############################################################################ *
+ * internal function
+ *
+ * realloc which doesn't fail when trying to reallocate NULL pointers
+ *
+ * returns pointer to (re-)allocate space or NULL on error
+ * ############################################################################ */
+static void *myrealloc(void *ptr, size_t size)
+	{
+	if(ptr)
+		return realloc(ptr, size);
+	else
+		return calloc(1,size);
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * used for CURLOPT_WRITEFUNCTION
+ *
+ * returns size of written data in bytes
+ * ############################################################################ */
+static size_t write_data(void *ptr, size_t size, size_t nmemb, void *data)
+	{
+	size_t realsize = size * nmemb;
+	struct rdata_s *mem = (struct rdata_s *) data;
+
+	mem->memory = myrealloc(mem->memory, mem->size + realsize + 1);
+	if (mem->memory)
+		{
+		memcpy(&(mem->memory[mem->size]), ptr, realsize);
+		mem->size += realsize;
+		mem->memory[mem->size] = 0;
+		}
+	return realsize;
+	}
+
+/* ################################################################ *
+ * internal function
+ *
+ * In CMP_CTX we have separate variables for server address and path,
+ * but libcurl doesn't have a separate function for just setting the
+ * path. This function simply checks the end of the effective url to
+ * make sure that the correct path is there, and if it's not set yet
+ * it will be added.
+ *
+ * returns 1 on success, 0 on error
+ * ################################################################ */
+static int set_http_path(CURL *curl, const CMP_CTX *ctx)
+	{
+	char *url = NULL;
+	int bufsize = 0;
+
+	bufsize = strlen(ctx->serverName) + strlen(ctx->serverPath) + 2;
+	url = malloc(bufsize);
+	if (!url) return 0;
+
+	BIO_snprintf(url, bufsize, "%s/%s", ctx->serverName, ctx->serverPath);
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	free(url);
+
+	return 1;
+	}
+
+
+#endif
+
+
+/*
+static uint32_t gethostiplong(const char *host)
+	{
+	unsigned char ip[4];
+
+	BIO_get_host_ip(host, ip);
+
+	return htonl( (unsigned long)
+			((unsigned long)ip[0]<<24L)|
+			((unsigned long)ip[1]<<16L)|
+			((unsigned long)ip[2]<< 8L)|
+			((unsigned long)ip[3]) );
+	}
+*/
+
+/* ########################################################################## *
+ * internal function
+ * Create a new http connection, with a specified source ip/interface
+ * returns 1 on success, 0 on error, returns the created bio inside the *bio
+ * argument
+ * ########################################################################## */
+static int CMP_new_http_bio( CMPBIO **bio, const CMP_CTX *ctx)
+	{
+#ifndef HAVE_CURL
+	BIO *cbio = NULL;
+
+	if (!ctx) goto err;
+	
+	if (!ctx->proxyName || !ctx->proxyPort)
+		{
+		cbio = BIO_new_connect(ctx->serverName);
+		if (!cbio) goto err;
+		BIO_set_conn_int_port(cbio, &ctx->serverPort);
+		}
+	else
+		{
+		cbio = BIO_new_connect(ctx->proxyName);
+		if (!cbio) goto err;
+		BIO_set_conn_int_port(cbio, &ctx->proxyPort);
+		}
+
+	if (ctx->useTLS)
+		{
+		OpenSSL_add_ssl_algorithms();
+		/* TODO support all versions of SSL / TLS properly */
+		SSL_CTX *ctx = SSL_CTX_new(TLSv1_client_method());
+		SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);
+		BIO *sbio = BIO_new_ssl(ctx, 1);
+		cbio = BIO_push(sbio, cbio);
+		}
+
+	*bio = cbio;
+	return 1;
+
+	err:
+	return 0;
+#else
+	struct curl_slist *slist=NULL;
+	CURL *curl;
+	
+	static int curl_initialized = 0;
+
+	if (!ctx) goto err;
+
+	if (curl_initialized == 0)
+		{
+		curl_initialized =	1;
+		curl_global_init(CURL_GLOBAL_ALL);
+		}
+
+	if (!(curl=curl_easy_init())) goto err;
+
+	slist = curl_slist_append(slist, "Content-Type: application/pkixcmp");
+	slist = curl_slist_append(slist, "Cache-control: no-cache");
+	slist = curl_slist_append(slist, "Expect:"); 
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, slist);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
+	if (ctx->sourceAddress != NULL)
+		curl_easy_setopt(curl, CURLOPT_INTERFACE, ctx->sourceAddress);
+
+	curl_easy_setopt(curl, CURLOPT_URL, ctx->serverName);
+	curl_easy_setopt(curl, CURLOPT_PORT, ctx->serverPort);
+
+	curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
+
+	if (ctx->proxyName && ctx->proxyPort)
+		{
+		curl_easy_setopt(curl, CURLOPT_PROXY, ctx->proxyName);
+		curl_easy_setopt(curl, CURLOPT_PROXYPORT, ctx->proxyPort);
+		curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
+		}
+	else
+		{
+		/* curl will automatically try to get proxy from environment if we don't set this.
+		 * if proxy use is enabled, it will be set in CMP_PKIMESSAGE_http_perform. */
+		curl_easy_setopt(curl, CURLOPT_PROXY, ""); /* TODO: that needs to be explicitly documented */
+		}
+
+	*bio = curl;
+	return 1;
+
+	err:
+	CMPerr(CMP_F_CMP_NEW_HTTP_BIO, CMP_R_CURL_ERROR);
+	return 0;
+#endif
+	}
+
+static int CMP_delete_http_bio( CMPBIO *cbio)
+	{
+#ifndef HAVE_CURL
+	if (cbio) BIO_free_all(cbio);
+#else
+	if (cbio) curl_easy_cleanup(cbio);
+#endif
+	return 1;
+	}
+
+/* ################################################################ *
+ * Send the given PKIMessage msg and place the response in *out.
+ * returns 1 on success, 0 on error
+ * on success, returns pointer to received PKIMessage in *out
+ * ################################################################ */
+#ifndef HAVE_CURL
+
+int CMP_PKIMESSAGE_http_perform(const CMP_CTX *ctx, const CMP_PKIMESSAGE *msg, CMP_PKIMESSAGE **out)
+	{
+	int rv, fd;
+	fd_set confds;
+	struct timeval tv;
+	char *path=0;
+	size_t pos=0, pathlen=0;
+	CMPBIO *cbio = 0;
+
+	CMP_new_http_bio(&cbio, ctx);
+
+	if (!cbio || !ctx || !msg || !out)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_NULL_ARGUMENT);
+		goto err;
+		}
+
+	if (!ctx->serverName || !ctx->serverPath || !ctx->serverPort)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_NULL_ARGUMENT);
+		goto err;
+		}
+
+	if (ctx->HttpTimeOut != 0)
+		BIO_set_nbio(cbio, 1);
+	
+	rv = BIO_do_connect(cbio);
+	if (rv <= 0 && (ctx->HttpTimeOut == -1 || !BIO_should_retry(cbio)))
+		{
+		/* Error connecting */
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_SERVER_NOT_REACHABLE);
+		goto err;
+		}
+
+	if (BIO_get_fd(cbio, &fd) <= 0)
+		{
+		/* XXX Can't get fd, is this the right error to return? */
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_SERVER_NOT_REACHABLE);
+		goto err;
+		}
+
+	if (ctx->HttpTimeOut != -1 && rv <= 0)
+		{
+		FD_ZERO(&confds);
+		openssl_fdset(fd, &confds);
+		tv.tv_usec = 0;
+		tv.tv_sec = ctx->HttpTimeOut;
+		rv = select(fd + 1, NULL, (void *)&confds, NULL, &tv);
+		if (rv == 0)
+			{
+			// Timed out
+			CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_SERVER_NOT_REACHABLE);
+			goto err;
+			}
+		}
+
+	pathlen = strlen(ctx->serverName) + strlen(ctx->serverPath) + 32;
+	path = (char*) OPENSSL_malloc(pathlen);
+	if (!path) goto err;
+
+	/* Section 5.1.2 of RFC 1945 states that the absoluteURI form is only allowed when using a proxy */
+	if (ctx->proxyName && ctx->proxyPort)
+		pos = BIO_snprintf(path, pathlen-1, "http://%s:%d", ctx->serverName, ctx->serverPort);
+	
+	/* make sure path includes a forward slash */
+	if (ctx->serverPath[0] != '/') path[pos++] = '/';
+
+	BIO_snprintf(path+pos, pathlen-pos-1, "%s", ctx->serverPath);
+
+	*out = CMP_sendreq_bio(cbio, path, (CMP_PKIMESSAGE*) msg);
+
+	OPENSSL_free(path);
+	// BIO_reset(cbio);
+	CMP_delete_http_bio(cbio);
+	
+	if (!*out) {
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_FAILED_TO_DECODE_PKIMESSAGE);
+		goto err;
+	}
+	
+	return 1;
+
+	err:
+	return 0;
+	}
+
+#else  /* HAVE_CURL */
+
+int CMP_PKIMESSAGE_http_perform(const CMP_CTX *ctx, const CMP_PKIMESSAGE *msg, CMP_PKIMESSAGE **out)
+	{
+	unsigned char *derMsg = NULL, *pder = NULL;
+	char *content_type = NULL;
+	int derLen = 0;
+	CURLcode res;
+	rdata_t rdata = {0,0};
+	CMPBIO *curl = NULL;
+
+	CMP_new_http_bio(&curl, ctx);
+
+	if (!curl || !ctx || !msg || !out)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_NULL_ARGUMENT);
+		goto err;
+		}
+
+	if (!ctx->serverName || !ctx->serverPath || !ctx->serverPort)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_NULL_ARGUMENT);
+		goto err;
+		}
+
+	derLen = i2d_CMP_PKIMESSAGE( (CMP_PKIMESSAGE*) msg, &derMsg);
+
+	set_http_path(curl, ctx);
+
+	/* curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); */
+
+	/* rdata will contain the data received from the server */
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&rdata);
+
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, (void*) derMsg);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, derLen);
+
+	/* set timeout for the entire HTTP operation */
+	if (ctx->HttpTimeOut != 0)
+		curl_easy_setopt(curl, CURLOPT_TIMEOUT, ctx->HttpTimeOut);
+
+	res = curl_easy_perform(curl);
+
+	/* free up sent DER message from memory */
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, (void*) 0);
+	free(derMsg);
+
+	if (res != CURLE_OK)
+		{
+		char num[64];
+
+		if (res == CURLE_COULDNT_CONNECT
+			|| res == CURLE_COULDNT_RESOLVE_PROXY
+			|| res == CURLE_COULDNT_RESOLVE_HOST
+			|| res == CURLE_SEND_ERROR
+			|| res == CURLE_RECV_ERROR
+			|| res == CURLE_OPERATION_TIMEDOUT
+			|| res == CURLE_INTERFACE_FAILED)
+			CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_SERVER_NOT_REACHABLE);
+		else if (res != CURLE_OK)
+			CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_CURL_ERROR);
+
+		BIO_snprintf(num, sizeof(num)-1, "%d:", res);
+		ERR_add_error_data(2, num, curl_easy_strerror(res));
+		goto err;
+		}
+	
+	/* verify that Content-type is application/pkixcmp */
+	curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &content_type);
+	if (content_type == NULL || strcmp(content_type, "application/pkixcmp") != 0)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_INVALID_CONTENT_TYPE);
+		goto err;
+		}
+
+	pder = (unsigned char*) rdata.memory;
+	*out = d2i_CMP_PKIMESSAGE( NULL, (const unsigned char**) &pder, rdata.size);
+	if (*out == 0)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_FAILED_TO_DECODE_PKIMESSAGE);
+		goto err;
+		}
+
+	if (CURLE_OK != curl_easy_getinfo((CMPBIO*)curl, CURLINFO_RESPONSE_CODE, &ctx->lastHTTPCode)) goto err;
+
+	CMP_delete_http_bio(curl);
+
+	free(rdata.memory);
+	return 1;
+
+	err:
+	if (rdata.memory)
+		free(rdata.memory);
+
+	if (curl)
+		CMP_delete_http_bio(curl);
+	return 0;
+	}
+#endif	/* HAVE_CURL */
+
+
+/* ################################################################ *
+ * Returns the HTTP response code of the last response we got from
+ * the server.
+ * returns 0 on error
+ * ################################################################ */
+long CMP_get_http_response_code(const CMP_CTX *ctx)
+	{
+	if (!ctx) return 0;
+	return ctx->lastHTTPCode;
+	}
diff -Naur crypto/cmp/cmp_lib.c crypto-/cmp/cmp_lib.c
--- cryptoold/cmp/cmp_lib.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_lib.c	2017-04-20 21:40:11.071807421 +0700
@@ -0,0 +1,1537 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* crypto/cmp/cmp_lib.c
+ * CMP (RFC 4210) library functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+ /* NAMING
+  * The 0 version uses the supplied structure pointer directly in the parent and
+  * it will be freed up when the parent is freed. In the above example crl would
+  * be freed but rev would not.
+  *
+  * The 1 function uses a copy of the supplied structure pointer (or in some
+  * cases increases its link count) in the parent and so both (x and obj above)
+  * should be freed up.
+ */
+
+/* ############################################################################ *
+ * In this file are the functions which set the individual items inside			*
+ * the CMP structures															*
+ * ############################################################################ */
+
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/rand.h>
+#include <openssl/safestack.h>
+#include <openssl/crypto.h>
+#include <openssl/engine.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+/* for bio_err */
+#include <openssl/err.h>
+
+#include <time.h>
+#include <string.h>
+
+/* ############################################################################ *
+ * Sets the protocol version number in PKIHeader.
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set_version(CMP_PKIHEADER *hdr, int version)
+	{
+	if( !hdr) goto err;
+
+	if(! ASN1_INTEGER_set(hdr->pvno, version)) goto err;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * Set the recipient name of PKIHeader.
+ * when nm is NULL, recipient is set to an empty string
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm)
+	{
+	GENERAL_NAME *gen=NULL;
+	if( !hdr) goto err;
+
+	gen = GENERAL_NAME_new();
+	if( !gen) goto err;
+
+	gen->type = GEN_DIRNAME;
+
+	/* if nm is not set an empty dirname will be set */
+	if (nm == NULL)
+		{
+		gen->d.directoryName = X509_NAME_new();
+		}
+	else
+		{
+		if (!X509_NAME_set(&gen->d.directoryName, (X509_NAME*) nm))
+			{
+			GENERAL_NAME_free(gen);
+			goto err;
+			}
+		}
+
+	if (hdr->recipient)
+		GENERAL_NAME_free(hdr->recipient);
+	hdr->recipient = gen;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * Set the sender name in PKIHeader.
+ * when nm is NULL, sender is set to an empty string
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm)
+	{
+	GENERAL_NAME *gen=NULL;
+	if( !hdr) goto err;
+
+	gen = GENERAL_NAME_new();
+	if( !gen) goto err;
+
+	gen->type = GEN_DIRNAME;
+
+	/* if nm is not set an empty dirname will be set */
+	if (nm == NULL)
+		{
+		gen->d.directoryName = X509_NAME_new();
+		}
+	else {
+		if (!X509_NAME_set(&gen->d.directoryName, (X509_NAME*) nm))
+			{
+			GENERAL_NAME_free(gen);
+			goto err;
+			}
+		}
+	if (hdr->sender)
+		GENERAL_NAME_free(hdr->sender);
+	hdr->sender = gen;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * (re-)set given transaction ID in CMP header
+ * if given *transactionID is NULL, a random one is created with 128 bit
+ * according to section 5.1.1:
+ *
+ * It is RECOMMENDED that the clients fill the transactionID field with
+ * 128 bits of (pseudo-) random data for the start of a transaction to
+ * reduce the probability of having the transactionID in use at the
+ * server.
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_transactionID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *transactionID)
+	{
+#define TRANSACTIONID_LENGTH 16
+	unsigned char *transactionIDuchar=NULL;
+
+	if(!hdr) goto err;
+
+	if(transactionID)
+		{
+		if (!(hdr->transactionID = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)transactionID))) goto err;
+		}
+	else {
+		/* generate a random value if none was given */
+		if(!(transactionIDuchar = (unsigned char*)OPENSSL_malloc(TRANSACTIONID_LENGTH))) goto err;
+		RAND_pseudo_bytes(transactionIDuchar, TRANSACTIONID_LENGTH);
+
+		if(hdr->transactionID == NULL)
+			{
+			hdr->transactionID = ASN1_OCTET_STRING_new();
+			}
+		if(!(ASN1_OCTET_STRING_set(hdr->transactionID, transactionIDuchar, TRANSACTIONID_LENGTH))) goto err;
+
+		OPENSSL_free(transactionIDuchar);
+		}
+
+	return 1;
+err:
+	if(transactionIDuchar)
+		OPENSSL_free(transactionIDuchar);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * (re-)set random senderNonce to given header
+ * as in 5.1.1:
+ *
+ * senderNonce			present
+ *	   -- 128 (pseudo-)random bits
+ * The senderNonce and recipNonce fields protect the PKIMessage against
+ * replay attacks.	The senderNonce will typically be 128 bits of
+ * (pseudo-) random data generated by the sender, whereas the recipNonce
+ * is copied from the senderNonce of the previous message in the
+ * transaction.
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_new_senderNonce(CMP_PKIHEADER *hdr)
+	{
+#define SENDERNONCE_LENGTH 16
+	unsigned char senderNonce[SENDERNONCE_LENGTH];
+
+	if( !hdr) goto err;
+
+	RAND_pseudo_bytes(senderNonce, SENDERNONCE_LENGTH);
+
+	if (hdr->senderNonce == NULL)
+		{
+		hdr->senderNonce = ASN1_OCTET_STRING_new();
+		}
+
+	if (!(ASN1_OCTET_STRING_set(hdr->senderNonce, senderNonce, SENDERNONCE_LENGTH))) goto err;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * (re-)sets given recipient nonce to given header
+ * as per 5.1.1 used to mirror the nonce back to the other side
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_recipNonce(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *recipNonce)
+	{
+	if (!hdr) goto err;
+	if (!recipNonce) goto err;
+
+	if (hdr->recipNonce)
+		ASN1_OCTET_STRING_free(hdr->recipNonce);
+
+	if (!(hdr->recipNonce = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)recipNonce))) goto err;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * (re-)set given senderKID to given header
+ *
+ * senderKID			referenceNum
+ *	 -- the reference number which the CA has previously issued
+ *	 -- to the end entity (together with the MACing key)
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_senderKID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *senderKID)
+	{
+	if (!hdr) goto err;
+	if (!senderKID) goto err;
+
+	if (hdr->senderKID)
+		 ASN1_OCTET_STRING_free(hdr->senderKID);
+
+	if (!(hdr->senderKID = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)senderKID))) goto err;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################
+ * (re-)set the messageTime to the current system time
+ *
+ * as in 5.1.1:
+ *
+ * The messageTime field contains the time at which the sender created
+ * the message.  This may be useful to allow end entities to
+ * correct/check their local time for consistency with the time on a
+ * central system.
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_set_messageTime(CMP_PKIHEADER *hdr)
+	{
+	if (!hdr) goto err;
+
+	if (!hdr->messageTime)
+		 hdr->messageTime = ASN1_GENERALIZEDTIME_new();
+
+	if (! ASN1_GENERALIZEDTIME_set( hdr->messageTime, time(NULL))) goto err;
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * push given ASN1_UTF8STRING to hdr->freeText and consume the given pointer
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_push0_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text)
+	{
+	if (!hdr) goto err;
+	if (!text) goto err;
+
+	if (!hdr->freeText)
+		if (!(hdr->freeText = sk_ASN1_UTF8STRING_new_null())) goto err;
+
+	if (!(sk_ASN1_UTF8STRING_push(hdr->freeText, text))) goto err;
+
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * push an ASN1_UTF8STRING to hdr->freeText and don't consume the given pointer
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_push1_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text)
+	{
+	ASN1_UTF8STRING *textDup=NULL;
+
+	if (!hdr) goto err;
+	if (!text) goto err;
+
+	if( !(textDup = ASN1_UTF8STRING_new())) goto err;
+	if( !ASN1_STRING_set( textDup, text->data, text->length)) goto err;
+
+	return CMP_PKIHEADER_push0_freeText( hdr, textDup);
+err:
+	if (textDup) ASN1_UTF8STRING_free(textDup);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * Initialize the given PkiHeader structure with values set in the CMP_CTX structure.
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_init(CMP_CTX *ctx, CMP_PKIHEADER *hdr)
+	{
+	if( !hdr) goto err;
+	if( !ctx) goto err;
+
+	/* set the CMP version */
+	CMP_PKIHEADER_set_version( hdr, CMP_VERSION);
+
+	/* in case there is no OLD client cert the sender name is not set (e.g. for IR) */
+	if( ctx->clCert)
+		{
+		if( !CMP_PKIHEADER_set1_sender( hdr, X509_get_subject_name( (X509*) ctx->clCert))) goto err;
+		}
+	else {
+		if( !CMP_PKIHEADER_set1_sender( hdr, NULL)) goto err;
+		}
+
+	/* set recipient name either from known server certificate or recipient name in ctx, leave empty if not set in ctx */
+	if( ctx->srvCert)
+		{
+		if( !CMP_PKIHEADER_set1_recipient( hdr, X509_get_subject_name( (X509*) ctx->srvCert))) goto err;
+		}
+	else if( ctx->recipient)
+		{
+		if( !CMP_PKIHEADER_set1_recipient( hdr, ctx->recipient)) goto err;
+		}
+	else
+		{
+		if( !CMP_PKIHEADER_set1_recipient( hdr, NULL)) goto err;
+		}
+
+	/* set current time as message time */
+	if( !CMP_PKIHEADER_set_messageTime(hdr)) goto err;
+
+	if (ctx->recipNonce)
+		if( !CMP_PKIHEADER_set1_recipNonce(hdr, ctx->recipNonce)) goto err;
+
+	if (ctx->transactionID)
+		{
+		if (!CMP_PKIHEADER_set1_transactionID(hdr, ctx->transactionID)) goto err;
+		}
+	else {
+		/* create new transaction ID */
+		if (!CMP_PKIHEADER_set1_transactionID(hdr, NULL)) goto err;
+		CMP_CTX_set1_transactionID(ctx, hdr->transactionID);
+		}
+
+	if (!CMP_PKIHEADER_new_senderNonce(hdr)) goto err;
+
+#if 0
+	/*
+		 freeText		 [7] PKIFreeText			 OPTIONAL,
+		 -- this may be used to indicate context-specific instructions
+		 -- (this field is intended for human consumption)
+	 */
+	if( ctx->freeText)
+		if( !CMP_PKIHEADER_push1_freeText(hdr, ctx->freeText)) goto err;
+#endif
+
+	return 1;
+err:
+	return 0;
+}
+
+
+/* ############################################################################ *
+ * also used for verification from cmp_vfy
+ *
+ * calculate PBM protection for given PKImessage utilizing the given secret and the
+ * pbm-parameters set inside the message header's protectionAlg
+ *
+ * returns pointer to ASN1_BIT_STRING containing protection on success, NULL on
+ * error
+ * ############################################################################ */
+ASN1_BIT_STRING *CMP_calc_protection_pbmac(CMP_PKIMESSAGE *pkimessage, const ASN1_OCTET_STRING *secret)
+	{
+	ASN1_BIT_STRING *prot=NULL;
+	CMP_PROTECTEDPART protPart;
+	ASN1_STRING *pbmStr=NULL;
+	ASN1_OBJECT *algorOID=NULL;
+
+	CRMF_PBMPARAMETER *pbm=NULL;
+
+	size_t protPartDerLen;
+	unsigned int macLen;
+	unsigned char *protPartDer=NULL;
+	unsigned char *mac=NULL;
+	const unsigned char *pbmStrUchar=NULL;
+
+	void *ppval=NULL;
+	int pptype=0;
+
+	if (!secret)
+		{
+		CMPerr(CMP_F_CMP_CALC_PROTECTION_PBMAC, CMP_R_NO_SECRET_VALUE_GIVEN_FOR_PBMAC);
+		goto err;
+		}
+
+	protPart.header = pkimessage->header;
+	protPart.body	= pkimessage->body;
+	protPartDerLen	= i2d_CMP_PROTECTEDPART(&protPart, &protPartDer);
+
+	X509_ALGOR_get0( &algorOID, &pptype, &ppval, pkimessage->header->protectionAlg);
+
+	if (NID_id_PasswordBasedMAC == OBJ_obj2nid(algorOID))
+		{
+		/* there is no pmb set in this message */
+		if (!ppval) goto err;
+
+		pbmStr = (ASN1_STRING *)ppval;
+		pbmStrUchar = (unsigned char *)pbmStr->data;
+		pbm = d2i_CRMF_PBMPARAMETER( NULL, &pbmStrUchar, pbmStr->length);
+
+		if(!(CRMF_passwordBasedMac_new(pbm, protPartDer, protPartDerLen, secret->data, secret->length, &mac, &macLen))) goto err;
+		}
+	else {
+		CMPerr(CMP_F_CMP_CALC_PROTECTION_PBMAC, CMP_R_WRONG_ALGORITHM_OID);
+		goto err;
+		}
+	OPENSSL_free(protPartDer);
+
+	if(!(prot = ASN1_BIT_STRING_new())) goto err;
+	ASN1_BIT_STRING_set(prot, mac, macLen);
+
+	/* Actually this should not be needed but OpenSSL defaults all bitstrings to be a NamedBitList */
+	prot->flags &= ~0x07;
+	prot->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+	/* cleanup */
+	if (mac) OPENSSL_free(mac);
+	return prot;
+
+err:
+	if (mac) OPENSSL_free(mac);
+
+	CMPerr(CMP_F_CMP_CALC_PROTECTION_PBMAC, CMP_R_ERROR_CALCULATING_PROTECTION);
+	if(prot) ASN1_BIT_STRING_free(prot);
+	if(protPartDer) OPENSSL_free(protPartDer);
+	return NULL;
+}
+
+/* ############################################################################ *
+ * only used internally
+ *
+ * calculate signature protection for given PKImessage utilizing the given secret key
+ * and the algorithm parameters set inside the message header's protectionAlg
+ *
+ * returns pointer to ASN1_BIT_STRING containing protection on success, NULL on
+ * error
+ * ############################################################################ */
+ASN1_BIT_STRING *CMP_calc_protection_sig(CMP_PKIMESSAGE *pkimessage, EVP_PKEY *pkey)
+	{
+	ASN1_BIT_STRING *prot=NULL;
+	CMP_PROTECTEDPART protPart;
+	ASN1_OBJECT *algorOID=NULL;
+
+	size_t protPartDerLen;
+	unsigned int macLen;
+	size_t maxMacLen;
+	unsigned char *protPartDer=NULL;
+	unsigned char *mac=NULL;
+
+	void *ppval=NULL;
+	int pptype=0;
+
+	EVP_MD_CTX	 *evp_ctx=NULL;
+	const EVP_MD *md=NULL;
+
+	if (!pkey)
+		{ /* EVP_SignFinal() will check that pkey type is correct for the algorithm */
+		CMPerr(CMP_F_CMP_CALC_PROTECTION_SIG, CMP_R_INVALID_KEY);
+		ERR_add_error_data(1, "pkey was NULL although it is supposed to be used for generating protection");
+		goto err;
+		}
+
+	/* construct data to be signed */
+	protPart.header = pkimessage->header;
+	protPart.body	= pkimessage->body;
+	protPartDerLen	= i2d_CMP_PROTECTEDPART(&protPart, &protPartDer);
+
+	X509_ALGOR_get0( &algorOID, &pptype, &ppval, pkimessage->header->protectionAlg);
+
+	if ((md = EVP_get_digestbynid(OBJ_obj2nid(algorOID))))
+		{
+		maxMacLen = EVP_PKEY_size(pkey);
+		mac = OPENSSL_malloc(maxMacLen);
+
+		/* calculate signature */
+		evp_ctx = EVP_MD_CTX_create();
+		if (!evp_ctx) goto err;
+		if (!(EVP_SignInit_ex(evp_ctx, md, NULL))) goto err;
+		if (!(EVP_SignUpdate(evp_ctx, protPartDer, protPartDerLen))) goto err;
+		if (!(EVP_SignFinal(evp_ctx, mac, &macLen, pkey))) goto err;
+		}
+	else {
+		CMPerr(CMP_F_CMP_CALC_PROTECTION_SIG, CMP_R_UNKNOWN_ALGORITHM_ID);
+		goto err;
+		}
+
+	if(!(prot = ASN1_BIT_STRING_new())) goto err;
+	ASN1_BIT_STRING_set(prot, mac, macLen);
+
+	/* Actually this should not be needed but OpenSSL defaults all bitstrings to be a NamedBitList */
+	prot->flags &= ~0x07;
+	prot->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+	/* cleanup */
+	if (evp_ctx) EVP_MD_CTX_destroy(evp_ctx);
+	if (mac) OPENSSL_free(mac);
+	if (protPartDer) OPENSSL_free(protPartDer);
+	return prot;
+
+err:
+	if (evp_ctx) EVP_MD_CTX_destroy(evp_ctx);
+	if (mac) OPENSSL_free(mac);
+	if (protPartDer) OPENSSL_free(protPartDer);
+
+	CMPerr(CMP_F_CMP_CALC_PROTECTION_SIG, CMP_R_ERROR_CALCULATING_PROTECTION);
+	if(prot) ASN1_BIT_STRING_free(prot);
+	return NULL;
+}
+
+/* ############################################################################ *
+ * internal function
+ * Create an X509_ALGOR structure for PasswordBasedMAC protection
+ * returns pointer to X509_ALGOR on success, NULL on error
+ * TODO: this could take options to configure the pbmac
+ * ############################################################################ */
+X509_ALGOR *CMP_create_pbmac_algor(void)
+	{
+	X509_ALGOR *alg=NULL;
+	CRMF_PBMPARAMETER *pbm=NULL;
+	unsigned char *pbmDer=NULL;
+	int pbmDerLen;
+	ASN1_STRING *pbmStr=NULL;
+
+	if (!(alg = X509_ALGOR_new())) goto err;
+	if (!(pbm = CRMF_pbm_new())) goto err;
+	if (!(pbmStr = ASN1_STRING_new())) goto err;
+
+	pbmDerLen = i2d_CRMF_PBMPARAMETER( pbm, &pbmDer);
+
+	ASN1_STRING_set( pbmStr, pbmDer, pbmDerLen);
+	OPENSSL_free( pbmDer);
+	pbmDer = NULL; /* to avoid double free in case there would be a "goto err" inserted behind this point later in development */
+
+	X509_ALGOR_set0( alg, OBJ_nid2obj(NID_id_PasswordBasedMAC), V_ASN1_SEQUENCE, pbmStr);
+	pbmStr = NULL; /* pbmStr is not freed explicityly because the pointer was consumed by X509_ALGOR_set0() */
+
+	CRMF_PBMPARAMETER_free( pbm);
+	return alg;
+err:
+	if (alg) X509_ALGOR_free(alg);
+	if (pbm) CRMF_PBMPARAMETER_free( pbm);
+	if (pbmDer) OPENSSL_free( pbmDer);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * determines which kind of protection should be created based on the ctx
+ * sets this into the protectionAlg field in the message header
+ * calculates the protection and sets it in the protections filed
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIMESSAGE_protect(CMP_CTX *ctx, CMP_PKIMESSAGE *msg)
+	{
+	if(!ctx) goto err;
+	if(!msg) goto err;
+
+	/* use PasswordBasedMac according to 5.1.3.1 if secretValue is given */
+	if (ctx->secretValue)
+		{
+		if(!(msg->header->protectionAlg = CMP_create_pbmac_algor())) goto err;
+		CMP_PKIHEADER_set1_senderKID(msg->header, ctx->referenceValue);
+		if(!(msg->protection = CMP_calc_protection_pbmac( msg, ctx->secretValue)))
+			goto err;
+		}
+	else {
+		/* use MSG_SIG_ALG according to 5.1.3.3 if client Certificate and private key is given */
+		if (ctx->clCert && ctx->pkey)
+			{
+			ASN1_OCTET_STRING *subjKeyIDStr = NULL;
+			int algNID = 0;
+
+			if (!msg->header->protectionAlg)
+				msg->header->protectionAlg = X509_ALGOR_new();
+
+			/* DSA/SHA1 is mandatory for MSG_SIG_ALG (appendix D.2) so SHA-1 is hardcoded here for now */
+			/* This could be made configurable via ctx to include SHA-256 etc */
+			switch (EVP_PKEY_type(ctx->pkey->type))
+				{
+				case EVP_PKEY_DSA:
+					algNID = NID_dsaWithSHA1;
+					break;
+				case EVP_PKEY_RSA:
+					algNID = NID_sha1WithRSAEncryption;
+					break;
+				default:
+					CMPerr(CMP_F_CMP_PKIMESSAGE_PROTECT, CMP_R_UNSUPPORTED_KEY_TYPE);
+					goto err;
+				}
+			X509_ALGOR_set0(msg->header->protectionAlg, OBJ_nid2obj(algNID), V_ASN1_NULL, NULL);
+
+			/* set senderKID to  keyIdentifier of the used certificate according
+			 * to section 5.1.1 */
+			subjKeyIDStr = CMP_get_cert_subject_key_id(ctx->clCert);
+			if (subjKeyIDStr)
+				{
+				CMP_PKIHEADER_set1_senderKID(msg->header, subjKeyIDStr);
+				ASN1_OCTET_STRING_free(subjKeyIDStr);
+				}
+
+			if (!(msg->protection = CMP_calc_protection_sig( msg, ctx->pkey)))
+				goto err;
+			}
+		else
+			{
+			CMPerr(CMP_F_CMP_PKIMESSAGE_PROTECT, CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
+			goto err;
+			}
+		}
+
+	return 1;
+	err:
+	CMPerr(CMP_F_CMP_PKIMESSAGE_PROTECT, CMP_R_ERROR_PROTECTING_MESSAGE);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * set certificate Hash in certStatus of certConf messages according to 5.3.18.
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_CERTSTATUS_set_certHash( CMP_CERTSTATUS *certStatus, const X509 *cert)
+	{
+	unsigned int hashLen;
+	unsigned char hash[EVP_MAX_MD_SIZE];
+	int sigAlgID;
+	const EVP_MD *md = NULL;
+
+	if (!certStatus) goto err;
+	if (!cert) goto err;
+
+	/*  select hash algorithm, as stated in Appendix F.  Compilable ASN.1 Definitions:
+	 *  -- the hash of the certificate, using the same hash algorithm
+	 *  -- as is used to create and verify the certificate signature */
+	sigAlgID = OBJ_obj2nid(cert->sig_alg->algorithm);
+	if ((md = EVP_get_digestbynid(sigAlgID)))
+		{
+		if (!X509_digest(cert, md, hash, &hashLen)) goto err;
+		if (!certStatus->certHash)
+			if (!(certStatus->certHash = ASN1_OCTET_STRING_new())) goto err;
+		if (!ASN1_OCTET_STRING_set(certStatus->certHash, hash, hashLen)) goto err;
+		}
+	else
+		{
+		CMPerr(CMP_F_CMP_CERTSTATUS_SET_CERTHASH, CMP_R_UNSUPPORTED_ALGORITHM);
+		goto err;
+		}
+
+	return 1;
+	err:
+	CMPerr(CMP_F_CMP_CERTSTATUS_SET_CERTHASH, CMP_R_ERROR_SETTING_CERTHASH);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets implicitConfirm in the generalInfo field of the PKIMessage header
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIMESSAGE_set_implicitConfirm(CMP_PKIMESSAGE *msg)
+	{
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+
+	if (!msg) goto err;
+
+	if (!(itav = CMP_INFOTYPEANDVALUE_new())) goto err;
+	itav->infoType = OBJ_nid2obj(NID_id_it_implicitConfirm);
+	itav->infoValue.implicitConfirm = ASN1_NULL_new();
+	if (!CMP_PKIHEADER_generalInfo_item_push0( msg->header, itav)) goto err;
+	return 1;
+err:
+	if (itav) CMP_INFOTYPEANDVALUE_free(itav);
+	return 0;
+	}
+
+/* ############################################################################
+ * checks if implicitConfirm in the generalInfo field of the header is set
+ *
+ * returns 1 if it is set, 0 if not
+ * ############################################################################ */
+int CMP_PKIMESSAGE_check_implicitConfirm(CMP_PKIMESSAGE *msg)
+	{
+	int itavCount;
+	int i;
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+
+	if (!msg) return 0;
+
+	itavCount = sk_CMP_INFOTYPEANDVALUE_num(msg->header->generalInfo);
+
+	for( i=0; i < itavCount; i++)
+		{
+		itav = sk_CMP_INFOTYPEANDVALUE_value(msg->header->generalInfo,i);
+		if (OBJ_obj2nid(itav->infoType) == NID_id_it_implicitConfirm)
+			return 1;
+		}
+
+	return 0;
+	}
+
+/* ############################################################################ *
+ * push given itav to message header
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIHEADER_generalInfo_item_push0(CMP_PKIHEADER *hdr, const CMP_INFOTYPEANDVALUE *itav)
+	{
+	if( !hdr) goto err;
+
+	if( !CMP_ITAV_stack_item_push0(&hdr->generalInfo, itav))
+		goto err;
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * push itav to general message
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIMESSAGE_genm_item_push0(CMP_PKIMESSAGE *msg, const CMP_INFOTYPEANDVALUE *itav)
+	{
+	if (!msg) goto err;
+
+	if (CMP_PKIMESSAGE_get_bodytype(msg) != V_CMP_PKIBODY_GENM) goto err;
+
+	if (!CMP_ITAV_stack_item_push0( &msg->body->value.genm, itav))
+		goto err;
+	return 1;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * push given itav to given stack
+ *
+ * @itav: a pointer to the infoTypeAndValue item to push on the stack.
+ *		  If NULL it will only made sure the stack exists, that might be
+ *		  needed for creating an empty general message
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_ITAV_stack_item_push0(STACK_OF(CMP_INFOTYPEANDVALUE) **itav_sk_p, const CMP_INFOTYPEANDVALUE *itav)
+	{
+	int created = 0;
+
+	if (!itav_sk_p) goto err;
+
+	if (!*itav_sk_p)
+		{
+		/* not yet created */
+		if (!(*itav_sk_p = sk_CMP_INFOTYPEANDVALUE_new_null()))
+			goto err;
+		created = 1;
+		}
+	if (itav)
+		{
+		if (!sk_CMP_INFOTYPEANDVALUE_push(*itav_sk_p, itav)) goto err;
+		}
+	return 1;
+err:
+	if (created)
+		{
+		sk_CMP_INFOTYPEANDVALUE_pop_free(*itav_sk_p, CMP_INFOTYPEANDVALUE_free);
+		*itav_sk_p = NULL;
+		}
+	return 0;
+}
+
+/* ############################################################################ *
+ * returns the PKIStatus of the given PKIStatusInfo
+ * returns -1 on error
+ * ############################################################################ */
+long CMP_PKISTATUSINFO_PKIstatus_get( CMP_PKISTATUSINFO *statusInfo)
+	{
+	if (!statusInfo) return -1;
+	if (!statusInfo->status) return -1;
+	return ASN1_INTEGER_get(statusInfo->status);
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * convert PKIstatus to human readable string
+ *
+ * returns pointer to character array containing a sting representing the
+ * PKIStatus of the given PKIStatusInfo
+ * returns NULL on error
+ * ############################################################################ */
+static char *CMP_PKISTATUSINFO_PKIstatus_get_string( CMP_PKISTATUSINFO *statusInfo)
+	{
+	long PKIstatus;
+
+	if (!statusInfo) return 0;
+
+	PKIstatus = CMP_PKISTATUSINFO_PKIstatus_get(statusInfo);
+	switch (PKIstatus)
+		{
+		case CMP_PKISTATUS_accepted:
+			return "PKIStatus: accepted";
+		case CMP_PKISTATUS_grantedWithMods:
+			return "PKIStatus: granded with mods";
+		case CMP_PKISTATUS_rejection:
+			return "PKIStatus: rejection";
+		case CMP_PKISTATUS_waiting:
+			return "PKIStatus: waiting";
+		case CMP_PKISTATUS_revocationWarning:
+			return "PKIStatus: revocation warning";
+		case CMP_PKISTATUS_revocationNotification:
+			return "PKIStatus: revocation notification";
+		case CMP_PKISTATUS_keyUpdateWarning:
+			return "PKIStatus: key update warning";
+		case -1:
+		default:
+			CMPerr(CMP_F_CMP_PKISTATUSINFO_PKISTATUS_GET_STRING, CMP_R_ERROR_PARSING_PKISTATUS);
+			return 0;
+		}
+	return 0;
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * convert PKIstatus to human readable string
+ *
+ * returns pointer to string containing the the PKIFailureInfo
+ * returns NULL on error
+ * ############################################################################ */
+static char *CMP_PKISTATUSINFO_PKIFailureInfo_get_string( CMP_PKISTATUSINFO *statusInfo)
+	{
+	int i;
+
+	if (!statusInfo) return 0;
+	for (i=0; i <= CMP_PKIFAILUREINFO_MAX; i++)
+		{
+		if (ASN1_BIT_STRING_get_bit(statusInfo->failInfo, i))
+			{
+			switch (i)
+				{
+				case CMP_PKIFAILUREINFO_badAlg:
+					return "PKIFailureInfo: badAlg";
+				case CMP_PKIFAILUREINFO_badMessageCheck:
+					return "PKIFailureInfo: badMessageCheck";
+				case CMP_PKIFAILUREINFO_badRequest:
+					return "PKIFailureInfo: badRequest";
+				case CMP_PKIFAILUREINFO_badTime:
+					return "PKIFailureInfo: badTime";
+				case CMP_PKIFAILUREINFO_badCertId:
+					return "PKIFailureInfo: badCertId";
+				case CMP_PKIFAILUREINFO_badDataFormat:
+					return "PKIFailureInfo: badDataFormat";
+				case CMP_PKIFAILUREINFO_wrongAuthority:
+					return "PKIFailureInfo: wrongAuthority";
+				case CMP_PKIFAILUREINFO_incorrectData:
+					return "PKIFailureInfo: incorrectData";
+				case CMP_PKIFAILUREINFO_missingTimeStamp:
+					return "PKIFailureInfo: missingTimeStamp";
+				case CMP_PKIFAILUREINFO_badPOP:
+					return "PKIFailureInfo: badPOP";
+				case CMP_PKIFAILUREINFO_certRevoked:
+					return "PKIFailureInfo: certRevoked";
+				case CMP_PKIFAILUREINFO_certConfirmed:
+					return "PKIFailureInfo: certConfirmed";
+				case CMP_PKIFAILUREINFO_wrongIntegrity:
+					return "PKIFailureInfo: wrongIntegrity";
+				case CMP_PKIFAILUREINFO_badRecipientNonce:
+					return "PKIFailureInfo: badRecipientNonce";
+				case CMP_PKIFAILUREINFO_timeNotAvailable:
+					return "PKIFailureInfo: timeNotAvailable";
+				case CMP_PKIFAILUREINFO_unacceptedPolicy:
+					return "PKIFailureInfo: unacceptedPolicy";
+				case CMP_PKIFAILUREINFO_unacceptedExtension:
+					return "PKIFailureInfo: unacceptedExtension";
+				case CMP_PKIFAILUREINFO_addInfoNotAvailable:
+					return "PKIFailureInfo: addInfoNotAvailable";
+				case CMP_PKIFAILUREINFO_badSenderNonce:
+					return "PKIFailureInfo: badSenderNonce";
+				case CMP_PKIFAILUREINFO_badCertTemplate:
+					return "PKIFailureInfo: badCertTemplate";
+				case CMP_PKIFAILUREINFO_signerNotTrusted:
+					return "PKIFailureInfo: signerNotTrusted";
+				case CMP_PKIFAILUREINFO_transactionIdInUse:
+					return "PKIFailureInfo: transactionIdInUse";
+				case CMP_PKIFAILUREINFO_unsupportedVersion:
+					return "PKIFailureInfo: unsupportedVersion";
+				case CMP_PKIFAILUREINFO_notAuthorized:
+					return "PKIFailureInfo: notAuthorized";
+				case CMP_PKIFAILUREINFO_systemUnavail:
+					return "PKIFailureInfo: systemUnavail";
+				case CMP_PKIFAILUREINFO_systemFailure:
+					return "PKIFailureInfo: systemFailure";
+				case CMP_PKIFAILUREINFO_duplicateCertReq:
+					return "PKIFailureInfo: duplicateCertReq";
+				}
+			}
+		}
+	return 0;
+	}
+
+/* ############################################################################ *
+ * returns the PKIStatus of the given certReqId inside a Rev
+ * returns -1 on error
+ * ############################################################################ */
+long CMP_REVREPCONTENT_PKIStatus_get( CMP_REVREPCONTENT *revRep, long reqId)
+	{
+	CMP_PKISTATUSINFO *status=NULL;
+	if (!revRep) return -1;
+
+	if ( (status = sk_CMP_PKISTATUSINFO_value( revRep->status, reqId)) )
+		{
+		return CMP_PKISTATUSINFO_PKIstatus_get(status);
+		}
+
+	CMPerr(CMP_F_CMP_REVREPCONTENT_PKISTATUS_GET, CMP_R_ERROR_REQID_NOT_FOUND);
+	return -1;
+	}
+
+/* ############################################################################ *
+ * returns the PKIStatus of the given certReqId inside a CertRepMessage
+ * returns -1 on error
+ * ############################################################################ */
+long CMP_CERTREPMESSAGE_PKIStatus_get( CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return -1;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		{
+		return CMP_PKISTATUSINFO_PKIstatus_get(certResponse->status);
+		}
+
+	CMPerr(CMP_F_CMP_CERTREPMESSAGE_PKISTATUS_GET, CMP_R_ERROR_REQID_NOT_FOUND);
+	return -1;
+	}
+
+/* ############################################################################ *
+ * returns pointer to PKIFailureInfo of given certRep message
+ * returns NULL on error or if no matching failInfo was found
+ * ############################################################################ */
+CMP_PKIFAILUREINFO *CMP_CERTREPMESSAGE_PKIFailureInfo_get0(CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		{
+		if (certResponse->status)
+			return certResponse->status->failInfo;
+		}
+
+	CMPerr(CMP_F_CMP_CERTREPMESSAGE_PKIFAILUREINFO_GET0, CMP_R_ERROR_REQID_NOT_FOUND);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * returns pointer to PKIFailureInfoString character array of given certRep message
+ * returns NULL on error or if no matching failInfo was found
+ * ############################################################################ */
+char *CMP_CERTREPMESSAGE_PKIFailureInfoString_get0(CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		{
+		if (certResponse->status)
+			return CMP_PKISTATUSINFO_PKIFailureInfo_get_string(certResponse->status);
+		}
+
+	CMPerr(CMP_F_CMP_CERTREPMESSAGE_PKIFAILUREINFOSTRING_GET0, CMP_R_ERROR_REQID_NOT_FOUND);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * returns the status string of the given certReqId inside a CertRepMessage
+ * returns NULL on error
+ * ############################################################################ */
+STACK_OF(ASN1_UTF8STRING)* CMP_CERTREPMESSAGE_PKIStatusString_get0( CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		{
+		return certResponse->status->statusString;
+		}
+
+	CMPerr(CMP_F_CMP_CERTREPMESSAGE_PKISTATUSSTRING_GET0, CMP_R_ERROR_REQID_NOT_FOUND);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * checks bits in given PKIFailureInfo
+ * returns 1 if a given bit is set in a PKIFailureInfo
+ *				0 if			not set
+ *			   -1 on error
+ * PKIFailureInfo ::= ASN1_BIT_STRING
+ * ############################################################################ */
+int CMP_PKIFAILUREINFO_check( ASN1_BIT_STRING *failInfo, int codeBit)
+	{
+	if (!failInfo) return -1;
+	if ( (codeBit < 0) || (codeBit > CMP_PKIFAILUREINFO_MAX)) return -1;
+
+	return ASN1_BIT_STRING_get_bit( failInfo, codeBit);
+	}
+
+/* ############################################################################ *
+ * returns a pointer to the CertResponse with the given certReqId inside a CertRepMessage
+ * returns NULL on error or if no CertResponse available
+ * ############################################################################ */
+CMP_CERTRESPONSE *CMP_CERTREPMESSAGE_certResponse_get0( CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	CMP_CERTRESPONSE *certResponse=NULL;
+	int certRespCount;
+	int i;
+
+	if( !certRep) return NULL;
+
+	certRespCount = sk_CMP_CERTRESPONSE_num( certRep->response);
+
+	for( i=0; i < certRespCount; i++)
+		{
+		/* is it the right certReqId */
+        CMP_CERTRESPONSE *r = sk_CMP_CERTRESPONSE_value(certRep->response,i);
+		if( certReqId == ASN1_INTEGER_get(r->certReqId) )
+			{
+			certResponse = r;
+			break;
+			}
+		}
+
+	return certResponse;
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * returns a pointer to a copy of the Certificate with the given certReqId inside a CertRepMessage
+ * returns NULL on error or if no Certificate available
+ * ############################################################################ */
+static X509 *CMP_CERTREPMESSAGE_cert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	X509 *certCopy=NULL;
+	CMP_CERTRESPONSE *certResponse=NULL;
+
+	if( !certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		{
+		certCopy = X509_dup(certResponse->certifiedKeyPair->certOrEncCert->value.certificate);
+		}
+
+	return certCopy;
+	}
+
+/* ############################################################################# *
+ * internal function
+ *
+ * Decrypts the certificate with the given certReqId inside a CertRepMessage and
+ * this is needed for the indirect PoP method as in section 5.2.8.2
+ *
+ * returns a pointer to the decrypted certificate
+ * returns NULL on error or if no Certificate available
+ * ############################################################################# */
+static X509 *CMP_CERTREPMESSAGE_encCert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId, EVP_PKEY *pkey)
+	{
+	CRMF_ENCRYPTEDVALUE *encCert   = NULL;
+	X509				*cert	   = NULL; /* decrypted certificate					  */
+	EVP_CIPHER_CTX		*evp_ctx   = NULL; /* context for symmetric encryption		  */
+	unsigned char		*ek		   = NULL; /* decrypted symmetric encryption key	  */
+	const EVP_CIPHER	*cipher    = NULL; /* used cipher							  */
+	unsigned char		*iv		   = NULL; /* initial vector for symmetric encryption */
+	unsigned char		*outbuf    = NULL; /* decryption output buffer				  */
+	const unsigned char *p		   = NULL; /* needed for decoding ASN1				  */
+	int					 symmAlg   = 0;    /* NIDs for symmetric algorithm            */
+	int					 n, outlen = 0;
+	EVP_PKEY_CTX		*pkctx	   = NULL; /* private key context */
+	CMP_CERTRESPONSE *certResponse = NULL;
+
+	if ( !(certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		goto err;
+
+	if ( !(encCert = certResponse->certifiedKeyPair->certOrEncCert->value.encryptedCert))
+		goto err;
+
+	if ( !(symmAlg = OBJ_obj2nid(encCert->symmAlg->algorithm)))
+		goto err;
+
+	/* first the symmetric key needs to be decrypted */
+	if ((pkctx = EVP_PKEY_CTX_new(pkey, NULL)) && EVP_PKEY_decrypt_init(pkctx))
+		{
+		ASN1_BIT_STRING *encKey = encCert->encSymmKey;
+		size_t eksize = 0;
+
+		if (EVP_PKEY_decrypt(pkctx, NULL, &eksize, encKey->data, encKey->length) <= 0
+			|| !(ek = OPENSSL_malloc(eksize))
+			|| EVP_PKEY_decrypt(pkctx, ek, &eksize, encKey->data, encKey->length) <= 0)
+			{
+			CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_SYMMETRIC_KEY);
+			goto err;
+			}
+		EVP_PKEY_CTX_free(pkctx);
+		}
+	else {
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_KEY);
+		goto err;
+		}
+
+	/* select symmetric cipher based on algorithm given in message */
+	if (!(cipher = EVP_get_cipherbynid(symmAlg)))
+		{
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_UNSUPPORTED_CIPHER);
+		goto err;
+		}
+	if (!(iv = OPENSSL_malloc(cipher->iv_len))) goto err;
+	ASN1_TYPE_get_octetstring(encCert->symmAlg->parameter, iv, cipher->iv_len);
+
+	/* d2i_X509 changes the given pointer, so use p for decoding the message and keep the
+	 * original pointer in outbuf so that the memory can be freed later */
+	if (!(p = outbuf = OPENSSL_malloc(encCert->encValue->length + cipher->block_size))) goto err;
+	evp_ctx = EVP_CIPHER_CTX_new();
+	EVP_CIPHER_CTX_set_padding(evp_ctx, 0);
+
+	if (!EVP_DecryptInit(evp_ctx, cipher, ek, iv)
+		|| !EVP_DecryptUpdate(evp_ctx, outbuf, &outlen, encCert->encValue->data, encCert->encValue->length)
+		|| !EVP_DecryptFinal(evp_ctx, outbuf+outlen, &n))
+		{
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_CERTIFICATE);
+		goto err;
+		}
+	outlen += n;
+
+	/* convert decrypted certificate from DER to internal ASN.1 structure */
+	if (!(cert = d2i_X509(NULL, &p, outlen)))
+		{
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECODING_CERTIFICATE);
+		goto err;
+		}
+
+	OPENSSL_free(outbuf);
+	EVP_CIPHER_CTX_free(evp_ctx);
+	OPENSSL_free(ek);
+	OPENSSL_free(iv);
+	return cert;
+err:
+	CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_ENCCERT);
+	if (outbuf) OPENSSL_free(outbuf);
+	if (evp_ctx) EVP_CIPHER_CTX_free(evp_ctx);
+	if (ek) OPENSSL_free(ek);
+	if (iv) OPENSSL_free(iv);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * returns the type of the certificate contained in the certificate response
+ * returns -1 on errror
+ * ############################################################################ */
+int CMP_CERTREPMESSAGE_certType_get( CMP_CERTREPMESSAGE *certRep, long certReqId)
+	{
+	CMP_CERTRESPONSE *certResponse=NULL;
+
+	if( !certRep) return -1;
+	if( !(certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		return -1;
+
+	return certResponse->certifiedKeyPair->certOrEncCert->type;
+	}
+
+/* ############################################################################ *
+ * returns 1 on success
+ * returns 0 on error
+ * ############################################################################ */
+int CMP_PKIMESSAGE_set_bodytype( CMP_PKIMESSAGE *msg, int type)
+	{
+	if( !msg) return 0;
+
+	msg->body->type = type;
+
+	return 1;
+	}
+
+/* ############################################################################ *
+ * returns the body type of the given CMP message
+ * returns -1 on error
+ * ############################################################################ */
+int CMP_PKIMESSAGE_get_bodytype( CMP_PKIMESSAGE *msg)
+	{
+	if( !msg) return -1;
+
+	return msg->body->type;
+	}
+
+/* ############################################################################ *
+ * return pointer to human readable error message string created out of the
+ * information extracted from given error message
+ * returns NULL on error
+ * ############################################################################ */
+char *CMP_PKIMESSAGE_parse_error_msg( CMP_PKIMESSAGE *msg, char *errormsg, int bufsize)
+	{
+	char *status, *failureinfo;
+
+	if( !msg) return NULL;
+	if( CMP_PKIMESSAGE_get_bodytype(msg) != V_CMP_PKIBODY_ERROR) return NULL;
+
+	status = CMP_PKISTATUSINFO_PKIstatus_get_string(msg->body->value.error->pKIStatusInfo);
+	if (!status)
+		{
+		CMPerr(CMP_F_CMP_PKIMESSAGE_PARSE_ERROR_MSG, CMP_R_ERROR_PARSING_ERROR_MESSAGE);
+		return NULL;
+		}
+
+	/* PKIFailureInfo is optional */
+	failureinfo = CMP_PKISTATUSINFO_PKIFailureInfo_get_string(msg->body->value.error->pKIStatusInfo);
+
+	STACK_OF(ASN1_UTF8STRING) *details = msg->body->value.error->pKIStatusInfo->statusString;
+	ASN1_UTF8STRING *str = 0;
+	if (details && sk_ASN1_UTF8STRING_num(details) > 0)
+		str = sk_ASN1_UTF8STRING_value(details, 0);
+
+	if (failureinfo && str && str->data) {
+		BIO_snprintf(errormsg, bufsize, "%s, %s: %s", status, failureinfo,
+					 str->data);
+	}
+	else if (failureinfo)
+		BIO_snprintf(errormsg, bufsize, "%s, %s", status, failureinfo);
+	else
+		BIO_snprintf(errormsg, bufsize, "%s", status);
+
+	return errormsg;
+	}
+
+/* ############################################################################ *
+ * Retrieve the returned certificate from the given certrepmessage.
+ * returns NULL if not found
+ * TODO: create another function handing multiple certreps when 2 certificates
+ * had been requested
+ * ############################################################################ */
+X509 *CMP_CERTREPMESSAGE_get_certificate(CMP_CTX *ctx, CMP_CERTREPMESSAGE *certrep)
+	{
+	X509 *newClCert = NULL;
+	int repNum = 0;
+
+	/* Get the certReqId of the first certresponse. Need to do it this way instead
+	 * of just using certReqId==0, because in error cases the server might reply with a certReqId
+	 * of -1... */
+	if (sk_CMP_CERTRESPONSE_num(certrep->response) > 0) {
+		CMP_CERTRESPONSE *r = sk_CMP_CERTRESPONSE_value(certrep->response, 0);
+		repNum = ASN1_INTEGER_get(r->certReqId);
+	}
+
+	CMP_CTX_set_failInfoCode(ctx, CMP_CERTREPMESSAGE_PKIFailureInfo_get0(certrep, repNum));
+
+	ctx->lastPKIStatus = CMP_CERTREPMESSAGE_PKIStatus_get( certrep, repNum);
+	switch (ctx->lastPKIStatus)
+		{
+		case CMP_PKISTATUS_waiting:
+			goto err;
+			break;
+
+		case CMP_PKISTATUS_grantedWithMods:
+			CMP_printf( ctx, "WARNING: got \"grantedWithMods\"");
+
+		case CMP_PKISTATUS_accepted:
+			/* if we received a certificate then place it to ctx->newClCert and return,
+			 * if the cert is encrypted then we first decrypt it. */
+			switch (CMP_CERTREPMESSAGE_certType_get(certrep, repNum))
+				{
+				case CMP_CERTORENCCERT_CERTIFICATE:
+					if( !(newClCert = CMP_CERTREPMESSAGE_cert_get1(certrep,repNum)))
+						{
+						CMPerr(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE, CMP_R_CERTIFICATE_NOT_FOUND);
+						goto err;
+						}
+					break;
+					/* certificate encrypted for PoP using indirect method according to section 5.2.8.2 */
+				case CMP_CERTORENCCERT_ENCRYPTEDCERT:
+					if( !(newClCert = CMP_CERTREPMESSAGE_encCert_get1(certrep,repNum,ctx->newPkey)))
+						{
+						CMPerr(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE, CMP_R_CERTIFICATE_NOT_FOUND);
+						goto err;
+						}
+					break;
+				default:
+					CMPerr(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE, CMP_R_UNKNOWN_CERTTYPE);
+					goto err;
+				}
+			break;
+
+			/* get all information in case of a rejection before going to error */
+		case CMP_PKISTATUS_rejection: {
+			char *failInfoString = NULL;
+			char *statusString = NULL;
+			int statusLen = 0;
+			ASN1_UTF8STRING *status = NULL;
+			STACK_OF(ASN1_UTF8STRING) *strstack = CMP_CERTREPMESSAGE_PKIStatusString_get0(certrep, repNum);
+
+			CMPerr(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE, CMP_R_REQUEST_REJECTED_BY_CA);
+
+			failInfoString = CMP_CERTREPMESSAGE_PKIFailureInfoString_get0(certrep, repNum);
+			if (failInfoString)
+				/* initialize status string with human readable failure info */
+				statusString = OPENSSL_strdup(failInfoString);
+			else
+				statusString = OPENSSL_strdup("<no failure info received>");
+
+			statusLen = strlen(statusString)+18;
+			statusString = OPENSSL_realloc(statusString, statusLen);
+			strcat(statusString, ", statusString: \""); /* length = 17 */
+
+			while ((status = sk_ASN1_UTF8STRING_pop(strstack)))
+				{
+				statusLen += strlen((char*)status->data)+1;
+				statusString = OPENSSL_realloc(statusString, statusLen);
+				if (!statusString) goto err;
+				strcat(statusString, (char*)status->data);
+				strcat(statusString, " ");
+				}
+
+			strcat(statusString, "\"");
+			ERR_add_error_data(1, statusString);
+
+			goto err;
+			break;
+			}
+
+		case CMP_PKISTATUS_revocationWarning:
+		case CMP_PKISTATUS_revocationNotification:
+		case CMP_PKISTATUS_keyUpdateWarning:
+			CMPerr(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE, CMP_R_NO_CERTIFICATE_RECEIVED);
+			goto err;
+			break;
+
+		default: {
+			STACK_OF(ASN1_UTF8STRING) *strstack = CMP_CERTREPMESSAGE_PKIStatusString_get0(certrep, 0);
+			ASN1_UTF8STRING *status = NULL;
+
+			CMPerr(CMP_F_CMP_CERTREPMESSAGE_GET_CERTIFICATE, CMP_R_UNKNOWN_PKISTATUS);
+			while ((status = sk_ASN1_UTF8STRING_pop(strstack)))
+				ERR_add_error_data(3, "statusString=\"", status->data, "\"");
+
+			CMP_printf( ctx, "ERROR: unknown pkistatus %ld", CMP_CERTREPMESSAGE_PKIStatus_get( certrep, repNum));
+			goto err;
+			break;
+			}
+		}
+
+	return newClCert;
+err:
+	return NULL;
+	}
+
+/* ################################################################ *
+ * Builds up the certificate chain of cert as high up as possible using
+ * the given X509_STORE containing all possible intermediate certificates and
+ * optionally the (possible) trust anchor(s).
+ *
+ * Intended use of this function is to find all the certificates below the trust
+ * anchor needed to verify an EE's own certificate.  Those are supposed to be
+ * included in the ExtraCerts field of every first sent message of an tansaction
+ * when MSG_SIG_ALG is utilized.
+ *
+ * NOTE: This creates duplicates of each certificate,
+ * so when the stack is no longer needed it should be freed with
+ * sk_X509_pop_free()
+ * NOTE: in case there are more than one possibilities for certificates up the
+ * chain, OpenSSL seems to take the first one, check X509_verify_cert() for
+ * details.
+ *
+ * returns a pointer to a stack of (duplicated) X509 certificates containing:
+ *	- the EE certificate given in the function arguments (cert)
+ *	- all intermediate certificates up the chain towards the trust anchor
+ *	- the trust anchor if it was included in the store
+ *	returns NULL on error
+ * ################################################################ */
+STACK_OF(X509) *CMP_build_cert_chain(X509_STORE *store, X509 *cert)
+	{
+	STACK_OF(X509) *chain = NULL, *chainDup = NULL;
+	X509_STORE_CTX *csc = NULL;
+	int i=0;
+
+	if (!store || !cert) goto err;
+
+	csc = X509_STORE_CTX_new();
+	if (!csc) goto err;
+
+	/* chainDup to store the duplicated certificates */
+	chainDup = sk_X509_new_null();
+	if (!chainDup) goto err;
+
+	X509_STORE_set_flags(store, 0); /* clear all flags, e.g. do not check CRLs */
+	if(!X509_STORE_CTX_init(csc,store,cert,NULL))
+		goto err;
+
+	X509_verify_cert(csc); /* ignore return value as it would fail without trust anchor given in store */
+
+	chain = X509_STORE_CTX_get_chain(csc);
+	for (i = 0; i < sk_X509_num(chain); i++)
+		{
+		X509 *certDup = X509_dup( sk_X509_value(chain, i) );
+		sk_X509_push(chainDup, certDup);
+		}
+
+	X509_STORE_CTX_free(csc);
+
+	return chainDup;
+
+err:
+	if (csc) X509_STORE_CTX_free(csc);
+	if (chainDup) sk_X509_free(chainDup);
+	return NULL;
+	}
+
+/* ############################################################################
+ * this function is inteded to be used only within the CMP library although it is
+ * included in cmp.h
+ *
+ * Returns the subject key identifier of the given certificate
+ * returns NULL on error, respecively when none was found.
+ * ############################################################################ */
+ASN1_OCTET_STRING *CMP_get_cert_subject_key_id(const X509 *cert)
+	{
+	unsigned char *subjKeyIDStrDer = NULL;
+	X509_EXTENSION *ex = NULL;
+	int subjKeyIDLoc = -1;
+
+	if(!cert) goto err;
+
+	subjKeyIDLoc = X509_get_ext_by_NID( (X509*) cert, NID_subject_key_identifier, -1);
+	if (subjKeyIDLoc == -1) goto err;
+
+	/* found a subject key ID */
+	if(!(ex = sk_X509_EXTENSION_value( cert->cert_info->extensions, subjKeyIDLoc))) goto err;
+
+	subjKeyIDStrDer = ex->value->data;
+	return d2i_ASN1_OCTET_STRING( NULL, (const unsigned char **) &subjKeyIDStrDer, ex->value->length);
+err:
+	return NULL;
+	}
diff -Naur crypto/cmp/cmp_msg.c crypto-/cmp/cmp_msg.c
--- cryptoold/cmp/cmp_msg.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_msg.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,533 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* crypto/cmp/cmp_msg.c
+ * Functions for creating CMP (RFC 4210) messages for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2014 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/safestack.h>
+#include <openssl/err.h>
+
+#include <string.h>
+
+/* ############################################################################ 
+ * Takes a stack of GENERAL_NAMEs and adds them to the given extension stack.
+ * this is used to setting subject alternate names to a certTemplate
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+static int add_altname_extensions(X509_EXTENSIONS **extensions, STACK_OF(GENERAL_NAME) *altnames, int critical)
+	{
+	X509_EXTENSION *ext = NULL;
+	unsigned char *der = NULL;
+	int derlen = 0;
+	ASN1_OCTET_STRING *str = NULL;;
+
+	if(!extensions) goto err;
+	if(!altnames) goto err;
+
+	if(!(str = ASN1_OCTET_STRING_new())) goto err;
+
+	if(!(ASN1_seq_pack_GENERAL_NAME(altnames, i2d_GENERAL_NAME, &der, &derlen))) goto err;
+
+	if(!ASN1_STRING_set(str, der, derlen)) goto err;
+	if(!X509_EXTENSION_create_by_NID(&ext, NID_subject_alt_name, critical, str)) goto err;
+
+	ASN1_OCTET_STRING_free(str);
+	OPENSSL_free(der);
+
+	if(!X509v3_add_ext(extensions, ext, 0)) goto err;
+
+	X509_EXTENSION_free(ext);
+
+	return 1;
+err:
+	if (ext) X509_EXTENSION_free(ext);
+	return 0;
+	}
+
+/* ############################################################################ 
+ * Takes a CERTIFICATEPOLICIES structure and adds it to the given extension stack.
+ * this is used to setting certificate policy OIDs to a certTemplate
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+static int add_policy_extensions(X509_EXTENSIONS **extensions, CERTIFICATEPOLICIES *policies)
+	{
+	X509_EXTENSION *ext = NULL;
+	unsigned char *der = NULL;
+	int derlen = 0;
+	ASN1_OCTET_STRING *str = NULL;
+
+	if(!extensions || !policies) goto err;
+
+	if(!(str = ASN1_OCTET_STRING_new())) goto err;
+
+	derlen = i2d_CERTIFICATEPOLICIES(policies, &der);
+	if(!ASN1_STRING_set(str, der, derlen)) goto err;
+	if(!X509_EXTENSION_create_by_NID(&ext, NID_certificate_policies, 1, str)) goto err;
+
+	ASN1_OCTET_STRING_free(str);
+	OPENSSL_free(der);
+
+	if(!X509v3_add_ext(extensions, ext, 0)) goto err;
+
+	X509_EXTENSION_free(ext);
+
+	return 1;
+err:
+	if (ext) X509_EXTENSION_free(ext);
+	return 0;
+	}
+
+/* ############################################################################
+ * Adds the certificates to the extraCerts fields in the given message.  For
+ * this it tries to build the certificate chain of our client cert (ctx->clCert)
+ * by using certificates in ctx->untrusted_store. If no untrusted store is set, 
+ * it will at least place the client certificate into extraCerts.
+ * Additionally all the certificates explicitly specified to be sent out
+ * (i.e. ctx->extraCertsOut) are added to the stack.
+ *
+ * Note: it will NOT put the trust anchor in the extraCerts - unless it would be
+ * in the untrusted store.
+ *
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+static int add_extraCerts(CMP_CTX *ctx, CMP_PKIMESSAGE *msg)
+	{
+	int i;
+
+	if (!ctx) goto err;
+	if (!msg) goto err;
+	if (!msg->extraCerts && !(msg->extraCerts = sk_X509_new_null())) goto err;
+
+	/* add any additional certificates from ctx->extraCertsOut */
+	for (i = 0; i < sk_X509_num(ctx->extraCertsOut); i++)
+		sk_X509_push(msg->extraCerts, X509_dup(sk_X509_value(ctx->extraCertsOut, i)));
+
+	if (ctx->clCert)
+		{
+		/* if we have untrusted store, try to add all the intermediate certs and our own */
+		if (ctx->untrusted_store)
+			{
+			STACK_OF(X509) *chain = CMP_build_cert_chain(ctx->untrusted_store, ctx->clCert);
+			int i;
+			for(i = 0; i < sk_X509_num(chain); i++)
+				{
+				X509 *cert = sk_X509_value(chain, i);
+				sk_X509_push(msg->extraCerts, cert);
+				}
+			sk_X509_free(chain); /* only frees the stack, not the content */
+			} else {
+			/* Make sure that at least our own cert gets sent */
+			sk_X509_push(msg->extraCerts, X509_dup(ctx->clCert));
+			}
+		}
+
+	return 1;
+
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * Creates a new polling request PKIMessage for the given request ID
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_pollReq_new( CMP_CTX *ctx, int reqId)
+	{
+	CMP_PKIMESSAGE *msg = NULL;
+	CMP_POLLREQ    *preq = NULL;
+	if (!ctx) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if( !CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_POLLREQ);
+
+	if(!(preq = CMP_POLLREQ_new())) goto err;
+	/* TODO support multiple cert request ids to poll */
+	ASN1_INTEGER_set(preq->certReqId, reqId);
+	if (!(msg->body->value.pollReq = sk_CMP_POLLREQ_new_null()))
+		goto err;
+
+	sk_CMP_POLLREQ_push(msg->body->value.pollReq, preq);
+
+	if(!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	return msg;
+err:
+	CMPerr(CMP_F_CMP_POLLREQ_NEW, CMP_R_ERROR_CREATING_POLLREQ);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Create a new Initial Request PKIMessage based on the settings in given ctx
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_ir_new( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE	*msg=NULL;
+	CRMF_CERTREQMSG *certReq0=NULL;
+	X509_EXTENSIONS *extensions = NULL;
+	X509_NAME *subject=NULL;
+
+	if (!ctx) goto err;
+
+	/* for authentication we need either a reference value/secret or external identity certificate (E.7) and private key */
+	if (!((ctx->referenceValue && ctx->secretValue) || (ctx->pkey && ctx->clCert))) goto err;
+
+	/* new key pair for new Certificate must be set */
+	if (!ctx->newPkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if (!CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm(msg)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_IR);
+
+	if (ctx->subjectName)
+		subject = ctx->subjectName;
+	else if (ctx->clCert && sk_GENERAL_NAME_num(ctx->subjectAltNames) <= 0)
+		/* get subject name from existing certificate (E.7) */
+		subject = X509_get_subject_name(ctx->clCert);
+	else
+		subject = NULL;
+
+	if (sk_GENERAL_NAME_num(ctx->subjectAltNames) > 0)
+		/* According to RFC5280, subjectAltName MUST be critical if subject is null */
+		add_altname_extensions(&extensions, ctx->subjectAltNames, ctx->setSubjectAltNameCritical || subject == NULL);
+
+	if (ctx->policies)
+		add_policy_extensions(&extensions, ctx->policies);
+
+	if (!(msg->body->value.ir = sk_CRMF_CERTREQMSG_new_null())) goto err;
+	if (!(certReq0 = CRMF_cr_new(0L, ctx->newPkey, subject, extensions))) goto err;
+	sk_CRMF_CERTREQMSG_push( msg->body->value.ir, certReq0);
+	/* TODO: here also the optional 2nd certreqmsg could be pushed to the stack */
+
+    /* sets the id-regCtrl-regToken to regInfo (not described in RFC, but EJBCA
+	 * in CA mode might insist on that) */
+	if (ctx->regToken)
+		if (!CRMF_CERTREQMSG_set1_regInfo_regToken(certReq0, ctx->regToken)) goto err;
+
+	CRMF_CERTREQMSG_calc_and_set_popo( certReq0, ctx->newPkey, ctx->popoMethod);
+
+	add_extraCerts(ctx, msg);
+	if (!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	/* cleanup */
+	if (extensions) sk_X509_EXTENSION_pop_free(extensions, X509_EXTENSION_free);
+	
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_IR_NEW, CMP_R_ERROR_CREATING_IR);
+	if (extensions) sk_X509_EXTENSION_pop_free(extensions, X509_EXTENSION_free);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Creates a new Revocation Request PKIMessage based on the settings in ctx
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_rr_new( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE	*msg=NULL;
+	CRMF_CERTTEMPLATE *certTpl=NULL;
+	X509_NAME *subject=NULL;
+	CMP_REVDETAILS *rd=NULL;
+
+	if (!ctx) goto err;
+	if (!ctx->clCert) goto err;
+	if (!ctx->pkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if (!CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_RR);
+
+	if (!(msg->body->value.rr = sk_CMP_REVDETAILS_new_null())) goto err;
+	if (!(rd = CMP_REVDETAILS_new())) goto err;
+	sk_CMP_REVDETAILS_push( msg->body->value.rr, rd);
+
+	if (!(certTpl = CRMF_CERTTEMPLATE_new())) goto err;
+	rd->certDetails = certTpl;
+
+	/* Set the subject from the previous certificate */
+	if (!(subject = X509_get_subject_name(ctx->clCert))) goto err;
+	X509_NAME_set(&certTpl->subject, subject);
+	X509_PUBKEY_set(&certTpl->publicKey, ctx->pkey);
+	if (!(certTpl->serialNumber = ASN1_INTEGER_dup(ctx->clCert->cert_info->serialNumber))) goto err;
+	X509_NAME_set(&certTpl->issuer, ctx->clCert->cert_info->issuer);
+
+	/* TODO: the Revocation Passphrase according to section 5.3.19.9 could be set here if set in ctx */
+
+	if(!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_RR_NEW, CMP_R_ERROR_CREATING_RR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Creates a new Certificate Request PKIMessage based on the settings in ctx
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_cr_new( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE	*msg=NULL;
+	CRMF_CERTREQMSG *certReq0=NULL;
+	X509_NAME *subject=NULL;
+
+	if (!ctx) goto err;
+	/* for authentication we need either a reference value/secret for MSG_MAC_ALG 
+	 * or existing certificate and private key for MSG_SIG_ALG */
+	if (!((ctx->referenceValue && ctx->secretValue) || (ctx->pkey && ctx->clCert))) goto err;
+	if (!ctx->pkey) goto err;
+
+	if (ctx->subjectName)
+		subject = ctx->subjectName;
+	else if (ctx->clCert) /* get subject name from existing certificate */
+		subject = X509_get_subject_name(ctx->clCert);
+	else
+		goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if (!CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm(msg)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_CR);
+
+	if (!(msg->body->value.cr = sk_CRMF_CERTREQMSG_new_null())) goto err;
+	if (!(certReq0 = CRMF_cr_new(0L, ctx->pkey, subject, NULL))) goto err;
+	sk_CRMF_CERTREQMSG_push( msg->body->value.cr, certReq0);
+	/* TODO: here also the optional 2nd certreqmsg could be pushed to the stack */
+
+	CRMF_CERTREQMSG_calc_and_set_popo( certReq0, ctx->pkey, ctx->popoMethod);
+
+	add_extraCerts(ctx, msg);
+	if (!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_CR_NEW, CMP_R_ERROR_CREATING_CR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Creates a new Key Update Request PKIMessage based on the settings in ctx
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * TODO: the differentiation between certificate used to sign the CMP messages
+ * and the certificate to update should be improved - so far only the clCert
+ * could be updated
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_kur_new( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *msg=NULL;
+	CRMF_CERTREQMSG *certReq0=NULL;
+	X509_EXTENSIONS *extensions = NULL;
+	X509_NAME *subject=NULL;
+
+	if (!ctx) goto err;
+	/* for authentication we need either a reference value/secret for MSG_MAC_ALG 
+	 * or existing certificate and private key for MSG_SIG_ALG */
+	if (!((ctx->referenceValue && ctx->secretValue) || (ctx->pkey && ctx->clCert))) goto err;
+	if (!ctx->newPkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if (!CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm( msg)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_KUR);
+
+	if (ctx->subjectName)
+		subject = ctx->subjectName;
+	else
+		subject = X509_get_subject_name( (X509*) ctx->clCert); /* TODO: from certificate to be renewed */
+
+	if (sk_GENERAL_NAME_num(ctx->subjectAltNames) > 0)
+		/* According to RFC5280, subjectAltName MUST be critical if subject is null */
+		add_altname_extensions(&extensions, ctx->subjectAltNames, ctx->setSubjectAltNameCritical || subject == NULL);
+
+	if (ctx->policies)
+		add_policy_extensions(&extensions, ctx->policies);
+
+	if (!(msg->body->value.kur = sk_CRMF_CERTREQMSG_new_null())) goto err;
+	if (!(certReq0 = CRMF_cr_new(0L, ctx->newPkey, subject, extensions))) goto err;
+	sk_CRMF_CERTREQMSG_push( msg->body->value.kur, certReq0);
+	/* TODO: here also the optional 2nd certreqmsg could be pushed to the stack */
+
+	/* setting OldCertId according to D.6:
+	   7.  regCtrl OldCertId SHOULD be used */
+
+	if (ctx->oldClCert)
+		CRMF_CERTREQMSG_set1_control_oldCertId( certReq0, ctx->oldClCert);
+	else
+		CRMF_CERTREQMSG_set1_control_oldCertId( certReq0, ctx->clCert);
+
+
+	CRMF_CERTREQMSG_calc_and_set_popo( certReq0, ctx->newPkey, ctx->popoMethod);
+
+	add_extraCerts(ctx, msg);
+	if (!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	if (extensions) sk_X509_EXTENSION_pop_free(extensions, X509_EXTENSION_free);
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_KUR_NEW, CMP_R_ERROR_CREATING_KUR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	if (extensions) sk_X509_EXTENSION_pop_free(extensions, X509_EXTENSION_free);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Creates a new Certificate Confirmation PKIMessage
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * TODO: handle both possible certificates when signing and encrypting
+ * certificates have been requested/received
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_certConf_new( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *msg=NULL;
+	CMP_CERTSTATUS *certStatus=NULL;
+
+	if (!ctx) goto err;
+	/* for authentication we need either a reference value/secret for MSG_MAC_ALG 
+	 * or existing certificate and private key for MSG_SIG_ALG */
+	if (!((ctx->referenceValue && ctx->secretValue) || (ctx->pkey && ctx->clCert))) goto err;
+	if (!ctx->newClCert) goto err; /* in this case we wouldn't have received a certificate */
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if (!CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_CERTCONF);
+	if (!(msg->body->value.certConf = sk_CMP_CERTSTATUS_new_null())) goto err;
+
+	if (!(certStatus = CMP_CERTSTATUS_new())) goto err;
+	if (!sk_CMP_CERTSTATUS_push( msg->body->value.certConf, certStatus)) goto err;
+	/* set the # of the certReq */
+	ASN1_INTEGER_set(certStatus->certReqId,0L);
+	/* -- the hash of the certificate, using the same hash algorithm
+	 * -- as is used to create and verify the certificate signature */
+	CMP_CERTSTATUS_set_certHash( certStatus, ctx->newClCert);
+
+	/* execute the callback function set in ctx which can be used to examine a
+	 * certificate and reject it */
+	if (ctx->certConf_cb && ctx->newClCert && ctx->certConf_cb(ctx->lastPKIStatus, ctx->newClCert) == 0)
+		{
+		certStatus->statusInfo = CMP_PKISTATUSINFO_new();
+		ASN1_INTEGER_set(certStatus->statusInfo->status, CMP_PKISTATUS_rejection);
+		CMP_printf(ctx, "INFO: rejecting certificate.");
+		}
+
+	if (!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_CERTCONF_NEW, CMP_R_ERROR_CREATING_CERTCONF);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Creates a new General Message with an empty itav stack
+ * returns a pointer to the PKIMessage on success, NULL on error
+ * ############################################################################ */
+CMP_PKIMESSAGE *CMP_genm_new( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *msg=NULL;
+
+	if (!ctx) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	if (!CMP_PKIHEADER_init( ctx, msg->header)) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_GENM);
+	if (!(msg->body->value.genm = sk_CMP_INFOTYPEANDVALUE_new_null())) goto err; /* initialize with empty stack */
+
+	if (!CMP_PKIMESSAGE_protect(ctx, msg)) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_GENM_NEW, CMP_R_ERROR_CREATING_GENM);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+	}
+
diff -Naur crypto/cmp/cmp_ses.c crypto-/cmp/cmp_ses.c
--- cryptoold/cmp/cmp_ses.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_ses.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,866 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+ /* crypto/cmp/cmp_ses.c
+ * Functions to do CMP (RFC 4210) message sequences for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *		notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *		notice, this list of conditions and the following disclaimer in
+ *		the documentation and/or other materials provided with the
+ *		distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *		software must display the following acknowledgment:
+ *		"This product includes software developed by the OpenSSL Project
+ *		for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *		endorse or promote products derived from this software without
+ *		prior written permission. For written permission, please contact
+ *		openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *		nor may "OpenSSL" appear in their names without prior written
+ *		permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *		acknowledgment:
+ *		"This product includes software developed by the OpenSSL Project
+ *		for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <string.h>
+
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+
+#include <unistd.h>
+
+/* XXX this is here to fool the openssl perl script that checks errors codes strictly
+ *     without func() the macro below would cause the script to complain */
+#if 0
+static void func() { }
+#endif
+/* adds connection error information to OpenSSL error queue */
+#define ADD_HTTP_ERROR_INFO(cmp_f_func, errcode, msg)\
+		if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT\
+			&& ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)\
+			CMPerr(cmp_f_func, errcode);\
+		else\
+			add_error_data("unable to send "msg);
+
+/* ############################################################################ *
+ * table used to translate PKIMessage body type number into a printable string
+ * ############################################################################ */
+static char *V_CMP_TABLE[] = {
+	"IR",
+	"IP",
+	"CR",
+	"CP",
+	"P10CR",
+	"POPDECC",
+	"POPDECR",
+	"KUR",
+	"KUP",
+	"KRR",
+	"KRP",
+	"RR",
+	"RP",
+	"CCR",
+	"CCP",
+	"CKUANN",
+	"CANN",
+	"RANN",
+	"CRLANN",
+	"PKICONF",
+	"NESTED",
+	"GENM",
+	"GENP",
+	"ERROR",
+	"CERTCONF",
+	"POLLREQ",
+	"POLLREP",
+};
+
+#define MSG_TYPE_STR(type)	\
+	(((unsigned int) (type) < sizeof(V_CMP_TABLE)/sizeof(V_CMP_TABLE[0])) \
+	 ? V_CMP_TABLE[(unsigned int)(type)] : "unknown")
+
+/* ############################################################################ * 
+ * internal function
+ *
+ * Prints error data of the given CMP_PKIMESSAGE into a buffer specified by out
+ * and returns pointer to the buffer.
+ * ############################################################################ */
+static char *PKIError_data(CMP_PKIMESSAGE *msg, char *out, int outsize)
+	{
+	char tempbuf[1024];
+	switch (CMP_PKIMESSAGE_get_bodytype(msg))
+		{
+		case V_CMP_PKIBODY_ERROR:
+			BIO_snprintf(out, outsize, "bodytype=%d, error=\"%s\"",
+				V_CMP_PKIBODY_ERROR,
+				CMP_PKIMESSAGE_parse_error_msg( msg, tempbuf, sizeof(tempbuf)));
+			break;
+		case -1:
+			BIO_snprintf(out, outsize, "received NO message");
+			break;
+		default:
+			BIO_snprintf(out, outsize, "received unexpected message of type '%s'", MSG_TYPE_STR(CMP_PKIMESSAGE_get_bodytype( msg)));
+			break;
+		}
+	return out;
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * Adds text to the extra error data field of the last error in openssl's error
+ * queue. ERR_add_error_data() simply overwrites the previous contents of the error
+ * data, while this function can be used to add a string to the end of it.
+ * ############################################################################ */
+static void add_error_data(const char *txt)
+	{
+	const char *current_error=NULL;
+	ERR_peek_last_error_line_data(NULL, NULL, &current_error, NULL);
+	ERR_add_error_data(3, current_error, ":", txt);
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * When a 'waiting' PKIStatus has been received, this function is used to attempt
+ * to poll for a response message. 
+ *
+ * A maxPollTime timeout can be set in the context.  The function will continue
+ * to poll until the timeout is reached and then poll a last time even when that
+ * is before the "checkAfter" sent by the server.  If ctx->maxPollTime is 0, the
+ * timeout is disabled.
+ *
+ * returns 1 on success, returns received PKIMESSAGE in *msg argument
+ * returns 0 on error or when timeout is reached without a received messsage
+ *
+ * TODO handle multiple pollreqs for multiple certificates
+ * ############################################################################ */
+static int pollForResponse(CMP_CTX *ctx, CMP_CERTREPMESSAGE *certrep, CMP_PKIMESSAGE **msg)
+	{
+	int maxTimeLeft = ctx->maxPollTime;
+	CMP_PKIMESSAGE *preq = NULL;
+	CMP_PKIMESSAGE *prep = NULL;
+	CMP_POLLREP *pollRep = NULL;
+
+	CMP_printf(ctx, "INFO: Received 'waiting' PKIStatus, attempting to poll server for response.");
+	for (;;)
+		{
+		if(!(preq = CMP_pollReq_new(ctx, 0))) goto err; /* TODO: this only handles one certificate request so far */
+
+
+		CMP_printf(ctx, "INFO: Sending polling request...");
+		/* immediately send the first pollReq */
+		if (! (CMP_PKIMESSAGE_http_perform(ctx, preq, &prep)))
+			{
+			/* set message to error stack */
+			ADD_HTTP_ERROR_INFO(CMP_F_POLLFORRESPONSE, CMP_R_POLLREP_NOT_RECEIVED, "pollReq");
+			goto err;
+			}
+
+		/* handle potential pollRep */
+		if (CMP_PKIMESSAGE_get_bodytype(prep) == V_CMP_PKIBODY_POLLREP)
+			{
+			int checkAfter;
+			if(!(pollRep = sk_CMP_POLLREP_value(prep->body->value.pollRep, 0))) goto err; /* TODO: this only handles one certificate request so far */
+			checkAfter = ASN1_INTEGER_get(pollRep->checkAfter);
+			/* TODO: print OPTIONAL reason (PKIFreeText) from message */
+			CMP_printf(ctx, "INFO: Received polling response, waiting checkAfter = %ld seconds before sending another polling request...", checkAfter);
+
+			if (ctx->maxPollTime != 0)
+				{        /* timout is set in context */
+				if (maxTimeLeft == 0) goto err; /* timeout reached */
+				if (maxTimeLeft > checkAfter)
+					{
+					maxTimeLeft -= checkAfter;
+					}
+				else
+					{
+					checkAfter = maxTimeLeft; /* poll a last time just when the set timeout will be reached */
+					maxTimeLeft = 0;
+					}
+				}
+
+			CMP_PKIMESSAGE_free(prep);
+			CMP_PKIMESSAGE_free(preq);
+			sleep(checkAfter);
+			}
+		else break; /* final success */
+		}
+	if (!prep) goto err;
+
+	CMP_PKIMESSAGE_free(preq);
+	*msg = prep;
+
+	return 1; 
+err:
+	CMP_PKIMESSAGE_free(preq);
+	CMP_PKIMESSAGE_free(prep);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * send certConf for IR, CR or KUR sequences
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+static int sendCertConf( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *certConf=NULL;
+	CMP_PKIMESSAGE *PKIconf=NULL;
+
+	/* crate Certificate Confirmation - certConf */
+	if (!(certConf = CMP_certConf_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Certificate Confirm");
+	if (! (CMP_PKIMESSAGE_http_perform(ctx, certConf, &PKIconf)))
+		{
+		ADD_HTTP_ERROR_INFO(CMP_F_SENDCERTCONF, CMP_R_PKICONF_NOT_RECEIVED, "certConf");
+		goto err;
+		}
+
+	/* make sure the received messagetype indicates an PKIconf message */
+	if (CMP_PKIMESSAGE_get_bodytype(PKIconf) != V_CMP_PKIBODY_PKICONF)
+		{
+		char errmsg[256];
+		CMPerr(CMP_F_SENDCERTCONF, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data( PKIconf, errmsg, sizeof(errmsg)));
+		goto err;
+		}
+
+	/* validate message protection */
+	if (CMP_validate_msg(ctx, PKIconf))
+		{
+		CMP_printf( ctx,"SUCCESS: validating protection of incoming message");
+		}
+	else
+		{
+		CMPerr(CMP_F_SENDCERTCONF, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+		}
+
+	/* compare received nonce with the one sent in certConf */
+	if (PKIconf->header->recipNonce)
+		{
+		if(ASN1_OCTET_STRING_cmp(certConf->header->senderNonce, PKIconf->header->recipNonce))
+			{
+			CMPerr(CMP_F_SENDCERTCONF, CMP_R_ERROR_NONCES_DO_NOT_MATCH);
+			goto err;
+			}
+		} /* it's not clear from the RFC whether recipNonce MUST be set or not */
+
+	CMP_PKIMESSAGE_free(certConf);
+	CMP_PKIMESSAGE_free(PKIconf);
+	return 1;
+err:
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * saves error information from PKIStatus field of a certrepmessage into the ctx
+ * TODO: in case we would get multiple certreps, this function would need to be 
+ *       extended to save the status from each one
+ * ############################################################################ */
+static void save_certrep_statusInfo(CMP_CTX *ctx, CMP_CERTREPMESSAGE *certrep)
+	{
+	CMP_CERTRESPONSE *resp=NULL;
+	int i = 0;
+
+	if (sk_CMP_CERTRESPONSE_num(certrep->response) > 0 &&
+		(resp = sk_CMP_CERTRESPONSE_value(certrep->response, 0)) &&
+		resp->status != NULL)
+		{
+		CMP_CTX_set_failInfoCode(ctx, resp->status->failInfo);
+		ctx->lastPKIStatus = CMP_PKISTATUSINFO_PKIstatus_get(resp->status);
+
+		if (!ctx->lastStatusString)
+			ctx->lastStatusString = sk_ASN1_UTF8STRING_new_null();
+
+		if (ctx->lastStatusString)
+			{
+			for (i = 0; i < sk_ASN1_UTF8STRING_num(resp->status->statusString); i++)
+				{
+				ASN1_UTF8STRING *str = sk_ASN1_UTF8STRING_value(resp->status->statusString, i);
+				sk_ASN1_UTF8STRING_push(ctx->lastStatusString, ASN1_STRING_dup(str));
+				}
+			}
+		}
+	}
+
+/* ############################################################################ *
+ * do the full sequence for IR, including IR, IP, certConf, PKIconf and
+ * potential polling
+ *
+ * All options need to be set in the context.
+ *
+ * TODO: another function to request two certificates at once should be created
+ *
+ * returns pointer to received certificate, NULL if none was received
+ * ############################################################################ */
+X509 *CMP_doInitialRequestSeq( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *ir=NULL;
+	CMP_PKIMESSAGE *ip=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx || !ctx->newPkey ||
+		/* for authentication we need either reference/secret or external 
+		 * identity certificate and private key, the server name/cert might not be
+		 * known here yet especiallaly in case of E.7 */
+			(!(ctx->referenceValue && ctx->secretValue) &&  /* MSG_MAC_ALG */
+			!(ctx->pkey && ctx->clCert)) )
+		{ /* MSG_SIG_ALG for E.7 */
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+		}
+
+	/* create Initialization Request - ir */
+	if (!(ir = CMP_ir_new(ctx))) goto err;
+
+	CMP_printf(ctx, "INFO: Sending Initialization Request");
+	if (! (CMP_PKIMESSAGE_http_perform(ctx, ir, &ip)))
+		{
+		ADD_HTTP_ERROR_INFO(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_IP_NOT_RECEIVED, "ir");
+		goto err;
+		}
+	
+	/* catch if the received messagetype does not indicate an IP message (e.g. error)*/
+	if (CMP_PKIMESSAGE_get_bodytype(ip) != V_CMP_PKIBODY_IP)
+		{
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(ip, errmsg, sizeof(errmsg)));
+		goto err;
+		}
+
+	save_certrep_statusInfo(ctx, ip->body->value.ip);
+
+	/* validate message protection */
+	if (CMP_validate_msg(ctx, ip))
+		{
+		CMP_printf( ctx, "SUCCESS: validating protection of incoming message");
+		} else {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+		}
+
+	/* compare received nonce with the one sent in IR */
+	if (ip->header->recipNonce)
+		{
+		if(ASN1_OCTET_STRING_cmp(ir->header->senderNonce, ip->header->recipNonce))
+			{
+			/* senderNonce != recipNonce (sic although there is no "!" in the if) */
+			CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_ERROR_NONCES_DO_NOT_MATCH);
+			goto err;
+			}
+		} /* it's not clear from the RFC whether recipNonce MUST be set or not */
+	CMP_CTX_set1_recipNonce(ctx, ip->header->senderNonce); /* store for setting in the next msg */
+
+	/* make sure the PKIStatus for the *first* CERTrepmessage indicates a certificate was granted */
+	/* TODO handle second CERTrepmessages if two would have sent */
+	if (CMP_CERTREPMESSAGE_PKIStatus_get( ip->body->value.ip, 0) == CMP_PKISTATUS_waiting)
+		if (!pollForResponse(ctx, ip->body->value.ip, &ip))
+			{
+			CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_IP_NOT_RECEIVED);
+			ERR_add_error_data(1, "received 'waiting' pkistatus but polling failed");
+			goto err;
+			}
+
+	if (!(ctx->newClCert = CMP_CERTREPMESSAGE_get_certificate(ctx, ip->body->value.ip))) goto err;
+
+	/* if the CA returned certificates in the caPubs field, copy them
+	 * to the context so that they can be retrieved if necessary 
+	 *
+	 * section 5.3.2:
+	 * Note that if the PKI
+	 * Message Protection is "shared secret information" (see Section
+	 * 5.1.3), then any certificate transported in the caPubs field may be
+	 * directly trusted as a root CA certificate by the initiator. */
+
+	if (ip->body->value.ip->caPubs)
+		CMP_CTX_set1_caPubs(ctx, ip->body->value.ip->caPubs);
+
+	/* copy any received extraCerts to ctx->extraCertsIn so they can be retrieved */
+	if (ip->extraCerts)
+		CMP_CTX_set1_extraCertsIn(ctx, ip->extraCerts);
+
+	/* check if implicit confirm is set in generalInfo and send certConf if not */
+	if (!CMP_PKIMESSAGE_check_implicitConfirm(ip)) 
+		if (!sendCertConf(ctx)) goto err;
+
+	CMP_PKIMESSAGE_free(ir);
+	CMP_PKIMESSAGE_free(ip);
+	return ctx->newClCert;
+
+err:
+	if (ir) CMP_PKIMESSAGE_free(ir);
+	if (ip) CMP_PKIMESSAGE_free(ip);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_CTX_error_callback, (void*) ctx);
+	return NULL;
+	}
+
+
+/* ############################################################################ *
+ * do the full sequence for RR, including RR, RP and potential polling
+ *
+ * All options need to be set in the context.
+ *
+ * TODO: this function can only revoke one certifcate so far, should be possible
+ * for several according to 5.3.9
+ * TODO: this actually revokes the current clCertificate - it might be desired
+ * to revoke another certificate the EE posesses.
+ *
+ * The RFC is vague in which PKIStatus should be returned by the server, so we
+ * take "accepted, grantedWithMods, revocationWaring, revocationNotification"
+ * as information that the certifcate was revoked, "rejection" as information
+ * that the revocation was rejected and don't expect "waiting, keyUpdateWarning"
+ * (which are handled as error)
+ *
+ * returns according to PKIStatus received, 0 on error
+ *          accepted               (1)
+ *          grantedWithMods        (2)
+ *          rejection              (3) (this is not an error!)
+ *          revocationWarning      (5)
+ *          revocationNotification (6)
+ * ############################################################################ */
+int CMP_doRevocationRequestSeq( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *rr=NULL;
+	CMP_PKIMESSAGE *rp=NULL;
+	int pkiStatus = 0;
+
+	if (!ctx || !ctx->serverName || !ctx->pkey ||
+		!ctx->clCert || !(ctx->srvCert || ctx->trusted_store))
+		{
+		CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+		}
+
+	if (! (rr = CMP_rr_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Revocation Request");
+	if (! (CMP_PKIMESSAGE_http_perform(ctx, rr, &rp)))
+		{
+		ADD_HTTP_ERROR_INFO(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_RP_NOT_RECEIVED, "rr");
+		goto err;
+		}
+
+	/* make sure the received messagetype indicates an RP message */
+	if (CMP_PKIMESSAGE_get_bodytype( rp) != V_CMP_PKIBODY_RP)
+		{
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data( rp, errmsg, sizeof(errmsg)));
+		goto err;
+		}
+
+	/* validate message protection */
+	if (CMP_validate_msg(ctx, rp))
+		{
+		CMP_printf(  ctx, "SUCCESS: validating protection of incoming message");
+		}
+	else
+		{
+		CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+		}
+
+	/* compare received nonce with the one sent in RR */
+	if (rp->header->recipNonce)
+		{
+		if(ASN1_OCTET_STRING_cmp(rr->header->senderNonce, rp->header->recipNonce))
+			{
+			/* senderNonce != recipNonce (sic although there is no "!" in the if) */
+			CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_ERROR_NONCES_DO_NOT_MATCH);
+			goto err;
+			}
+		} /* it's not clear from the RFC whether recipNonce MUST be set or not */
+	
+
+	/* evaluate PKIStatus field */
+	switch (pkiStatus = CMP_REVREPCONTENT_PKIStatus_get( rp->body->value.rp, 0)) 
+		{
+		case CMP_PKISTATUS_accepted:
+			CMP_printf( ctx, "INFO: revocation accepted (PKIStatus=accepted)");
+			break;
+		case CMP_PKISTATUS_grantedWithMods:
+			CMP_printf( ctx, "INFO: revocation accepted (PKIStatus=grantedWithMods)");
+			break;
+		case CMP_PKISTATUS_rejection:
+			CMP_printf( ctx, "INFO: revocation rejected (PKIStatus=rejection)");
+			break;
+		case CMP_PKISTATUS_revocationWarning:
+			CMP_printf( ctx, "INFO: revocation accepted (PKIStatus=revocationWarning)");
+			break;
+		case CMP_PKISTATUS_revocationNotification:
+			CMP_printf( ctx, "INFO: revocation accepted (PKIStatus=revocationNotification)");
+			break;
+		case CMP_PKISTATUS_waiting:
+		case CMP_PKISTATUS_keyUpdateWarning:
+			CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_UNEXPECTED_PKISTATUS);
+			goto err;
+		default:
+			CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_UNKNOWN_PKISTATUS);
+			goto err;
+		}
+
+	CMP_PKIMESSAGE_free(rr);
+	CMP_PKIMESSAGE_free(rp);
+	return (pkiStatus+1);
+err:
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_CTX_error_callback, (void*) ctx);
+	if (rr) CMP_PKIMESSAGE_free(rr);
+	if (rp) CMP_PKIMESSAGE_free(rp);
+	return 0;
+	}
+
+
+/* ############################################################################ *
+ * do the full sequence for CR, including CR, CP, certConf, PKIconf and
+ * potential polling
+ *
+ * All options need to be set in the context.
+ *
+ * TODO: another function to request two certificates at once should be created
+ *
+ * returns pointer to received certificate, NULL if non was received
+ * ############################################################################ */
+X509 *CMP_doCertificateRequestSeq( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *cr=NULL;
+	CMP_PKIMESSAGE *cp=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx ||  !ctx->pkey ||
+			(!(ctx->referenceValue && ctx->secretValue) && /* MSG_MAC_ALG */
+			!(ctx->pkey && ctx->clCert && (ctx->srvCert || ctx->trusted_store))) /* MSG_SIG_ALG */
+		)
+		{
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+		}
+
+	/* create Certificate Request - cr */
+	if (! (cr = CMP_cr_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Certificate Request");
+	if (! (CMP_PKIMESSAGE_http_perform(ctx, cr, &cp)))
+		{
+		ADD_HTTP_ERROR_INFO(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_CP_NOT_RECEIVED, "cr");
+		goto err;
+		}
+
+	/* make sure the received messagetype indicates an CP message */
+	if (CMP_PKIMESSAGE_get_bodytype( cp) != V_CMP_PKIBODY_CP)
+		{
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data( cp, errmsg, sizeof(errmsg)));
+		goto err;
+		}
+
+	save_certrep_statusInfo(ctx, cp->body->value.cp);
+
+	/* validate message protection */
+	if (CMP_validate_msg(ctx, cp))
+		{
+		CMP_printf(  ctx, "SUCCESS: validating protection of incoming message");
+		} else {
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+		}
+
+	/* compare received nonce with the one sent in CR */
+	if (cp->header->recipNonce)
+		{
+		if(ASN1_OCTET_STRING_cmp(cr->header->senderNonce, cp->header->recipNonce))
+			{
+			/* senderNonce != recipNonce (sic although there is no "!" in the if) */
+			CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_ERROR_NONCES_DO_NOT_MATCH);
+			goto err;
+			}
+		} /* it's not clear from the RFC whether recipNonce MUST be set or not */
+	CMP_CTX_set1_recipNonce(ctx, cp->header->senderNonce); /* store for setting in the next msg */
+
+	/* evaluate PKIStatus field */
+	if (CMP_CERTREPMESSAGE_PKIStatus_get( cp->body->value.cp, 0) == CMP_PKISTATUS_waiting)
+		if (!pollForResponse(ctx, cp->body->value.cp, &cp))
+			{
+			CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_CP_NOT_RECEIVED);
+			ERR_add_error_data(1, "received 'waiting' pkistatus but polling failed");
+			goto err;
+			}
+
+	if (!(ctx->newClCert = CMP_CERTREPMESSAGE_get_certificate(ctx, cp->body->value.cp))) goto err;
+
+	/* copy any received extraCerts to ctx->etraCertsIn so they can be retrieved */
+	if (cp->extraCerts)
+		CMP_CTX_set1_extraCertsIn(ctx, cp->extraCerts);
+
+	/* check if implicit confirm is set in generalInfo and send certConf if not */
+	if (!CMP_PKIMESSAGE_check_implicitConfirm(cp)) 
+		if (!sendCertConf(ctx)) goto err;
+
+	CMP_PKIMESSAGE_free(cr);
+	CMP_PKIMESSAGE_free(cp);
+	return ctx->newClCert;
+
+err:
+	if (cr) CMP_PKIMESSAGE_free(cr);
+	if (cp) CMP_PKIMESSAGE_free(cp);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_CTX_error_callback, (void*) ctx);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * do the full sequence for KUR, including KUR, KUP, certConf, PKIconf and
+ * potential polling
+ *
+ * All options need to be set in the context.
+ *
+ * NB: the ctx->newKey can be set *by the user* as the same as the current key 
+ * as per section 5.3.5:
+ * An update is a replacement
+ * certificate containing either a new subject public key or the current
+ * subject public key (although the latter practice may not be
+ * appropriate for some environments).
+ *
+ * TODO: another function to request two certificates at once should be created
+ *
+ * returns pointer to received certificate, NULL if non was received
+ * ############################################################################ */
+X509 *CMP_doKeyUpdateRequestSeq( CMP_CTX *ctx)
+	{
+	CMP_PKIMESSAGE *kur=NULL;
+	CMP_PKIMESSAGE *kup=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx ||  !ctx->newPkey ||
+			(!(ctx->referenceValue && ctx->secretValue) && /* MSG_MAC_ALG */
+			!(ctx->pkey && ctx->clCert && (ctx->srvCert || ctx->trusted_store)))) /* MSG_SIG_ALG */
+		{
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+		}
+
+	/* create Key Update Request - kur */
+	if (! (kur = CMP_kur_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Key Update Request");
+	if (! (CMP_PKIMESSAGE_http_perform(ctx, kur, &kup)))
+		{
+		ADD_HTTP_ERROR_INFO(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_KUP_NOT_RECEIVED, "kur");
+		goto err;
+		}
+
+	/* make sure the received messagetype indicates an KUP message */
+	if (CMP_PKIMESSAGE_get_bodytype( kup) != V_CMP_PKIBODY_KUP)
+		{
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data( kup, errmsg, sizeof(errmsg)));
+		goto err;
+		}
+
+	save_certrep_statusInfo(ctx, kup->body->value.kup);
+
+	/* validate message protection */
+	if (CMP_validate_msg(ctx, kup))
+		{
+		CMP_printf( ctx,	"SUCCESS: validating protection of incoming message");
+		} else {
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+		}
+
+	/* compare received nonce with the one sent in KUR */
+	if (kup->header->recipNonce)
+		{
+		if(ASN1_OCTET_STRING_cmp(kur->header->senderNonce, kup->header->recipNonce))
+			{
+			/* senderNonce != recipNonce (sic although there is no "!" in the if) */
+			CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_ERROR_NONCES_DO_NOT_MATCH);
+			goto err;
+			}
+		} /* it's not clear from the RFC whether recipNonce MUST be set or not */
+	CMP_CTX_set1_recipNonce(ctx, kup->header->senderNonce); /* store for setting in the next msg */
+
+	/* evaluate PKIStatus field */
+	if (CMP_CERTREPMESSAGE_PKIStatus_get( kup->body->value.kup, 0) == CMP_PKISTATUS_waiting)
+		{
+		if (!pollForResponse(ctx, kup->body->value.kup, &kup)) {
+			CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_KUP_NOT_RECEIVED);
+			ERR_add_error_data(1, "received 'waiting' pkistatus but polling failed");
+			goto err;
+			}
+		}
+
+	if (!(ctx->newClCert = CMP_CERTREPMESSAGE_get_certificate(ctx, kup->body->value.kup))) goto err;
+
+	/* copy received capubs to the context */
+	if (kup->body->value.kup->caPubs)
+		CMP_CTX_set1_caPubs(ctx, kup->body->value.kup->caPubs);
+
+	/* copy any received extraCerts to ctx->etraCertsIn so they can be retrieved */
+	if (kup->extraCerts)
+		CMP_CTX_set1_extraCertsIn(ctx, kup->extraCerts);
+
+	/* check if implicit confirm is set in generalInfo and send certConf if not */
+	if (!CMP_PKIMESSAGE_check_implicitConfirm(kup)) 
+		if (!sendCertConf(ctx)) goto err;
+
+	CMP_PKIMESSAGE_free(kur);
+	CMP_PKIMESSAGE_free(kup);
+	return ctx->newClCert;
+
+err:
+	if (kur) CMP_PKIMESSAGE_free(kur);
+	if (kup) CMP_PKIMESSAGE_free(kup);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_CTX_error_callback, (void*) ctx);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * Sends a general message to the server to request information specified in the
+ * InfoType and Value (itav) given in the nid (section 5.3.19 and E.5).
+ *
+ * all obtions besides the single ITAV and it's value to be sent need to be set
+ * in the context.
+ *
+ * TODO: this could take multiple nids to have several ITAVs in the Genm
+ *
+ * returns pointer to stack of ITAVs received in the answer or NULL on error
+ * ############################################################################ */
+STACK_OF(CMP_INFOTYPEANDVALUE) *CMP_doGeneralMessageSeq( CMP_CTX *ctx, int nid, char *value)
+	{
+	CMP_PKIMESSAGE *genm=NULL;
+	CMP_PKIMESSAGE *genp=NULL;
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+	STACK_OF(CMP_INFOTYPEANDVALUE) *rcvdItavs=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx || (!(ctx->referenceValue && ctx->secretValue) && /* MSG_MAC_ALG */
+			!(ctx->pkey && ctx->clCert && (ctx->srvCert || ctx->trusted_store)))) /* MSG_SIG_ALG */
+		{
+		CMPerr(CMP_F_CMP_DOGENERALMESSAGESEQ, CMP_R_INVALID_ARGS);
+		goto err;
+		}
+
+	/* crate GenMsgContent - genm*/
+	if (! (genm = CMP_genm_new(ctx))) goto err;
+
+	/* set itav - TODO: let this function take a STACK of ITAV as arguments */
+	itav = CMP_INFOTYPEANDVALUE_new();
+	itav->infoType = OBJ_nid2obj(nid);
+	itav->infoValue.ptr = value;
+	CMP_PKIMESSAGE_genm_item_push0( genm, itav);
+
+	CMP_printf( ctx, "INFO: Sending General Message");
+	if (! (CMP_PKIMESSAGE_http_perform(ctx, genm, &genp)))
+		{
+		ADD_HTTP_ERROR_INFO(CMP_F_CMP_DOGENERALMESSAGESEQ, CMP_R_GENP_NOT_RECEIVED, "genm");
+		goto err;
+		}
+
+	/* make sure the received messagetype indicates an GENP message */
+	if (CMP_PKIMESSAGE_get_bodytype(genp) != V_CMP_PKIBODY_GENP)
+		{
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOGENERALMESSAGESEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data( genp, errmsg, sizeof(errmsg)));
+		goto err;
+		}
+
+	/* validate message protection */
+	if (CMP_validate_msg(ctx, genp))
+		{
+		CMP_printf( ctx, "SUCCESS: validating protection of incoming message");
+		} else {
+		CMPerr(CMP_F_CMP_DOGENERALMESSAGESEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+		}
+
+	/* compare received nonce with the one sent in genm */
+	if (genp->header->recipNonce)
+		{
+		if(ASN1_OCTET_STRING_cmp(genm->header->senderNonce, genp->header->recipNonce))
+			{
+			CMPerr(CMP_F_CMP_DOGENERALMESSAGESEQ, CMP_R_ERROR_NONCES_DO_NOT_MATCH);
+			goto err;
+			}
+		} /* it's not clear from the RFC whether recipNonce MUST be set or not */
+	
+	/* the received stack of itavs shouldn't be freed with the message */
+	rcvdItavs = genp->body->value.genp;
+	genp->body->value.genp = NULL;
+
+	CMP_PKIMESSAGE_free(genm);
+	CMP_PKIMESSAGE_free(genp);
+
+	return rcvdItavs;
+
+err:
+	if (genm) CMP_PKIMESSAGE_free(genm);
+	if (genp) CMP_PKIMESSAGE_free(genp);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_CTX_error_callback, (void*) ctx);
+	return NULL;
+	}
+
diff -Naur crypto/cmp/cmp_vfy.c crypto-/cmp/cmp_vfy.c
--- cryptoold/cmp/cmp_vfy.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/cmp_vfy.c	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,486 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* crypto/cmp/cmp_vfy.c
+ * Functions to verify CMP (RFC 4210) messages for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#include <openssl/err.h>
+
+/* ############################################################################ *
+ * internal function
+ *
+ * validate a message protected by signature according to section 5.1.3.3
+ * (sha1+RSA/DSA or any other algorithm supported by OpenSSL)
+ * returns 0 on error
+ * ############################################################################ */
+static int CMP_verify_signature( CMP_PKIMESSAGE *msg, X509 *cert)
+	{
+	EVP_MD_CTX *ctx=NULL;
+	CMP_PROTECTEDPART protPart;
+	int ret=0;
+	EVP_MD *digest=NULL;
+	EVP_PKEY *pubkey=NULL;
+
+	size_t protPartDerLen=0;
+	unsigned char *protPartDer=NULL;
+
+	if (!msg || !cert) return 0;
+
+	pubkey = X509_get_pubkey((X509*) cert);
+	if (!pubkey) return 0;
+
+	/* create the DER representation of protected part */
+	protPart.header = msg->header;
+	protPart.body	= msg->body;
+	protPartDerLen	= i2d_CMP_PROTECTEDPART(&protPart, &protPartDer);
+
+	/* verify prtotection of protected part */
+	ctx = EVP_MD_CTX_create();
+	if(!(digest = (EVP_MD *)EVP_get_digestbynid(OBJ_obj2nid(msg->header->protectionAlg->algorithm)))) goto notsup;
+	EVP_VerifyInit_ex(ctx, digest, NULL);
+	EVP_VerifyUpdate(ctx, protPartDer, protPartDerLen);
+	ret = EVP_VerifyFinal(ctx, msg->protection->data, msg->protection->length, pubkey);
+
+	/* cleanup */
+	EVP_MD_CTX_destroy(ctx);
+	OPENSSL_free(protPartDer);
+	EVP_PKEY_free(pubkey);
+	return ret;
+notsup:
+	CMPerr(CMP_F_CMP_VERIFY_SIGNATURE, CMP_R_ALGORITHM_NOT_SUPPORTED);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * Validates a message protected with PBMAC
+ * ############################################################################ */
+#define M_ASN1_BIT_STRING_cmp(a,b) ASN1_STRING_cmp(\
+		(const ASN1_STRING *)a,(const ASN1_STRING *)b)
+static int CMP_verify_MAC( CMP_PKIMESSAGE *msg, const ASN1_OCTET_STRING *secret)
+	{
+	ASN1_BIT_STRING *protection=NULL;
+	int valid = 0;
+
+	/* generate expected protection for the message */
+	if (!(protection = CMP_calc_protection_pbmac( msg, secret)))
+		goto err; /* failed to generate protection string! */
+
+	valid = M_ASN1_BIT_STRING_cmp( protection, msg->protection) == 0;
+	ASN1_BIT_STRING_free(protection);
+	return valid;
+err:
+	return 0;
+	}
+
+/* ############################################################################ *
+ * internal function
+ *
+ * Attempt to validate certificate path. returns 1 if the path was
+ * validated successfully and 0 if not.
+ * ############################################################################ */
+int CMP_validate_cert_path(X509_STORE *trusted_store, X509_STORE *untrusted_store, X509 *cert)
+	{
+	int ret=0,valid=0;
+	X509_STORE_CTX *csc=NULL;
+	STACK_OF(X509) *untrusted_stack=NULL;
+
+	if (!cert) goto end;
+
+	if (!trusted_store)
+		{
+		CMPerr(CMP_F_CMP_VALIDATE_CERT_PATH, CMP_R_NO_TRUSTED_CERTIFICATES_SET);
+		goto end;
+		}
+
+	/* A cert callback could be used to do additional checking, policies for example.*/
+	/* X509_STORE_set_verify_cb(trusted_store, CMP_cert_callback); */
+
+	if (!(csc = X509_STORE_CTX_new())) goto end;
+
+	/* note: there doesn't seem to be a good way to get a stack of all
+	 * the certs in an X509_STORE, so we need to try and find the chain
+	 * of intermediate certs here. */
+	if (untrusted_store)
+		untrusted_stack = CMP_build_cert_chain(untrusted_store, cert);
+
+	X509_STORE_set_flags(trusted_store, 0);
+	if(!X509_STORE_CTX_init(csc, trusted_store, cert, untrusted_stack))
+		goto end;
+
+	/* CRLs could be handled here */
+	/* if (crls) X509_STORE_CTX_set0_crls(csc, crls); */
+
+	valid=X509_verify_cert(csc);
+
+	X509_STORE_CTX_free(csc);
+
+	ret=0;
+
+	end:
+	if (untrusted_stack)
+		sk_X509_pop_free(untrusted_stack, X509_free);
+
+	if (valid > 0)
+		{
+		ret = 1;
+		}
+
+	return(ret);
+	}
+
+#if 0
+/* ############################################################################ *
+ * NOTE: This is only needed if/when we want to do additional checking on the certificates!
+ *		 It is not currently used.
+ *
+ * This is called for every valid certificate. Here we could add additional checks,
+ * for policies for example.
+ * ############################################################################ */
+int CMP_cert_callback(int ok, X509_STORE_CTX *ctx)
+	{
+	int cert_error = X509_STORE_CTX_get_error(ctx);
+	X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);
+
+	if (!ok)
+		{
+		switch(cert_error)
+			{
+			case X509_V_ERR_NO_EXPLICIT_POLICY:
+				/* policies_print(NULL, ctx); */
+			case X509_V_ERR_CERT_HAS_EXPIRED:
+
+				/* since we are just checking the certificates, it is
+				 * ok if they are self signed. But we should still warn
+				 * the user.
+				 */
+
+			case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+				/* Continue after extension errors too */
+			case X509_V_ERR_INVALID_CA:
+			case X509_V_ERR_INVALID_NON_CA:
+			case X509_V_ERR_PATH_LENGTH_EXCEEDED:
+			case X509_V_ERR_INVALID_PURPOSE:
+			case X509_V_ERR_CRL_HAS_EXPIRED:
+			case X509_V_ERR_CRL_NOT_YET_VALID:
+			case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
+				ok = 1;
+
+			}
+
+		return ok;
+		}
+
+#if 0
+	/* TODO: we could check policies here too */
+	if (cert_error == X509_V_OK && ok == 2)
+		policies_print(NULL, ctx);
+#endif
+
+	return(ok);
+	}
+#endif
+
+
+/* ############################################################################ *
+ * internal function
+ *
+ * Find server certificate by:
+ * - first see if we can find it in trusted store
+ * - then try to find it in untrusted store
+ * - then search for certs with matching name in extraCerts
+ *	 - if only one match found, return that
+ *	 - if more than one, try to find a cert with the matching senderKID if available
+ *	 - if keyID is not available, return first cert found
+ * returns pointer to found server Certificate on success
+ * returns NULL on error or when no certificate could be found
+ * ############################################################################ */
+static X509 *findSrvCert(CMP_CTX *ctx, CMP_PKIMESSAGE *msg)
+	{
+	X509 *srvCert = NULL;
+	X509_STORE_CTX *csc = NULL;
+	X509_OBJECT obj;
+	STACK_OF(X509) *found_certs = NULL;
+	int n;
+
+	if(!(csc = X509_STORE_CTX_new())) return NULL;
+
+	/* first attempt lookup in trusted_store */
+	if (X509_STORE_CTX_init(csc, ctx->trusted_store, NULL, NULL))
+		{
+		if (X509_STORE_get_by_subject(csc, X509_LU_X509, msg->header->sender->d.directoryName, &obj))
+			{
+			srvCert = obj.data.x509;
+			X509_STORE_CTX_free(csc);
+			return srvCert;
+			}
+		}
+
+	/* attempt lookup in untrusted_store */
+	if (X509_STORE_CTX_init(csc, ctx->untrusted_store, NULL, NULL))
+		{
+		if (X509_STORE_get_by_subject(csc, X509_LU_X509, msg->header->sender->d.directoryName, &obj))
+			{
+			srvCert = obj.data.x509;
+			X509_STORE_CTX_free(csc);
+			return srvCert;
+			}
+		}
+
+	/* not found in trusted_store, so look through extraCerts */
+	if(!(found_certs = sk_X509_new_null())) return NULL;
+
+	for (n = 0; n < sk_X509_num(msg->extraCerts); n++)
+		{
+		X509 *cert = sk_X509_value(msg->extraCerts, n);
+		X509_NAME *name = NULL;
+		if (!cert) continue;
+		name = X509_get_subject_name(cert);
+
+		if (name && !X509_NAME_cmp(name, msg->header->sender->d.directoryName))
+			sk_X509_push(found_certs, cert);
+		}
+
+	/* if found exactly one cert, we'll use that */
+	if (sk_X509_num(found_certs) == 1)
+		srvCert = sk_X509_pop(found_certs);
+
+	/* found more than one with a matching name, so try to search
+	   through the found certs by key ID if we have it.  if not,
+	   just return first one. */
+	else if (sk_X509_num(found_certs) > 1)
+		{
+		if (msg->header->senderKID) {
+			for (n = 0; n < sk_X509_num(found_certs); n++)
+				{
+				X509 *cert = sk_X509_value(found_certs, n);
+				ASN1_OCTET_STRING *cert_keyid = NULL;
+
+				if (!(cert_keyid = CMP_get_cert_subject_key_id(cert))) return NULL;
+
+				if (!ASN1_OCTET_STRING_cmp(cert_keyid, msg->header->senderKID))
+					{
+					srvCert = cert;
+					break;
+					}
+				}
+			}
+
+		if (!srvCert)
+			{
+			/* key id not available or we didn't find a cert with matching keyID.
+			 * -> return the first one with matching name */
+			srvCert = sk_X509_pop(found_certs);
+			}
+		}
+
+	sk_X509_free(found_certs);
+
+	return srvCert;
+	}
+
+
+/* ############################################################################ *
+ * internal function
+ *
+ * Creates a new certificate store and adds all the self-signed certificates from
+ * the given stack to the store.
+ * ############################################################################ */
+static X509_STORE *createTempTrustedStore(STACK_OF(X509) *stack)
+	{
+	X509_STORE *store = X509_STORE_new();
+	int i;
+
+	if (!store) goto err;
+
+	for (i = 0; i < sk_X509_num(stack); i++)
+		{
+		X509 *cert = sk_X509_value(stack, i);
+		EVP_PKEY *pubkey = X509_get_pubkey(cert);
+
+		if (pubkey && X509_verify(cert, pubkey))
+			X509_STORE_add_cert(store, cert);
+
+		EVP_PKEY_free(pubkey);
+		}
+
+	return store;
+
+	err:
+	return NULL;
+	}
+
+/* ############################################################################
+ * Validates the protection of the given PKIMessage using either password
+ * based mac or a signature algorithm. In the case of signature algorithm, the
+ * certificate can be provided in ctx->srvCert or it is taken from
+ * extraCerts and validate against ctx->trusted_store utilizing
+ * ctx->untrusted_store and extraCerts.
+ *
+ * If ctx->permitTAInExtraCertsForIR is true, the trust anchor may be taken from
+ * the extraCerts field when a self-signed certificate is found there which can
+ * be used to validate the issued certificate returned in IP.  This is according
+ * to the need given in 3GPP TS 33.310.
+ *
+ * returns 1 on success, 0 on error or validation failed
+ * ############################################################################ */
+int CMP_validate_msg(CMP_CTX *ctx, CMP_PKIMESSAGE *msg)
+	{
+	X509 *srvCert = ctx->srvCert;
+	int srvCert_valid = 0;
+	int nid = 0;
+	ASN1_OBJECT *algorOID=NULL;
+
+	if (!msg->header->protectionAlg)
+		/* unprotected message */
+		return 0;
+
+	/* determine the nid for the used protection algorithm */
+	X509_ALGOR_get0( &algorOID, NULL, NULL, msg->header->protectionAlg);
+	nid = OBJ_obj2nid(algorOID);
+
+	switch (nid)
+		{
+		/* 5.1.3.1.  Shared Secret Information */
+		case NID_id_PasswordBasedMAC:
+			return CMP_verify_MAC(msg, ctx->secretValue);
+
+			/* TODO: 5.1.3.2.  DH Key Pairs */
+		case NID_id_DHBasedMac:
+			CMPerr(CMP_F_CMP_VALIDATE_MSG, CMP_R_UNSUPPORTED_PROTECTION_ALG_DHBASEDMAC);
+			break;
+
+			/* 5.1.3.3.  Signature */
+			/* TODO: should that better whitelist DSA/RSA etc.? -> check all possible options from OpenSSL, should there be a makro? */
+		default:
+			if (!srvCert) {
+				/* if we've already found and validated a server cert, and it matches the sender name,
+				 * we will use that, this is used for PKIconf where the server
+				 * certificate and others could be missing from the extraCerts */
+				if (ctx->validatedSrvCert &&
+					!X509_NAME_cmp(X509_get_subject_name(ctx->validatedSrvCert), msg->header->sender->d.directoryName))
+					{
+					srvCert = ctx->validatedSrvCert;
+					srvCert_valid = 1;
+					}
+				else
+					{
+					/* load the provided extraCerts to help with cert path validation */
+					CMP_CTX_loadUntrustedStack(ctx, msg->extraCerts);
+
+					/* try to find the server certificate from 1) trusted_store 2) untrusted_store 3) extaCerts*/
+					srvCert = findSrvCert(ctx, msg);
+
+					/* validate the that the found server Certificate is trusted */
+					srvCert_valid = CMP_validate_cert_path(ctx->trusted_store, ctx->untrusted_store, srvCert);
+
+					/* do an exceptional handling for 3GPP */
+					if (!srvCert_valid)
+						{
+						/* For IP: when the ctxOption is set, extract the Trust Anchor from
+						 * ExtraCerts, provided that there is a self-signed certificate
+						 * which can be used to validate the issued certificate - refer to 3GPP TS 33.310 */
+
+						if (ctx->permitTAInExtraCertsForIR && CMP_PKIMESSAGE_get_bodytype(msg) == V_CMP_PKIBODY_IP)
+							{
+							X509_STORE *tempStore = createTempTrustedStore(msg->extraCerts);
+							/* TODO: check that issued certificates can validate against
+							 * trust achnor - and then exclusively use this CA */
+							srvCert_valid = CMP_validate_cert_path(tempStore, ctx->untrusted_store, srvCert);
+
+							if (srvCert_valid)
+								{
+								/* verify that our received certificate can also be validated with the same
+								 * trusted store as srvCert */
+								X509 *newClCert = CMP_CERTREPMESSAGE_get_certificate(ctx, msg->body->value.ip);
+								if (newClCert)
+									srvCert_valid = CMP_validate_cert_path(tempStore, ctx->untrusted_store, newClCert);
+								}
+
+							X509_STORE_free(tempStore);
+							}
+						}
+					}
+
+				/* verification failed if no valid server cert was found */
+				if (!srvCert_valid)
+					{
+					CMPerr(CMP_F_CMP_VALIDATE_MSG, CMP_R_NO_VALID_SRVCERT_FOUND);
+					return 0;
+					}
+
+				/* store trusted server cert for future messages in this interaction */
+				ctx->validatedSrvCert = srvCert;
+				}
+			return CMP_verify_signature(msg, srvCert);
+		}
+	return 0;
+	}
+
diff -Naur crypto/cmp/e_os.h crypto-/cmp/e_os.h
--- cryptoold/cmp/e_os.h	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/e_os.h	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,741 @@
+/* e_os.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_E_OS_H
+#define HEADER_E_OS_H
+
+#include <openssl/opensslconf.h>
+
+#include "e_os2.h"
+/* <openssl/e_os2.h> contains what we can justify to make visible
+ * to the outside; this file e_os.h is not part of the exported
+ * interface. */
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* Used to checking reference counts, most while doing perl5 stuff :-) */
+#ifdef REF_PRINT
+#undef REF_PRINT
+#define REF_PRINT(a,b)	fprintf(stderr,"%08X:%4d:%s\n",(int)b,b->references,a)
+#endif
+
+#ifndef DEVRANDOM
+/* set this to a comma-separated list of 'random' device files to try out.
+ * My default, we will try to read at least one of these files */
+#define DEVRANDOM "/dev/urandom","/dev/random","/dev/srandom"
+#endif
+#ifndef DEVRANDOM_EGD
+/* set this to a comma-seperated list of 'egd' sockets to try out. These
+ * sockets will be tried in the order listed in case accessing the device files
+ * listed in DEVRANDOM did not return enough entropy. */
+#define DEVRANDOM_EGD "/var/run/egd-pool","/dev/egd-pool","/etc/egd-pool","/etc/entropy"
+#endif
+
+#if defined(OPENSSL_SYS_VXWORKS)
+#  define NO_SYS_PARAM_H
+#  define NO_CHMOD
+#  define NO_SYSLOG
+#endif
+  
+#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC)
+# if macintosh==1
+#  ifndef MAC_OS_GUSI_SOURCE
+#    define MAC_OS_pre_X
+#    define NO_SYS_TYPES_H
+#  endif
+#  define NO_SYS_PARAM_H
+#  define NO_CHMOD
+#  define NO_SYSLOG
+#  undef  DEVRANDOM
+#  define GETPID_IS_MEANINGLESS
+# endif
+#endif
+
+/********************************************************************
+ The Microsoft section
+ ********************************************************************/
+/* The following is used because of the small stack in some
+ * Microsoft operating systems */
+#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYSNAME_WIN32)
+#  define MS_STATIC	static
+#else
+#  define MS_STATIC
+#endif
+
+#if defined(OPENSSL_SYS_WIN32) && !defined(WIN32)
+#  define WIN32
+#endif
+#if defined(OPENSSL_SYS_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(OPENSSL_SYS_MSDOS) && !defined(MSDOS)
+#  define MSDOS
+#endif
+
+#if defined(MSDOS) && !defined(GETPID_IS_MEANINGLESS)
+#  define GETPID_IS_MEANINGLESS
+#endif
+
+#ifdef WIN32
+#define get_last_sys_error()	GetLastError()
+#define clear_sys_error()	SetLastError(0)
+#if !defined(WINNT)
+#define WIN_CONSOLE_BUG
+#endif
+#else
+#define get_last_sys_error()	errno
+#define clear_sys_error()	errno=0
+#endif
+
+#if defined(WINDOWS)
+#define get_last_socket_error()	WSAGetLastError()
+#define clear_socket_error()	WSASetLastError(0)
+#define readsocket(s,b,n)	recv((s),(b),(n),0)
+#define writesocket(s,b,n)	send((s),(b),(n),0)
+#elif defined(__DJGPP__)
+#define WATT32
+#define get_last_socket_error()	errno
+#define clear_socket_error()	errno=0
+#define closesocket(s)		close_s(s)
+#define readsocket(s,b,n)	read_s(s,b,n)
+#define writesocket(s,b,n)	send(s,b,n,0)
+#elif defined(MAC_OS_pre_X)
+#define get_last_socket_error()	errno
+#define clear_socket_error()	errno=0
+#define closesocket(s)		MacSocket_close(s)
+#define readsocket(s,b,n)	MacSocket_recv((s),(b),(n),true)
+#define writesocket(s,b,n)	MacSocket_send((s),(b),(n))
+#elif defined(OPENSSL_SYS_VMS)
+#define get_last_socket_error() errno
+#define clear_socket_error()    errno=0
+#define ioctlsocket(a,b,c)      ioctl(a,b,c)
+#define closesocket(s)          close(s)
+#define readsocket(s,b,n)       recv((s),(b),(n),0)
+#define writesocket(s,b,n)      send((s),(b),(n),0)
+#elif defined(OPENSSL_SYS_VXWORKS)
+#define get_last_socket_error()	errno
+#define clear_socket_error()	errno=0
+#define ioctlsocket(a,b,c)	    ioctl((a),(b),(int)(c))
+#define closesocket(s)		    close(s)
+#define readsocket(s,b,n)	    read((s),(b),(n))
+#define writesocket(s,b,n)	    write((s),(char *)(b),(n))
+#elif defined(OPENSSL_SYS_BEOS_R5)
+#define get_last_socket_error() errno
+#define clear_socket_error()    errno=0
+#define FIONBIO SO_NONBLOCK
+#define ioctlsocket(a,b,c)		  setsockopt((a),SOL_SOCKET,(b),(c),sizeof(*(c)))
+#define readsocket(s,b,n)       recv((s),(b),(n),0)
+#define writesocket(s,b,n)      send((s),(b),(n),0)
+#elif defined(OPENSSL_SYS_NETWARE)
+#if defined(NETWARE_BSDSOCK)
+#define get_last_socket_error() errno
+#define clear_socket_error()    errno=0
+#define closesocket(s)          close(s)
+#define ioctlsocket(a,b,c)      ioctl(a,b,c)
+#if defined(NETWARE_LIBC)
+#define readsocket(s,b,n)       recv((s),(b),(n),0)
+#define writesocket(s,b,n)      send((s),(b),(n),0)
+#else
+#define readsocket(s,b,n)       recv((s),(char*)(b),(n),0)
+#define writesocket(s,b,n)      send((s),(char*)(b),(n),0)
+#endif
+#else
+#define get_last_socket_error()	WSAGetLastError()
+#define clear_socket_error()	WSASetLastError(0)
+#define readsocket(s,b,n)		recv((s),(b),(n),0)
+#define writesocket(s,b,n)		send((s),(b),(n),0)
+#endif
+#else
+#define get_last_socket_error()	errno
+#define clear_socket_error()	errno=0
+#define ioctlsocket(a,b,c)	ioctl(a,b,c)
+#define closesocket(s)		close(s)
+#define readsocket(s,b,n)	read((s),(b),(n))
+#define writesocket(s,b,n)	write((s),(b),(n))
+#endif
+
+#ifdef WIN16 /* never the case */
+#  define MS_CALLBACK	_far _loadds
+#  define MS_FAR	_far
+#else
+#  define MS_CALLBACK
+#  define MS_FAR
+#endif
+
+#ifdef OPENSSL_NO_STDIO
+#  undef OPENSSL_NO_FP_API
+#  define OPENSSL_NO_FP_API
+#endif
+
+#if (defined(WINDOWS) || defined(MSDOS))
+
+#  ifdef __DJGPP__
+#    include <unistd.h>
+#    include <sys/stat.h>
+#    include <sys/socket.h>
+#    include <tcp.h>
+#    include <netdb.h>
+#    define _setmode setmode
+#    define _O_TEXT O_TEXT
+#    define _O_BINARY O_BINARY
+#    undef DEVRANDOM
+#    define DEVRANDOM "/dev/urandom\x24"
+#  endif /* __DJGPP__ */
+
+#  ifndef S_IFDIR
+#    define S_IFDIR	_S_IFDIR
+#  endif
+
+#  ifndef S_IFMT
+#    define S_IFMT	_S_IFMT
+#  endif
+
+#  if !defined(WINNT) && !defined(__DJGPP__)
+#    define NO_SYSLOG
+#  endif
+#  define NO_DIRENT
+
+#  ifdef WINDOWS
+#    if !defined(_WIN32_WCE) && !defined(_WIN32_WINNT)
+       /*
+	* Defining _WIN32_WINNT here in e_os.h implies certain "discipline."
+	* Most notably we ought to check for availability of each specific
+	* routine with GetProcAddress() and/or guard NT-specific calls with
+	* GetVersion() < 0x80000000. One can argue that in latter "or" case
+	* we ought to /DELAYLOAD some .DLLs in order to protect ourselves
+	* against run-time link errors. This doesn't seem to be necessary,
+	* because it turned out that already Windows 95, first non-NT Win32
+	* implementation, is equipped with at least NT 3.51 stubs, dummy
+	* routines with same name, but which do nothing. Meaning that it's
+	* apparently sufficient to guard "vanilla" NT calls with GetVersion
+	* alone, while NT 4.0 and above interfaces ought to be linked with
+	* GetProcAddress at run-time.
+	*/
+#      define _WIN32_WINNT 0x0400
+#    endif
+#    if !defined(OPENSSL_NO_SOCK) && defined(_WIN32_WINNT)
+       /*
+        * Just like defining _WIN32_WINNT including winsock2.h implies
+        * certain "discipline" for maintaining [broad] binary compatibility.
+        * As long as structures are invariant among Winsock versions,
+        * it's sufficient to check for specific Winsock2 API availability
+        * at run-time [DSO_global_lookup is recommended]...
+        */
+#      include <winsock2.h>
+#      include <ws2tcpip.h>
+       /* yes, they have to be #included prior to <windows.h> */
+#    endif
+#    include <windows.h>
+#    include <stdio.h>
+#    include <stddef.h>
+#    include <errno.h>
+#    include <string.h>
+#    ifdef _WIN64
+#      define strlen(s) _strlen31(s)
+/* cut strings to 2GB */
+static unsigned int _strlen31(const char *str)
+	{
+	unsigned int len=0;
+	while (*str && len<0x80000000U) str++, len++;
+	return len&0x7FFFFFFF;
+	}
+#    endif
+#    include <malloc.h>
+#    if defined(_MSC_VER) && _MSC_VER<=1200 && defined(_MT) && defined(isspace)
+       /* compensate for bug in VC6 ctype.h */
+#      undef isspace
+#      undef isdigit
+#      undef isalnum
+#      undef isupper
+#      undef isxdigit
+#    endif
+#    if defined(_MSC_VER) && !defined(_DLL) && defined(stdin)
+#      if _MSC_VER>=1300
+#        undef stdin
+#        undef stdout
+#        undef stderr
+         FILE *__iob_func();
+#        define stdin  (&__iob_func()[0])
+#        define stdout (&__iob_func()[1])
+#        define stderr (&__iob_func()[2])
+#      elif defined(I_CAN_LIVE_WITH_LNK4049)
+#        undef stdin
+#        undef stdout
+#        undef stderr
+         /* pre-1300 has __p__iob(), but it's available only in msvcrt.lib,
+          * or in other words with /MD. Declaring implicit import, i.e.
+          * with _imp_ prefix, works correctly with all compiler options,
+	  * but without /MD results in LINK warning LNK4049:
+	  * 'locally defined symbol "__iob" imported'.
+          */
+         extern FILE *_imp___iob;
+#        define stdin  (&_imp___iob[0])
+#        define stdout (&_imp___iob[1])
+#        define stderr (&_imp___iob[2])
+#      endif
+#    endif
+#  endif
+#  include <io.h>
+#  include <fcntl.h>
+
+#  ifdef OPENSSL_SYS_WINCE
+#    define OPENSSL_NO_POSIX_IO
+#  endif
+
+#  if defined (__BORLANDC__)
+#    define _setmode setmode
+#    define _O_TEXT O_TEXT
+#    define _O_BINARY O_BINARY
+#    define _int64 __int64
+#    define _kbhit kbhit
+#  endif
+
+#  define EXIT(n) exit(n)
+#  define LIST_SEPARATOR_CHAR ';'
+#  ifndef X_OK
+#    define X_OK	0
+#  endif
+#  ifndef W_OK
+#    define W_OK	2
+#  endif
+#  ifndef R_OK
+#    define R_OK	4
+#  endif
+#  define OPENSSL_CONF	"openssl.cnf"
+#  define SSLEAY_CONF	OPENSSL_CONF
+#  define NUL_DEV	"nul"
+#  define RFILE		".rnd"
+#  ifdef OPENSSL_SYS_WINCE
+#    define DEFAULT_HOME  ""
+#  else
+#    define DEFAULT_HOME  "C:"
+#  endif
+
+/* Avoid Windows 8 SDK GetVersion deprecated problems */
+#if defined(_MSC_VER) && _MSC_VER>=1800
+#  define check_winnt() (1)
+#else
+#  define check_winnt() (GetVersion() < 0x80000000)
+#endif 
+
+#else /* The non-microsoft world */
+
+#  ifdef OPENSSL_SYS_VMS
+#    define VMS 1
+  /* some programs don't include stdlib, so exit() and others give implicit 
+     function warnings */
+#    include <stdlib.h>
+#    if defined(__DECC)
+#      include <unistd.h>
+#    else
+#      include <unixlib.h>
+#    endif
+#    define OPENSSL_CONF	"openssl.cnf"
+#    define SSLEAY_CONF		OPENSSL_CONF
+#    define RFILE		".rnd"
+#    define LIST_SEPARATOR_CHAR ','
+#    define NUL_DEV		"NLA0:"
+  /* We don't have any well-defined random devices on VMS, yet... */
+#    undef DEVRANDOM
+  /* We need to do this since VMS has the following coding on status codes:
+
+     Bits 0-2: status type: 0 = warning, 1 = success, 2 = error, 3 = info ...
+               The important thing to know is that odd numbers are considered
+	       good, while even ones are considered errors.
+     Bits 3-15: actual status number
+     Bits 16-27: facility number.  0 is considered "unknown"
+     Bits 28-31: control bits.  If bit 28 is set, the shell won't try to
+                 output the message (which, for random codes, just looks ugly)
+
+     So, what we do here is to change 0 to 1 to get the default success status,
+     and everything else is shifted up to fit into the status number field, and
+     the status is tagged as an error, which I believe is what is wanted here.
+     -- Richard Levitte
+  */
+#    define EXIT(n)		do { int __VMS_EXIT = n; \
+                                     if (__VMS_EXIT == 0) \
+				       __VMS_EXIT = 1; \
+				     else \
+				       __VMS_EXIT = (n << 3) | 2; \
+                                     __VMS_EXIT |= 0x10000000; \
+				     exit(__VMS_EXIT); } while(0)
+#    define NO_SYS_PARAM_H
+
+#  elif defined(OPENSSL_SYS_NETWARE)
+#    include <fcntl.h>
+#    include <unistd.h>
+#    define NO_SYS_TYPES_H
+#    undef  DEVRANDOM
+#    ifdef NETWARE_CLIB
+#      define getpid GetThreadID
+       extern int GetThreadID(void);
+/* #      include <conio.h> */
+       extern int kbhit(void);
+#    else
+#      include <screen.h>
+#    endif
+#    define NO_SYSLOG
+#    define _setmode setmode
+#    define _kbhit kbhit
+#    define _O_TEXT O_TEXT
+#    define _O_BINARY O_BINARY
+#    define OPENSSL_CONF   "openssl.cnf"
+#    define SSLEAY_CONF    OPENSSL_CONF
+#    define RFILE    ".rnd"
+#    define LIST_SEPARATOR_CHAR ';'
+#    define EXIT(n)  { if (n) printf("ERROR: %d\n", (int)n); exit(n); }
+
+#  else
+     /* !defined VMS */
+#    ifdef OPENSSL_SYS_MPE
+#      define NO_SYS_PARAM_H
+#    endif
+#    ifdef OPENSSL_UNISTD
+#      include OPENSSL_UNISTD
+#    else
+#      include <unistd.h>
+#    endif
+#    ifndef NO_SYS_TYPES_H
+#      include <sys/types.h>
+#    endif
+#    if defined(NeXT) || defined(OPENSSL_SYS_NEWS4)
+#      define pid_t int /* pid_t is missing on NEXTSTEP/OPENSTEP
+                         * (unless when compiling with -D_POSIX_SOURCE,
+                         * which doesn't work for us) */
+#    endif
+#    ifdef OPENSSL_SYS_NEWS4 /* setvbuf is missing on mips-sony-bsd */
+#      define setvbuf(a, b, c, d) setbuffer((a), (b), (d))
+       typedef unsigned long clock_t;
+#    endif
+#    ifdef OPENSSL_SYS_WIN32_CYGWIN
+#      include <io.h>
+#      include <fcntl.h>
+#    endif
+
+#    define OPENSSL_CONF	"openssl.cnf"
+#    define SSLEAY_CONF		OPENSSL_CONF
+#    define RFILE		".rnd"
+#    define LIST_SEPARATOR_CHAR ':'
+#    define NUL_DEV		"/dev/null"
+#    define EXIT(n)		exit(n)
+#  endif
+
+#  define SSLeay_getpid()	getpid()
+
+#endif
+
+
+/*************/
+
+#ifdef USE_SOCKETS
+#  if defined(WINDOWS) || defined(MSDOS)
+      /* windows world */
+
+#    ifdef OPENSSL_NO_SOCK
+#      define SSLeay_Write(a,b,c)	(-1)
+#      define SSLeay_Read(a,b,c)	(-1)
+#      define SHUTDOWN(fd)		close(fd)
+#      define SHUTDOWN2(fd)		close(fd)
+#    elif !defined(__DJGPP__)
+#      if defined(_WIN32_WCE) && _WIN32_WCE<410
+#        define getservbyname _masked_declaration_getservbyname
+#      endif
+#      if !defined(IPPROTO_IP)
+         /* winsock[2].h was included already? */
+#        include <winsock.h>
+#      endif
+#      ifdef getservbyname
+#        undef getservbyname
+         /* this is used to be wcecompat/include/winsock_extras.h */
+         struct servent* PASCAL getservbyname(const char*,const char*);
+#      endif
+
+#      ifdef _WIN64
+/*
+ * Even though sizeof(SOCKET) is 8, it's safe to cast it to int, because
+ * the value constitutes an index in per-process table of limited size
+ * and not a real pointer.
+ */
+#        define socket(d,t,p)	((int)socket(d,t,p))
+#        define accept(s,f,l)	((int)accept(s,f,l))
+#      endif
+#      define SSLeay_Write(a,b,c)	send((a),(b),(c),0)
+#      define SSLeay_Read(a,b,c)	recv((a),(b),(c),0)
+#      define SHUTDOWN(fd)		{ shutdown((fd),0); closesocket(fd); }
+#      define SHUTDOWN2(fd)		{ shutdown((fd),2); closesocket(fd); }
+#    else
+#      define SSLeay_Write(a,b,c)	write_s(a,b,c,0)
+#      define SSLeay_Read(a,b,c)	read_s(a,b,c)
+#      define SHUTDOWN(fd)		close_s(fd)
+#      define SHUTDOWN2(fd)		close_s(fd)
+#    endif
+
+#  elif defined(MAC_OS_pre_X)
+
+#    include "MacSocket.h"
+#    define SSLeay_Write(a,b,c)		MacSocket_send((a),(b),(c))
+#    define SSLeay_Read(a,b,c)		MacSocket_recv((a),(b),(c),true)
+#    define SHUTDOWN(fd)		MacSocket_close(fd)
+#    define SHUTDOWN2(fd)		MacSocket_close(fd)
+
+#  elif defined(OPENSSL_SYS_NETWARE)
+         /* NetWare uses the WinSock2 interfaces by default, but can be configured for BSD
+         */
+#      if defined(NETWARE_BSDSOCK)
+#        include <sys/socket.h>
+#        include <netinet/in.h>
+#        include <sys/time.h>
+#        if defined(NETWARE_CLIB)
+#          include <sys/bsdskt.h>
+#        else
+#          include <sys/select.h>
+#        endif
+#        define INVALID_SOCKET (int)(~0)
+#      else
+#        include <novsock2.h>
+#      endif
+#      define SSLeay_Write(a,b,c)   send((a),(b),(c),0)
+#      define SSLeay_Read(a,b,c) recv((a),(b),(c),0)
+#      define SHUTDOWN(fd)    { shutdown((fd),0); closesocket(fd); }
+#      define SHUTDOWN2(fd)      { shutdown((fd),2); closesocket(fd); }
+
+#  else
+
+#    ifndef NO_SYS_PARAM_H
+#      include <sys/param.h>
+#    endif
+#    ifdef OPENSSL_SYS_VXWORKS
+#      include <time.h> 
+#    elif !defined(OPENSSL_SYS_MPE)
+#      include <sys/time.h> /* Needed under linux for FD_XXX */
+#    endif
+
+#    include <netdb.h>
+#    if defined(OPENSSL_SYS_VMS_NODECC)
+#      include <socket.h>
+#      include <in.h>
+#      include <inet.h>
+#    else
+#      include <sys/socket.h>
+#      ifdef FILIO_H
+#        include <sys/filio.h> /* Added for FIONBIO under unixware */
+#      endif
+#      include <netinet/in.h>
+#      if !defined(OPENSSL_SYS_BEOS_R5)
+#      include <arpa/inet.h>
+#    endif
+#    endif
+
+#    if defined(NeXT) || defined(_NEXT_SOURCE)
+#      include <sys/fcntl.h>
+#      include <sys/types.h>
+#    endif
+
+#    ifdef OPENSSL_SYS_AIX
+#      include <sys/select.h>
+#    endif
+
+#    ifdef __QNX__
+#      include <sys/select.h>
+#    endif
+
+#    if defined(sun)
+#      include <sys/filio.h>
+#    else
+#      ifndef VMS
+#        include <sys/ioctl.h>
+#      else
+	 /* ioctl is only in VMS > 7.0 and when socketshr is not used */
+#        if !defined(TCPIP_TYPE_SOCKETSHR) && defined(__VMS_VER) && (__VMS_VER > 70000000)
+#          include <sys/ioctl.h>
+#        endif
+#      endif
+#    endif
+
+#    ifdef VMS
+#      include <unixio.h>
+#      if defined(TCPIP_TYPE_SOCKETSHR)
+#        include <socketshr.h>
+#      endif
+#    endif
+
+#    define SSLeay_Read(a,b,c)     read((a),(b),(c))
+#    define SSLeay_Write(a,b,c)    write((a),(b),(c))
+#    define SHUTDOWN(fd)    { shutdown((fd),0); closesocket((fd)); }
+#    define SHUTDOWN2(fd)   { shutdown((fd),2); closesocket((fd)); }
+#    ifndef INVALID_SOCKET
+#    define INVALID_SOCKET	(-1)
+#    endif /* INVALID_SOCKET */
+#  endif
+
+/* Some IPv6 implementations are broken, disable them in known bad
+ * versions.
+ */
+#  if !defined(OPENSSL_USE_IPV6)
+#    if defined(AF_INET6) && !defined(OPENSSL_SYS_BEOS_BONE) && !defined(NETWARE_CLIB)
+#      define OPENSSL_USE_IPV6 1
+#    else
+#      define OPENSSL_USE_IPV6 0
+#    endif
+#  endif
+
+#endif
+
+#if defined(sun) && !defined(__svr4__) && !defined(__SVR4)
+  /* include headers first, so our defines don't break it */
+#include <stdlib.h>
+#include <string.h>
+  /* bcopy can handle overlapping moves according to SunOS 4.1.4 manpage */
+# define memmove(s1,s2,n) bcopy((s2),(s1),(n))
+# define strtoul(s,e,b) ((unsigned long int)strtol((s),(e),(b)))
+extern char *sys_errlist[]; extern int sys_nerr;
+# define strerror(errnum) \
+	(((errnum)<0 || (errnum)>=sys_nerr) ? NULL : sys_errlist[errnum])
+  /* Being signed SunOS 4.x memcpy breaks ASN1_OBJECT table lookup */
+#include "crypto/o_str.h"
+# define memcmp OPENSSL_memcmp
+#endif
+
+#ifndef OPENSSL_EXIT
+# if defined(MONOLITH) && !defined(OPENSSL_C)
+#  define OPENSSL_EXIT(n) return(n)
+# else
+#  define OPENSSL_EXIT(n) do { EXIT(n); return(n); } while(0)
+# endif
+#endif
+
+/***********************************************/
+
+#define DG_GCC_BUG	/* gcc < 2.6.3 on DGUX */
+
+#ifdef sgi
+#define IRIX_CC_BUG	/* all version of IRIX I've tested (4.* 5.*) */
+#endif
+#ifdef OPENSSL_SYS_SNI
+#define IRIX_CC_BUG	/* CDS++ up to V2.0Bsomething suffered from the same bug.*/
+#endif
+
+#if defined(OPENSSL_SYS_WINDOWS)
+#  define strcasecmp _stricmp
+#  define strncasecmp _strnicmp
+#elif defined(OPENSSL_SYS_VMS)
+/* VMS below version 7.0 doesn't have strcasecmp() */
+#  include "o_str.h"
+#  define strcasecmp OPENSSL_strcasecmp
+#  define strncasecmp OPENSSL_strncasecmp
+#  define OPENSSL_IMPLEMENTS_strncasecmp
+#elif defined(OPENSSL_SYS_OS2) && defined(__EMX__)
+#  define strcasecmp stricmp
+#  define strncasecmp strnicmp
+#elif defined(OPENSSL_SYS_NETWARE)
+#  include <string.h>
+#  if defined(NETWARE_CLIB)
+#    define strcasecmp stricmp
+#    define strncasecmp strnicmp
+#  endif /* NETWARE_CLIB */
+#endif
+
+#if defined(OPENSSL_SYS_OS2) && defined(__EMX__)
+# include <io.h>
+# include <fcntl.h>
+# define NO_SYSLOG
+#endif
+
+/* vxworks */
+#if defined(OPENSSL_SYS_VXWORKS)
+#include <ioLib.h>
+#include <tickLib.h>
+#include <sysLib.h>
+
+#define TTY_STRUCT int
+
+#define sleep(a) taskDelay((a) * sysClkRateGet())
+
+#include <vxWorks.h>
+#include <sockLib.h>
+#include <taskLib.h>
+
+#define getpid taskIdSelf
+
+/* NOTE: these are implemented by helpers in database app!
+ * if the database is not linked, we need to implement them
+ * elswhere */
+struct hostent *gethostbyname(const char *name);
+struct hostent *gethostbyaddr(const char *addr, int length, int type);
+struct servent *getservbyname(const char *name, const char *proto);
+
+#endif
+/* end vxworks */
+
+/* beos */
+#if defined(OPENSSL_SYS_BEOS_R5)
+#define SO_ERROR 0
+#define NO_SYS_UN
+#define IPPROTO_IP 0
+#include <OS.h>
+#endif
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
+
diff -Naur crypto/cmp/e_os2.h crypto-/cmp/e_os2.h
--- cryptoold/cmp/e_os2.h	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/e_os2.h	2017-04-20 16:50:26.937043376 +0700
@@ -0,0 +1,315 @@
+/* e_os2.h */
+/* ====================================================================
+ * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <openssl/opensslconf.h>
+
+#ifndef HEADER_E_OS2_H
+#define HEADER_E_OS2_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+ * Detect operating systems.  This probably needs completing.
+ * The result is that at least one OPENSSL_SYS_os macro should be defined.
+ * However, if none is defined, Unix is assumed.
+ **/
+
+#define OPENSSL_SYS_UNIX
+
+/* ----------------------- Macintosh, before MacOS X ----------------------- */
+#if defined(__MWERKS__) && defined(macintosh) || defined(OPENSSL_SYSNAME_MAC)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_MACINTOSH_CLASSIC
+#endif
+
+/* ----------------------- NetWare ----------------------------------------- */
+#if defined(NETWARE) || defined(OPENSSL_SYSNAME_NETWARE)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_NETWARE
+#endif
+
+/* ---------------------- Microsoft operating systems ---------------------- */
+
+/* Note that MSDOS actually denotes 32-bit environments running on top of
+   MS-DOS, such as DJGPP one. */
+#if defined(OPENSSL_SYSNAME_MSDOS)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_MSDOS
+#endif
+
+/* For 32 bit environment, there seems to be the CygWin environment and then
+   all the others that try to do the same thing Microsoft does... */
+#if defined(OPENSSL_SYSNAME_UWIN)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_WIN32_UWIN
+#else
+# if defined(__CYGWIN32__) || defined(OPENSSL_SYSNAME_CYGWIN32)
+#  undef OPENSSL_SYS_UNIX
+#  define OPENSSL_SYS_WIN32_CYGWIN
+# else
+#  if defined(_WIN32) || defined(OPENSSL_SYSNAME_WIN32)
+#   undef OPENSSL_SYS_UNIX
+#   define OPENSSL_SYS_WIN32
+#  endif
+#  if defined(OPENSSL_SYSNAME_WINNT)
+#   undef OPENSSL_SYS_UNIX
+#   define OPENSSL_SYS_WINNT
+#  endif
+#  if defined(OPENSSL_SYSNAME_WINCE)
+#   undef OPENSSL_SYS_UNIX
+#   define OPENSSL_SYS_WINCE
+#  endif
+# endif
+#endif
+
+/* Anything that tries to look like Microsoft is "Windows" */
+#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WINNT) || defined(OPENSSL_SYS_WINCE)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_WINDOWS
+# ifndef OPENSSL_SYS_MSDOS
+#  define OPENSSL_SYS_MSDOS
+# endif
+#endif
+
+/* DLL settings.  This part is a bit tough, because it's up to the application
+   implementor how he or she will link the application, so it requires some
+   macro to be used. */
+#ifdef OPENSSL_SYS_WINDOWS
+# ifndef OPENSSL_OPT_WINDLL
+#  if defined(_WINDLL) /* This is used when building OpenSSL to indicate that
+                          DLL linkage should be used */
+#   define OPENSSL_OPT_WINDLL
+#  endif
+# endif
+#endif
+
+/* -------------------------------- OpenVMS -------------------------------- */
+#if defined(__VMS) || defined(VMS) || defined(OPENSSL_SYSNAME_VMS)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_VMS
+# if defined(__DECC)
+#  define OPENSSL_SYS_VMS_DECC
+# elif defined(__DECCXX)
+#  define OPENSSL_SYS_VMS_DECC
+#  define OPENSSL_SYS_VMS_DECCXX
+# else
+#  define OPENSSL_SYS_VMS_NODECC
+# endif
+#endif
+
+/* --------------------------------- OS/2 ---------------------------------- */
+#if defined(__EMX__) || defined(__OS2__)
+# undef OPENSSL_SYS_UNIX
+# define OPENSSL_SYS_OS2
+#endif
+
+/* --------------------------------- Unix ---------------------------------- */
+#ifdef OPENSSL_SYS_UNIX
+# if defined(linux) || defined(__linux__) || defined(OPENSSL_SYSNAME_LINUX)
+#  define OPENSSL_SYS_LINUX
+# endif
+# ifdef OPENSSL_SYSNAME_MPE
+#  define OPENSSL_SYS_MPE
+# endif
+# ifdef OPENSSL_SYSNAME_SNI
+#  define OPENSSL_SYS_SNI
+# endif
+# ifdef OPENSSL_SYSNAME_ULTRASPARC
+#  define OPENSSL_SYS_ULTRASPARC
+# endif
+# ifdef OPENSSL_SYSNAME_NEWS4
+#  define OPENSSL_SYS_NEWS4
+# endif
+# ifdef OPENSSL_SYSNAME_MACOSX
+#  define OPENSSL_SYS_MACOSX
+# endif
+# ifdef OPENSSL_SYSNAME_MACOSX_RHAPSODY
+#  define OPENSSL_SYS_MACOSX_RHAPSODY
+#  define OPENSSL_SYS_MACOSX
+# endif
+# ifdef OPENSSL_SYSNAME_SUNOS
+#  define OPENSSL_SYS_SUNOS
+#endif
+# if defined(_CRAY) || defined(OPENSSL_SYSNAME_CRAY)
+#  define OPENSSL_SYS_CRAY
+# endif
+# if defined(_AIX) || defined(OPENSSL_SYSNAME_AIX)
+#  define OPENSSL_SYS_AIX
+# endif
+#endif
+
+/* --------------------------------- VOS ----------------------------------- */
+#if defined(__VOS__) || defined(OPENSSL_SYSNAME_VOS)
+# define OPENSSL_SYS_VOS
+#ifdef __HPPA__
+# define OPENSSL_SYS_VOS_HPPA
+#endif
+#ifdef __IA32__
+# define OPENSSL_SYS_VOS_IA32
+#endif
+#endif
+
+/* ------------------------------- VxWorks --------------------------------- */
+#ifdef OPENSSL_SYSNAME_VXWORKS
+# define OPENSSL_SYS_VXWORKS
+#endif
+
+/* --------------------------------- BeOS ---------------------------------- */
+#if defined(__BEOS__)
+# define OPENSSL_SYS_BEOS
+# include <sys/socket.h>
+# if defined(BONE_VERSION)
+#  define OPENSSL_SYS_BEOS_BONE
+# else
+#  define OPENSSL_SYS_BEOS_R5
+# endif
+#endif
+
+/**
+ * That's it for OS-specific stuff
+ *****************************************************************************/
+
+
+/* Specials for I/O an exit */
+#ifdef OPENSSL_SYS_MSDOS
+# define OPENSSL_UNISTD_IO <io.h>
+# define OPENSSL_DECLARE_EXIT extern void exit(int);
+#else
+# define OPENSSL_UNISTD_IO OPENSSL_UNISTD
+# define OPENSSL_DECLARE_EXIT /* declared in unistd.h */
+#endif
+
+/* Definitions of OPENSSL_GLOBAL and OPENSSL_EXTERN, to define and declare
+   certain global symbols that, with some compilers under VMS, have to be
+   defined and declared explicitely with globaldef and globalref.
+   Definitions of OPENSSL_EXPORT and OPENSSL_IMPORT, to define and declare
+   DLL exports and imports for compilers under Win32.  These are a little
+   more complicated to use.  Basically, for any library that exports some
+   global variables, the following code must be present in the header file
+   that declares them, before OPENSSL_EXTERN is used:
+
+   #ifdef SOME_BUILD_FLAG_MACRO
+   # undef OPENSSL_EXTERN
+   # define OPENSSL_EXTERN OPENSSL_EXPORT
+   #endif
+
+   The default is to have OPENSSL_EXPORT, OPENSSL_IMPORT and OPENSSL_GLOBAL
+   have some generally sensible values, and for OPENSSL_EXTERN to have the
+   value OPENSSL_IMPORT.
+*/
+
+#if defined(OPENSSL_SYS_VMS_NODECC)
+# define OPENSSL_EXPORT globalref
+# define OPENSSL_IMPORT globalref
+# define OPENSSL_GLOBAL globaldef
+#elif defined(OPENSSL_SYS_WINDOWS) && defined(OPENSSL_OPT_WINDLL)
+# define OPENSSL_EXPORT extern __declspec(dllexport)
+# define OPENSSL_IMPORT extern __declspec(dllimport)
+# define OPENSSL_GLOBAL
+#else
+# define OPENSSL_EXPORT extern
+# define OPENSSL_IMPORT extern
+# define OPENSSL_GLOBAL
+#endif
+#define OPENSSL_EXTERN OPENSSL_IMPORT
+
+/* Macros to allow global variables to be reached through function calls when
+   required (if a shared library version requires it, for example.
+   The way it's done allows definitions like this:
+
+	// in foobar.c
+	OPENSSL_IMPLEMENT_GLOBAL(int,foobar,0)
+	// in foobar.h
+	OPENSSL_DECLARE_GLOBAL(int,foobar);
+	#define foobar OPENSSL_GLOBAL_REF(foobar)
+*/
+#ifdef OPENSSL_EXPORT_VAR_AS_FUNCTION
+# define OPENSSL_IMPLEMENT_GLOBAL(type,name,value)			\
+	type *_shadow_##name(void)					\
+	{ static type _hide_##name=value; return &_hide_##name; }
+# define OPENSSL_DECLARE_GLOBAL(type,name) type *_shadow_##name(void)
+# define OPENSSL_GLOBAL_REF(name) (*(_shadow_##name()))
+#else
+# define OPENSSL_IMPLEMENT_GLOBAL(type,name,value) OPENSSL_GLOBAL type _shadow_##name=value;
+# define OPENSSL_DECLARE_GLOBAL(type,name) OPENSSL_EXPORT type _shadow_##name
+# define OPENSSL_GLOBAL_REF(name) _shadow_##name
+#endif
+
+#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC) && macintosh==1 && !defined(MAC_OS_GUSI_SOURCE)
+#  define ossl_ssize_t long
+#endif
+
+#ifdef OPENSSL_SYS_MSDOS
+#  define ossl_ssize_t long
+#endif
+
+#if defined(NeXT) || defined(OPENSSL_SYS_NEWS4) || defined(OPENSSL_SYS_SUNOS)
+#  define ssize_t int
+#endif
+
+#if defined(__ultrix) && !defined(ssize_t)
+#  define ossl_ssize_t int 
+#endif
+
+#ifndef ossl_ssize_t
+#  define ossl_ssize_t ssize_t
+#endif
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Naur crypto/cmp/rfc4210.txt crypto-/cmp/rfc4210.txt
--- cryptoold/cmp/rfc4210.txt	1970-01-01 07:00:00.000000000 +0700
+++ crypto/cmp/rfc4210.txt	2017-04-20 16:50:26.941043274 +0700
@@ -0,0 +1,5323 @@
+
+
+
+
+
+
+Network Working Group                                           C. Adams
+Request for Comments: 4210                          University of Ottawa
+Obsoletes: 2510                                               S. Farrell
+Category: Standards Track                         Trinity College Dublin
+                                                                T. Kause
+                                                                     SSH
+                                                              T. Mononen
+                                                                 SafeNet
+                                                          September 2005
+
+
+               Internet X.509 Public Key Infrastructure
+                 Certificate Management Protocol (CMP)
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2005).
+
+Abstract
+
+   This document describes the Internet X.509 Public Key Infrastructure
+   (PKI) Certificate Management Protocol (CMP).  Protocol messages are
+   defined for X.509v3 certificate creation and management.  CMP
+   provides on-line interactions between PKI components, including an
+   exchange between a Certification Authority (CA) and a client system.
+
+Table of Contents
+
+   1. Introduction ....................................................5
+   2. Requirements ....................................................5
+   3. PKI Management Overview .........................................5
+      3.1. PKI Management Model .......................................6
+           3.1.1. Definitions of PKI Entities .........................6
+                  3.1.1.1. Subjects and End Entities ..................6
+                  3.1.1.2. Certification Authority ....................7
+                  3.1.1.3. Registration Authority .....................7
+           3.1.2. PKI Management Requirements .........................8
+           3.1.3. PKI Management Operations ..........................10
+   4. Assumptions and Restrictions ...................................14
+      4.1. End Entity Initialization .................................14
+
+
+
+Adams, et al.               Standards Track                     [Page 1]
+
+RFC 4210                          CMP                     September 2005
+
+
+      4.2. Initial Registration/Certification ........................14
+           4.2.1. Criteria Used ......................................15
+                  4.2.1.1. Initiation of Registration/Certification ..15
+                  4.2.1.2. End Entity Message Origin Authentication ..15
+                  4.2.1.3. Location of Key Generation ................15
+                  4.2.1.4. Confirmation of Successful Certification ..16
+           4.2.2. Mandatory Schemes ..................................16
+                  4.2.2.1. Centralized Scheme ........................16
+                  4.2.2.2. Basic Authenticated Scheme ................17
+      4.3. Proof-of-Possession (POP) of Private Key ..................17
+           4.3.1. Signature Keys .....................................18
+           4.3.2. Encryption Keys ....................................18
+           4.3.3. Key Agreement Keys .................................19
+      4.4. Root CA Key Update ........................................19
+           4.4.1. CA Operator Actions ................................20
+           4.4.2. Verifying Certificates .............................21
+                  4.4.2.1. Verification in Cases 1, 4, 5, and 8 ......22
+                  4.4.2.2. Verification in Case 2 ....................22
+                  4.4.2.3. Verification in Case 3 ....................23
+                  4.4.2.4. Failure of Verification in Case 6 .........23
+                  4.4.2.5. Failure of Verification in Case 7 .........23
+           4.4.3. Revocation - Change of CA Key ......................23
+   5. Data Structures ................................................24
+      5.1. Overall PKI Message .......................................24
+           5.1.1. PKI Message Header .................................24
+                  5.1.1.1. ImplicitConfirm ...........................27
+                  5.1.1.2. ConfirmWaitTime ...........................27
+           5.1.2. PKI Message Body ...................................27
+           5.1.3. PKI Message Protection .............................28
+                  5.1.3.1. Shared Secret Information .................29
+                  5.1.3.2. DH Key Pairs ..............................30
+                  5.1.3.3. Signature .................................30
+                  5.1.3.4. Multiple Protection .......................30
+      5.2. Common Data Structures ....................................31
+           5.2.1. Requested Certificate Contents .....................31
+           5.2.2. Encrypted Values ...................................31
+           5.2.3. Status codes and Failure Information for
+                  PKI Messages .......................................32
+           5.2.4. Certificate Identification .........................33
+           5.2.5. Out-of-band root CA Public Key .....................33
+           5.2.6. Archive Options ....................................34
+           5.2.7. Publication Information ............................34
+           5.2.8. Proof-of-Possession Structures .....................34
+                  5.2.8.1. Inclusion of the Private Key ..............35
+                  5.2.8.2. Indirect Method ...........................35
+                  5.2.8.3. Challenge-Response Protocol ...............35
+                  5.2.8.4. Summary of PoP Options ....................37
+
+
+
+
+Adams, et al.               Standards Track                     [Page 2]
+
+RFC 4210                          CMP                     September 2005
+
+
+      5.3. Operation-Specific Data Structures ........................38
+           5.3.1. Initialization Request .............................38
+           5.3.2. Initialization Response ............................39
+           5.3.3. Certification Request ..............................39
+           5.3.4. Certification Response .............................39
+           5.3.5. Key Update Request Content .........................40
+           5.3.6. Key Update Response Content ........................41
+           5.3.7. Key Recovery Request Content .......................41
+           5.3.8. Key Recovery Response Content ......................41
+           5.3.9. Revocation Request Content .........................41
+           5.3.10. Revocation Response Content .......................42
+           5.3.11. Cross Certification Request Content ...............42
+           5.3.12. Cross Certification Response Content ..............42
+           5.3.13. CA Key Update Announcement Content ................42
+           5.3.14. Certificate Announcement ..........................43
+           5.3.15. Revocation Announcement ...........................43
+           5.3.16. CRL Announcement ..................................43
+           5.3.17. PKI Confirmation Content ..........................43
+           5.3.18. Certificate Confirmation Content ..................44
+           5.3.19. PKI General Message Content .......................44
+                  5.3.19.1. CA Protocol Encryption Certificate .......44
+                  5.3.19.2. Signing Key Pair Types ...................45
+                  5.3.19.3. Encryption/Key Agreement Key Pair Types ..45
+                  5.3.19.4. Preferred Symmetric Algorithm ............45
+                  5.3.19.5. Updated CA Key Pair ......................45
+                  5.3.19.6. CRL ......................................46
+                  5.3.19.7. Unsupported Object Identifiers ...........46
+                  5.3.19.8. Key Pair Parameters ......................46
+                  5.3.19.9. Revocation Passphrase ....................46
+                  5.3.19.10. ImplicitConfirm .........................46
+                  5.3.19.11. ConfirmWaitTime .........................47
+                  5.3.19.12. Original PKIMessage .....................47
+                  5.3.19.13. Supported Language Tags .................47
+           5.3.20. PKI General Response Content ......................47
+           5.3.21. Error Message Content .............................47
+           5.3.22. Polling Request and Response ......................48
+   6. Mandatory PKI Management Functions .............................51
+      6.1. Root CA Initialization ....................................51
+      6.2. Root CA Key Update ........................................51
+      6.3. Subordinate CA Initialization .............................51
+      6.4. CRL production ............................................52
+      6.5. PKI Information Request ...................................52
+      6.6. Cross Certification .......................................52
+           6.6.1. One-Way Request-Response Scheme: ...................52
+      6.7. End Entity Initialization .................................54
+           6.7.1. Acquisition of PKI Information .....................54
+           6.7.2. Out-of-Band Verification of Root-CA Key ............55
+      6.8. Certificate Request .......................................55
+
+
+
+Adams, et al.               Standards Track                     [Page 3]
+
+RFC 4210                          CMP                     September 2005
+
+
+      6.9. Key Update ................................................55
+   7. Version Negotiation ............................................56
+      7.1. Supporting RFC 2510 Implementations .......................56
+           7.1.1. Clients Talking to RFC 2510 Servers ................56
+           7.1.2. Servers Receiving Version cmp1999 PKIMessages ......57
+   8. Security Considerations ........................................57
+      8.1. Proof-Of-Possession with a Decryption Key .................57
+      8.2. Proof-Of-Possession by Exposing the Private Key ...........57
+      8.3. Attack Against Diffie-Hellman Key Exchange ................57
+   9. IANA Considerations ............................................58
+   Normative References ..............................................58
+   Informative References ............................................59
+   A. Reasons for the Presence of RAs ................................61
+   B. The Use of Revocation Passphrase ...............................61
+   C. Request Message Behavioral Clarifications ......................63
+   D. PKI Management Message Profiles (REQUIRED) .....................65
+      D.1. General Rules for Interpretation of These Profiles ........65
+      D.2. Algorithm Use Profile .....................................66
+      D.3. Proof-of-Possession Profile ...............................68
+      D.4. Initial Registration/Certification (Basic
+           Authenticated Scheme) .....................................68
+      D.5. Certificate Request .......................................74
+      D.6. Key Update Request ........................................75
+   E. PKI Management Message Profiles (OPTIONAL) .....................75
+      E.1. General Rules for Interpretation of These Profiles ........76
+      E.2. Algorithm Use Profile .....................................76
+      E.3. Self-Signed Certificates ..................................76
+      E.4. Root CA Key Update ........................................77
+      E.5. PKI Information Request/Response ..........................77
+      E.6. Cross Certification Request/Response (1-way) ..............79
+      E.7. In-Band Initialization Using External Identity
+           Certificate  ..............................................82
+   F. Compilable ASN.1 Definitions ...................................83
+   G. Acknowledgements ...............................................93
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                     [Page 4]
+
+RFC 4210                          CMP                     September 2005
+
+
+1.  Introduction
+
+   This document describes the Internet X.509 Public Key Infrastructure
+   (PKI) Certificate Management Protocol (CMP).  Protocol messages are
+   defined for certificate creation and management.  The term
+   "certificate" in this document refers to an X.509v3 Certificate as
+   defined in [X509].
+
+   This specification obsoletes RFC 2510.  This specification differs
+   from RFC 2510 in the following areas:
+
+      The PKI management message profile section is split to two
+      appendices: the required profile and the optional profile.  Some
+      of the formerly mandatory functionality is moved to the optional
+      profile.
+
+      The message confirmation mechanism has changed substantially.
+
+      A new polling mechanism is introduced, deprecating the old polling
+      method at the CMP transport level.
+
+      The CMP transport protocol issues are handled in a separate
+      document [CMPtrans], thus the Transports section is removed.
+
+      A new implicit confirmation method is introduced to reduce the
+      number of protocol messages exchanged in a transaction.
+
+      The new specification contains some less prominent protocol
+      enhancements and improved explanatory text on several issues.
+
+2.  Requirements
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT",
+   "RECOMMENDED", "MAY", and "OPTIONAL" in this document (in uppercase,
+   as shown) are to be interpreted as described in [RFC2119].
+
+3.  PKI Management Overview
+
+   The PKI must be structured to be consistent with the types of
+   individuals who must administer it.  Providing such administrators
+   with unbounded choices not only complicates the software required,
+   but also increases the chances that a subtle mistake by an
+   administrator or software developer will result in broader
+   compromise.  Similarly, restricting administrators with cumbersome
+   mechanisms will cause them not to use the PKI.
+
+
+
+
+
+
+Adams, et al.               Standards Track                     [Page 5]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Management protocols are REQUIRED to support on-line interactions
+   between Public Key Infrastructure (PKI) components.  For example, a
+   management protocol might be used between a Certification Authority
+   (CA) and a client system with which a key pair is associated, or
+   between two CAs that issue cross-certificates for each other.
+
+3.1.  PKI Management Model
+
+   Before specifying particular message formats and procedures, we first
+   define the entities involved in PKI management and their interactions
+   (in terms of the PKI management functions required).  We then group
+   these functions in order to accommodate different identifiable types
+   of end entities.
+
+3.1.1.  Definitions of PKI Entities
+
+   The entities involved in PKI management include the end entity (i.e.,
+   the entity to whom the certificate is issued) and the certification
+   authority (i.e., the entity that issues the certificate).  A
+   registration authority MAY also be involved in PKI management.
+
+3.1.1.1.  Subjects and End Entities
+
+   The term "subject" is used here to refer to the entity to whom the
+   certificate is issued, typically named in the subject or
+   subjectAltName field of a certificate.  When we wish to distinguish
+   the tools and/or software used by the subject (e.g., a local
+   certificate management module), we will use the term "subject
+   equipment".  In general, the term "end entity" (EE), rather than
+   "subject", is preferred in order to avoid confusion with the field
+   name.  It is important to note that the end entities here will
+   include not only human users of applications, but also applications
+   themselves (e.g., for IP security).  This factor influences the
+   protocols that the PKI management operations use; for example,
+   application software is far more likely to know exactly which
+   certificate extensions are required than are human users.  PKI
+   management entities are also end entities in the sense that they are
+   sometimes named in the subject or subjectAltName field of a
+   certificate or cross-certificate.  Where appropriate, the term "end-
+   entity" will be used to refer to end entities who are not PKI
+   management entities.
+
+   All end entities require secure local access to some information --
+   at a minimum, their own name and private key, the name of a CA that
+   is directly trusted by this entity, and that CA's public key (or a
+   fingerprint of the public key where a self-certified version is
+   available elsewhere).  Implementations MAY use secure local storage
+   for more than this minimum (e.g., the end entity's own certificate or
+
+
+
+Adams, et al.               Standards Track                     [Page 6]
+
+RFC 4210                          CMP                     September 2005
+
+
+   application-specific information).  The form of storage will also
+   vary -- from files to tamper-resistant cryptographic tokens.  The
+   information stored in such local, trusted storage is referred to here
+   as the end entity's Personal Security Environment (PSE).
+
+   Though PSE formats are beyond the scope of this document (they are
+   very dependent on equipment, et cetera), a generic interchange format
+   for PSEs is defined here: a certification response message MAY be
+   used.
+
+3.1.1.2.  Certification Authority
+
+   The certification authority (CA) may or may not actually be a real
+   "third party" from the end entity's point of view.  Quite often, the
+   CA will actually belong to the same organization as the end entities
+   it supports.
+
+   Again, we use the term "CA" to refer to the entity named in the
+   issuer field of a certificate.  When it is necessary to distinguish
+   the software or hardware tools used by the CA, we use the term "CA
+   equipment".
+
+   The CA equipment will often include both an "off-line" component and
+   an "on-line" component, with the CA private key only available to the
+   "off-line" component.  This is, however, a matter for implementers
+   (though it is also relevant as a policy issue).
+
+   We use the term "root CA" to indicate a CA that is directly trusted
+   by an end entity; that is, securely acquiring the value of a root CA
+   public key requires some out-of-band step(s).  This term is not meant
+   to imply that a root CA is necessarily at the top of any hierarchy,
+   simply that the CA in question is trusted directly.
+
+   A "subordinate CA" is one that is not a root CA for the end entity in
+   question.  Often, a subordinate CA will not be a root CA for any
+   entity, but this is not mandatory.
+
+3.1.1.3.  Registration Authority
+
+   In addition to end-entities and CAs, many environments call for the
+   existence of a Registration Authority (RA) separate from the
+   Certification Authority.  The functions that the registration
+   authority may carry out will vary from case to case but MAY include
+   personal authentication, token distribution, revocation reporting,
+   name assignment, key generation, archival of key pairs, et cetera.
+
+
+
+
+
+
+Adams, et al.               Standards Track                     [Page 7]
+
+RFC 4210                          CMP                     September 2005
+
+
+   This document views the RA as an OPTIONAL component: when it is not
+   present, the CA is assumed to be able to carry out the RA's functions
+   so that the PKI management protocols are the same from the end-
+   entity's point of view.
+
+   Again, we distinguish, where necessary, between the RA and the tools
+   used (the "RA equipment").
+
+   Note that an RA is itself an end entity.  We further assume that all
+   RAs are in fact certified end entities and that RAs have private keys
+   that are usable for signing.  How a particular CA equipment
+   identifies some end entities as RAs is an implementation issue (i.e.,
+   this document specifies no special RA certification operation).  We
+   do not mandate that the RA is certified by the CA with which it is
+   interacting at the moment (so one RA may work with more than one CA
+   whilst only being certified once).
+
+   In some circumstances, end entities will communicate directly with a
+   CA even where an RA is present.  For example, for initial
+   registration and/or certification, the subject may use its RA, but
+   communicate directly with the CA in order to refresh its certificate.
+
+3.1.2.  PKI Management Requirements
+
+   The protocols given here meet the following requirements on PKI
+   management
+
+   1.   PKI management must conform to the ISO/IEC 9594-8/ITU-T X.509
+        standards.
+
+   2.   It must be possible to regularly update any key pair without
+        affecting any other key pair.
+
+   3.   The use of confidentiality in PKI management protocols must be
+        kept to a minimum in order to ease acceptance in environments
+        where strong confidentiality might cause regulatory problems.
+
+   4.   PKI management protocols must allow the use of different
+        industry-standard cryptographic algorithms (specifically
+        including RSA, DSA, MD5, and SHA-1).  This means that any given
+        CA, RA, or end entity may, in principle, use whichever
+        algorithms suit it for its own key pair(s).
+
+   5.   PKI management protocols must not preclude the generation of key
+        pairs by the end-entity concerned, by an RA, or by a CA.  Key
+        generation may also occur elsewhere, but for the purposes of PKI
+        management we can regard key generation as occurring wherever
+        the key is first present at an end entity, RA, or CA.
+
+
+
+Adams, et al.               Standards Track                     [Page 8]
+
+RFC 4210                          CMP                     September 2005
+
+
+   6.   PKI management protocols must support the publication of
+        certificates by the end-entity concerned, by an RA, or by a CA.
+        Different implementations and different environments may choose
+        any of the above approaches.
+
+   7.   PKI management protocols must support the production of
+        Certificate Revocation Lists (CRLs) by allowing certified end
+        entities to make requests for the revocation of certificates.
+        This must be done in such a way that the denial-of-service
+        attacks, which are possible, are not made simpler.
+
+   8.   PKI management protocols must be usable over a variety of
+        "transport" mechanisms, specifically including mail, http,
+        TCP/IP and ftp.
+
+   9.   Final authority for certification creation rests with the CA.
+        No RA or end-entity equipment can assume that any certificate
+        issued by a CA will contain what was requested; a CA may alter
+        certificate field values or may add, delete, or alter extensions
+        according to its operating policy.  In other words, all PKI
+        entities (end-entities, RAs, and CAs) must be capable of
+        handling responses to requests for certificates in which the
+        actual certificate issued is different from that requested (for
+        example, a CA may shorten the validity period requested).  Note
+        that policy may dictate that the CA must not publish or
+        otherwise distribute the certificate until the requesting entity
+        has reviewed and accepted the newly-created certificate
+        (typically through use of the certConf message).
+
+   10.  A graceful, scheduled change-over from one non-compromised CA
+        key pair to the next (CA key update) must be supported (note
+        that if the CA key is compromised, re-initialization must be
+        performed for all entities in the domain of that CA).  An end
+        entity whose PSE contains the new CA public key (following a CA
+        key update) must also be able to verify certificates verifiable
+        using the old public key.  End entities who directly trust the
+        old CA key pair must also be able to verify certificates signed
+        using the new CA private key (required for situations where the
+        old CA public key is "hardwired" into the end entity's
+        cryptographic equipment).
+
+   11.  The functions of an RA may, in some implementations or
+        environments, be carried out by the CA itself.  The protocols
+        must be designed so that end entities will use the same protocol
+        regardless of whether the communication is with an RA or CA.
+        Naturally, the end entity must use the correct RA of CA public
+        key to protect the communication.
+
+
+
+
+Adams, et al.               Standards Track                     [Page 9]
+
+RFC 4210                          CMP                     September 2005
+
+
+   12.  Where an end entity requests a certificate containing a given
+        public key value, the end entity must be ready to demonstrate
+        possession of the corresponding private key value.  This may be
+        accomplished in various ways, depending on the type of
+        certification request.  See Section 4.3 for details of the in-
+        band methods defined for the PKIX-CMP (i.e., Certificate
+        Management Protocol) messages.
+
+3.1.3.  PKI Management Operations
+
+   The following diagram shows the relationship between the entities
+   defined above in terms of the PKI management operations.  The letters
+   in the diagram indicate "protocols" in the sense that a defined set
+   of PKI management messages can be sent along each of the lettered
+   lines.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 10]
+
+RFC 4210                          CMP                     September 2005
+
+
+     +---+     cert. publish        +------------+      j
+     |   |  <---------------------  | End Entity | <-------
+     | C |             g            +------------+      "out-of-band"
+     | e |                            | ^                loading
+     | r |                            | |      initial
+     | t |                          a | | b     registration/
+     |   |                            | |       certification
+     | / |                            | |      key pair recovery
+     |   |                            | |      key pair update
+     | C |                            | |      certificate update
+     | R |  PKI "USERS"               V |      revocation request
+     | L | -------------------+-+-----+-+------+-+-------------------
+     |   |  PKI MANAGEMENT    | ^              | ^
+     |   |    ENTITIES      a | | b          a | | b
+     | R |                    V |              | |
+     | e |             g   +------+    d       | |
+     | p |   <------------ | RA   | <-----+    | |
+     | o |      cert.      |      | ----+ |    | |
+     | s |       publish   +------+   c | |    | |
+     | i |                              | |    | |
+     | t |                              V |    V |
+     | o |          g                 +------------+   i
+     | r |   <------------------------|     CA     |------->
+     | y |          h                 +------------+  "out-of-band"
+     |   |      cert. publish              | ^         publication
+     |   |      CRL publish                | |
+     +---+                                 | |    cross-certification
+                                         e | | f  cross-certificate
+                                           | |       update
+                                           | |
+                                           V |
+                                         +------+
+                                         | CA-2 |
+                                         +------+
+
+   Figure 1 - PKI Entities
+
+     At a high level, the set of operations for which management
+     messages are defined can be grouped as follows.
+
+   1.  CA establishment: When establishing a new CA, certain steps are
+       required (e.g., production of initial CRLs, export of CA public
+       key).
+
+   2.  End entity initialization: this includes importing a root CA
+       public key and requesting information about the options supported
+       by a PKI management entity.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 11]
+
+RFC 4210                          CMP                     September 2005
+
+
+   3.  Certification: various operations result in the creation of new
+       certificates:
+
+       1.  initial registration/certification: This is the process
+           whereby an end entity first makes itself known to a CA or RA,
+           prior to the CA issuing a certificate or certificates for
+           that end entity.  The end result of this process (when it is
+           successful) is that a CA issues a certificate for an end
+           entity's public key, and returns that certificate to the end
+           entity and/or posts that certificate in a public repository.
+           This process may, and typically will, involve multiple
+           "steps", possibly including an initialization of the end
+           entity's equipment.  For example, the end entity's equipment
+           must be securely initialized with the public key of a CA, to
+           be used in validating certificate paths.  Furthermore, an end
+           entity typically needs to be initialized with its own key
+           pair(s).
+
+       2.  key pair update: Every key pair needs to be updated regularly
+           (i.e., replaced with a new key pair), and a new certificate
+           needs to be issued.
+
+       3.  certificate update: As certificates expire, they may be
+           "refreshed" if nothing relevant in the environment has
+           changed.
+
+       4.  CA key pair update: As with end entities, CA key pairs need
+           to be updated regularly; however, different mechanisms are
+           required.
+
+       5.  cross-certification request: One CA requests issuance of a
+           cross-certificate from another CA.  For the purposes of this
+           standard, the following terms are defined.  A "cross-
+           certificate" is a certificate in which the subject CA and the
+           issuer CA are distinct and SubjectPublicKeyInfo contains a
+           verification key (i.e., the certificate has been issued for
+           the subject CA's signing key pair).  When it is necessary to
+           distinguish more finely, the following terms may be used: a
+           cross-certificate is called an "inter-domain cross-
+           certificate" if the subject and issuer CAs belong to
+           different administrative domains; it is called an "intra-
+           domain cross-certificate" otherwise.
+
+           1.  Note 1.  The above definition of "cross-certificate"
+               aligns with the defined term "CA-certificate" in X.509.
+               Note that this term is not to be confused with the X.500
+               "cACertificate" attribute type, which is unrelated.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 12]
+
+RFC 4210                          CMP                     September 2005
+
+
+           2.  Note 2.  In many environments, the term "cross-
+               certificate", unless further qualified, will be
+               understood to be synonymous with "inter-domain cross-
+               certificate" as defined above.
+
+           3.  Note 3.  Issuance of cross-certificates may be, but is
+               not necessarily, mutual; that is, two CAs may issue
+               cross-certificates for each other.
+
+       6.  cross-certificate update: Similar to a normal certificate
+           update, but involving a cross-certificate.
+
+   4.  Certificate/CRL discovery operations: some PKI management
+       operations result in the publication of certificates or CRLs:
+
+       1.  certificate publication: Having gone to the trouble of
+           producing a certificate, some means for publishing it is
+           needed.  The "means" defined in PKIX MAY involve the messages
+           specified in Sections 5.3.13 to 5.3.16, or MAY involve other
+           methods (LDAP, for example) as described in [RFC2559],
+           [RFC2585] (the "Operational Protocols" documents of the PKIX
+           series of specifications).
+
+       2.  CRL publication: As for certificate publication.
+
+   5.  Recovery operations: some PKI management operations are used when
+       an end entity has "lost" its PSE:
+
+       1.  key pair recovery: As an option, user client key materials
+           (e.g., a user's private key used for decryption purposes) MAY
+           be backed up by a CA, an RA, or a key backup system
+           associated with a CA or RA.  If an entity needs to recover
+           these backed up key materials (e.g., as a result of a
+           forgotten password or a lost key chain file), a protocol
+           exchange may be needed to support such recovery.
+
+   6.  Revocation operations: some PKI operations result in the creation
+       of new CRL entries and/or new CRLs:
+
+       1.  revocation request: An authorized person advises a CA of an
+           abnormal situation requiring certificate revocation.
+
+   7.  PSE operations: whilst the definition of PSE operations (e.g.,
+       moving a PSE, changing a PIN, etc.) are beyond the scope of this
+       specification, we do define a PKIMessage (CertRepMessage) that
+       can form the basis of such operations.
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 13]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Note that on-line protocols are not the only way of implementing the
+   above operations.  For all operations, there are off-line methods of
+   achieving the same result, and this specification does not mandate
+   use of on-line protocols.  For example, when hardware tokens are
+   used, many of the operations MAY be achieved as part of the physical
+   token delivery.
+
+   Later sections define a set of standard messages supporting the above
+   operations.  Transport protocols for conveying these exchanges in
+   different environments (file-based, on-line, E-mail, and WWW) are
+   beyond the scope of this document and are specified separately.
+
+4.  Assumptions and Restrictions
+
+4.1.  End Entity Initialization
+
+   The first step for an end entity in dealing with PKI management
+   entities is to request information about the PKI functions supported
+   and to securely acquire a copy of the relevant root CA public key(s).
+
+4.2.  Initial Registration/Certification
+
+   There are many schemes that can be used to achieve initial
+   registration and certification of end entities.  No one method is
+   suitable for all situations due to the range of policies that a CA
+   may implement and the variation in the types of end entity which can
+   occur.
+
+   However, we can classify the initial registration/certification
+   schemes that are supported by this specification.  Note that the word
+   "initial", above, is crucial: we are dealing with the situation where
+   the end entity in question has had no previous contact with the PKI.
+   Where the end entity already possesses certified keys, then some
+   simplifications/alternatives are possible.
+
+   Having classified the schemes that are supported by this
+   specification we can then specify some as mandatory and some as
+   optional.  The goal is that the mandatory schemes cover a sufficient
+   number of the cases that will arise in real use, whilst the optional
+   schemes are available for special cases that arise less frequently.
+   In this way, we achieve a balance between flexibility and ease of
+   implementation.
+
+   We will now describe the classification of initial
+   registration/certification schemes.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 14]
+
+RFC 4210                          CMP                     September 2005
+
+
+4.2.1.  Criteria Used
+
+4.2.1.1.  Initiation of Registration/Certification
+
+   In terms of the PKI messages that are produced, we can regard the
+   initiation of the initial registration/certification exchanges as
+   occurring wherever the first PKI message relating to the end entity
+   is produced.  Note that the real-world initiation of the
+   registration/certification procedure may occur elsewhere (e.g., a
+   personnel department may telephone an RA operator).
+
+   The possible locations are at the end entity, an RA, or a CA.
+
+4.2.1.2.  End Entity Message Origin Authentication
+
+   The on-line messages produced by the end entity that requires a
+   certificate may be authenticated or not.  The requirement here is to
+   authenticate the origin of any messages from the end entity to the
+   PKI (CA/RA).
+
+   In this specification, such authentication is achieved by the PKI
+   (CA/RA) issuing the end entity with a secret value (initial
+   authentication key) and reference value (used to identify the secret
+   value) via some out-of-band means.  The initial authentication key
+   can then be used to protect relevant PKI messages.
+
+   Thus, we can classify the initial registration/certification scheme
+   according to whether or not the on-line end entity -> PKI messages
+   are authenticated or not.
+
+   Note 1: We do not discuss the authentication of the PKI -> end entity
+   messages here, as this is always REQUIRED.  In any case, it can be
+   achieved simply once the root-CA public key has been installed at the
+   end entity's equipment or it can be based on the initial
+   authentication key.
+
+   Note 2: An initial registration/certification procedure can be secure
+   where the messages from the end entity are authenticated via some
+   out-of-band means (e.g., a subsequent visit).
+
+4.2.1.3.  Location of Key Generation
+
+   In this specification, "key generation" is regarded as occurring
+   wherever either the public or private component of a key pair first
+   occurs in a PKIMessage.  Note that this does not preclude a
+   centralized key generation service; the actual key pair MAY have been
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 15]
+
+RFC 4210                          CMP                     September 2005
+
+
+   generated elsewhere and transported to the end entity, RA, or CA
+   using a (proprietary or standardized) key generation request/response
+   protocol (outside the scope of this specification).
+
+   Thus, there are three possibilities for the location of "key
+   generation":  the end entity, an RA, or a CA.
+
+4.2.1.4.  Confirmation of Successful Certification
+
+   Following the creation of an initial certificate for an end entity,
+   additional assurance can be gained by having the end entity
+   explicitly confirm successful receipt of the message containing (or
+   indicating the creation of) the certificate.  Naturally, this
+   confirmation message must be protected (based on the initial
+   authentication key or other means).
+
+   This gives two further possibilities: confirmed or not.
+
+4.2.2.  Mandatory Schemes
+
+   The criteria above allow for a large number of initial
+   registration/certification schemes.  This specification mandates that
+   conforming CA equipment, RA equipment, and EE equipment MUST support
+   the second scheme listed below (Section 4.2.2.2).  Any entity MAY
+   additionally support other schemes, if desired.
+
+4.2.2.1.  Centralized Scheme
+
+   In terms of the classification above, this scheme is, in some ways,
+   the simplest possible, where:
+
+   o  initiation occurs at the certifying CA;
+
+   o  no on-line message authentication is required;
+
+   o  "key generation" occurs at the certifying CA (see Section
+      4.2.1.3);
+
+   o  no confirmation message is required.
+
+   In terms of message flow, this scheme means that the only message
+   required is sent from the CA to the end entity.  The message must
+   contain the entire PSE for the end entity.  Some out-of-band means
+   must be provided to allow the end entity to authenticate the message
+   received and to decrypt any encrypted values.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 16]
+
+RFC 4210                          CMP                     September 2005
+
+
+4.2.2.2.  Basic Authenticated Scheme
+
+   In terms of the classification above, this scheme is where:
+
+   o  initiation occurs at the end entity;
+
+   o  message authentication is REQUIRED;
+
+   o  "key generation" occurs at the end entity (see Section 4.2.1.3);
+
+   o  a confirmation message is REQUIRED.
+
+   In terms of message flow, the basic authenticated scheme is as
+   follows:
+
+     End entity                                          RA/CA
+     ==========                                      =============
+          out-of-band distribution of Initial Authentication
+          Key (IAK) and reference value (RA/CA -> EE)
+     Key generation
+     Creation of certification request
+     Protect request with IAK
+                   -->>-- certification request -->>--
+                                                    verify request
+                                                    process request
+                                                    create response
+                   --<<-- certification response --<<--
+     handle response
+     create confirmation
+                   -->>-- cert conf message      -->>--
+                                                    verify confirmation
+                                                    create response
+                   --<<-- conf ack (optional)    --<<--
+     handle response
+
+   (Where verification of the cert confirmation message fails, the RA/CA
+   MUST revoke the newly issued certificate if it has been published or
+   otherwise made available.)
+
+4.3.  Proof-of-Possession (POP) of Private Key
+
+   In order to prevent certain attacks and to allow a CA/RA to properly
+   check the validity of the binding between an end entity and a key
+   pair, the PKI management operations specified here make it possible
+   for an end entity to prove that it has possession of (i.e., is able
+   to use) the private key corresponding to the public key for which a
+   certificate is requested.  A given CA/RA is free to choose how to
+   enforce POP (e.g., out-of-band procedural means versus PKIX-CMP
+
+
+
+Adams, et al.               Standards Track                    [Page 17]
+
+RFC 4210                          CMP                     September 2005
+
+
+   in-band messages) in its certification exchanges (i.e., this may be a
+   policy issue).  However, it is REQUIRED that CAs/RAs MUST enforce POP
+   by some means because there are currently many non-PKIX operational
+   protocols in use (various electronic mail protocols are one example)
+   that do not explicitly check the binding between the end entity and
+   the private key.  Until operational protocols that do verify the
+   binding (for signature, encryption, and key agreement key pairs)
+   exist, and are ubiquitous, this binding can only be assumed to have
+   been verified by the CA/RA.  Therefore, if the binding is not
+   verified by the CA/RA, certificates in the Internet Public-Key
+   Infrastructure end up being somewhat less meaningful.
+
+   POP is accomplished in different ways depending upon the type of key
+   for which a certificate is requested.  If a key can be used for
+   multiple purposes (e.g., an RSA key) then any appropriate method MAY
+
+   be used (e.g., a key that may be used for signing, as well as other
+   purposes, SHOULD NOT be sent to the CA/RA in order to prove
+   possession).
+
+   This specification explicitly allows for cases where an end entity
+   supplies the relevant proof to an RA and the RA subsequently attests
+   to the CA that the required proof has been received (and validated!).
+   For example, an end entity wishing to have a signing key certified
+   could send the appropriate signature to the RA, which then simply
+   notifies the relevant CA that the end entity has supplied the
+   required proof.  Of course, such a situation may be disallowed by
+   some policies (e.g., CAs may be the only entities permitted to verify
+   POP during certification).
+
+4.3.1.  Signature Keys
+
+   For signature keys, the end entity can sign a value to prove
+   possession of the private key.
+
+4.3.2.  Encryption Keys
+
+   For encryption keys, the end entity can provide the private key to
+   the CA/RA, or can be required to decrypt a value in order to prove
+   possession of the private key (see Section 5.2.8).  Decrypting a
+   value can be achieved either directly or indirectly.
+
+   The direct method is for the RA/CA to issue a random challenge to
+   which an immediate response by the EE is required.
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 18]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The indirect method is to issue a certificate that is encrypted for
+   the end entity (and have the end entity demonstrate its ability to
+   decrypt this certificate in the confirmation message).  This allows a
+   CA to issue a certificate in a form that can only be used by the
+   intended end entity.
+
+   This specification encourages use of the indirect method because it
+   requires no extra messages to be sent (i.e., the proof can be
+   demonstrated using the {request, response, confirmation} triple of
+   messages).
+
+4.3.3.  Key Agreement Keys
+
+   For key agreement keys, the end entity and the PKI management entity
+   (i.e., CA or RA) must establish a shared secret key in order to prove
+   that the end entity has possession of the private key.
+
+   Note that this need not impose any restrictions on the keys that can
+   be certified by a given CA.  In particular, for Diffie-Hellman keys
+   the end entity may freely choose its algorithm parameters provided
+   that the CA can generate a short-term (or one-time) key pair with the
+   appropriate parameters when necessary.
+
+4.4.  Root CA Key Update
+
+   This discussion only applies to CAs that are directly trusted by some
+   end entities.  Self-signed CAs SHALL be considered as directly
+   trusted CAs.  Recognizing whether a non-self-signed CA is supposed to
+   be directly trusted for some end entities is a matter of CA policy
+   and is thus beyond the scope of this document.
+
+   The basis of the procedure described here is that the CA protects its
+   new public key using its previous private key and vice versa.  Thus,
+   when a CA updates its key pair it must generate two extra
+   cACertificate attribute values if certificates are made available
+   using an X.500 directory (for a total of four: OldWithOld,
+   OldWithNew, NewWithOld, and NewWithNew).
+
+   When a CA changes its key pair, those entities who have acquired the
+   old CA public key via "out-of-band" means are most affected.  It is
+   these end entities who will need access to the new CA public key
+   protected with the old CA private key.  However, they will only
+   require this for a limited period (until they have acquired the new
+   CA public key via the "out-of-band" mechanism).  This will typically
+   be easily achieved when these end entities' certificates expire.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 19]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The data structure used to protect the new and old CA public keys is
+   a standard certificate (which may also contain extensions).  There
+   are no new data structures required.
+
+   Note 1.  This scheme does not make use of any of the X.509 v3
+   extensions as it must be able to work even for version 1
+   certificates.  The presence of the KeyIdentifier extension would make
+   for efficiency improvements.
+
+   Note 2.  While the scheme could be generalized to cover cases where
+   the CA updates its key pair more than once during the validity period
+   of one of its end entities' certificates, this generalization seems
+   of dubious value.  Not having this generalization simply means that
+   the validity periods of certificates issued with the old CA key pair
+   cannot exceed the end of the OldWithNew validity period.
+
+   Note 3.  This scheme ensures that end entities will acquire the new
+   CA public key, at the latest by the expiry of the last certificate
+   they owned that was signed with the old CA private key (via the
+   "out-of-band" means).  Certificate and/or key update operations
+   occurring at other times do not necessarily require this (depending
+   on the end entity's equipment).
+
+4.4.1.  CA Operator Actions
+
+   To change the key of the CA, the CA operator does the following:
+
+   1.  Generate a new key pair;
+
+   2.  Create a certificate containing the old CA public key signed with
+       the new private key (the "old with new" certificate);
+
+   3.  Create a certificate containing the new CA public key signed with
+       the old private key (the "new with old" certificate);
+
+   4.  Create a certificate containing the new CA public key signed with
+       the new private key (the "new with new" certificate);
+
+   5.  Publish these new certificates via the repository and/or other
+       means (perhaps using a CAKeyUpdAnn message);
+
+   6.  Export the new CA public key so that end entities may acquire it
+       using the "out-of-band" mechanism (if required).
+
+   The old CA private key is then no longer required.  However, the old
+   CA public key will remain in use for some time.  The old CA public
+   key is no longer required (other than for non-repudiation) when all
+   end entities of this CA have securely acquired the new CA public key.
+
+
+
+Adams, et al.               Standards Track                    [Page 20]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The "old with new" certificate must have a validity period starting
+   at the generation time of the old key pair and ending at the expiry
+   date of the old public key.
+
+   The "new with old" certificate must have a validity period starting
+   at the generation time of the new key pair and ending at the time by
+   which all end entities of this CA will securely possess the new CA
+   public key (at the latest, the expiry date of the old public key).
+
+   The "new with new" certificate must have a validity period starting
+   at the generation time of the new key pair and ending at or before
+   the time by which the CA will next update its key pair.
+
+4.4.2.  Verifying Certificates
+
+   Normally when verifying a signature, the verifier verifies (among
+   other things) the certificate containing the public key of the
+   signer.  However, once a CA is allowed to update its key there are a
+   range of new possibilities.  These are shown in the table below.
+
+                Repository contains NEW     Repository contains only OLD
+                  and OLD public keys        public key (due to, e.g.,
+                                              delay in publication)
+
+                   PSE      PSE Contains  PSE Contains    PSE Contains
+                Contains     OLD public    NEW public      OLD public
+               NEW public       key            key            key
+                   key
+
+    Signer's   Case 1:      Case 3:       Case 5:        Case 7:
+    certifi-   This is      In this case  Although the   In this case
+    cate is    the          the verifier  CA operator    the CA
+    protected  standard     must access   has not        operator  has
+    using NEW  case where   the           updated the    not updated
+    public     the          repository in repository the the repository
+    key        verifier     order to get  verifier can   and so the
+               can          the value of  verify the     verification
+               directly     the NEW       certificate    will FAIL
+               verify the   public key    directly -
+               certificate                this is thus
+               without                    the same as
+               using the                  case 1.
+               repository
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 21]
+
+RFC 4210                          CMP                     September 2005
+
+
+    Signer's   Case 2:      Case 4:       Case 6:        Case 8:
+    certifi-   In this      In this case  The verifier   Although the
+    cate is    case the     the verifier  thinks this    CA operator
+    protected  verifier     can directly  is the         has not
+    using OLD  must         verify the    situation of   updated the
+    public     access the   certificate   case 2 and     repository the
+    key        repository   without       will access    verifier can
+               in order     using the     the            verify the
+               to get the   repository    repository;    certificate
+               value of                   however, the   directly -
+               the OLD                    verification   this is thus
+               public key                 will FAIL      the same as
+                                                         case 4.
+
+4.4.2.1.  Verification in Cases 1, 4, 5, and 8
+
+   In these cases, the verifier has a local copy of the CA public key
+   that can be used to verify the certificate directly.  This is the
+   same as the situation where no key change has occurred.
+
+   Note that case 8 may arise between the time when the CA operator has
+   generated the new key pair and the time when the CA operator stores
+   the updated attributes in the repository.  Case 5 can only arise if
+
+   the CA operator has issued both the signer's and verifier's
+   certificates during this "gap" (the CA operator SHOULD avoid this as
+   it leads to the failure cases described below)
+
+4.4.2.2.  Verification in Case 2
+
+   In case 2, the verifier must get access to the old public key of the
+   CA.  The verifier does the following:
+
+   1.  Look up the caCertificate attribute in the repository and pick
+       the OldWithNew certificate (determined based on validity periods;
+       note that the subject and issuer fields must match);
+
+   2.  Verify that this is correct using the new CA key (which the
+       verifier has locally);
+
+   3.  If correct, check the signer's certificate using the old CA key.
+
+   Case 2 will arise when the CA operator has issued the signer's
+   certificate, then changed the key, and then issued the verifier's
+   certificate; so it is quite a typical case.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 22]
+
+RFC 4210                          CMP                     September 2005
+
+
+4.4.2.3.  Verification in Case 3
+
+   In case 3, the verifier must get access to the new public key of the
+   CA.  The verifier does the following:
+
+   1.  Look up the CACertificate attribute in the repository and pick
+       the NewWithOld certificate (determined based on validity periods;
+       note that the subject and issuer fields must match);
+
+   2.  Verify that this is correct using the old CA key (which the
+       verifier has stored locally);
+
+   3.  If correct, check the signer's certificate using the new CA key.
+
+   Case 3 will arise when the CA operator has issued the verifier's
+   certificate, then changed the key, and then issued the signer's
+   certificate; so it is also quite a typical case.
+
+4.4.2.4.  Failure of Verification in Case 6
+
+   In this case, the CA has issued the verifier's PSE, which contains
+   the new key, without updating the repository attributes.  This means
+   that the verifier has no means to get a trustworthy version of the
+   CA's old key and so verification fails.
+
+   Note that the failure is the CA operator's fault.
+
+4.4.2.5.  Failure of Verification in Case 7
+
+   In this case, the CA has issued the signer's certificate protected
+   with the new key without updating the repository attributes.  This
+   means that the verifier has no means to get a trustworthy version of
+   the CA's new key and so verification fails.
+
+   Note that the failure is again the CA operator's fault.
+
+4.4.3.  Revocation - Change of CA Key
+
+   As we saw above, the verification of a certificate becomes more
+   complex once the CA is allowed to change its key.  This is also true
+   for revocation checks as the CA may have signed the CRL using a newer
+   private key than the one within the user's PSE.
+
+   The analysis of the alternatives is the same as for certificate
+   verification.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 23]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.  Data Structures
+
+   This section contains descriptions of the data structures required
+   for PKI management messages.  Section 6 describes constraints on
+   their values and the sequence of events for each of the various PKI
+   management operations.
+
+5.1.  Overall PKI Message
+
+   All of the messages used in this specification for the purposes of
+   PKI management use the following structure:
+
+      PKIMessage ::= SEQUENCE {
+         header           PKIHeader,
+         body             PKIBody,
+         protection   [0] PKIProtection OPTIONAL,
+         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL
+     }
+     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
+
+   The PKIHeader contains information that is common to many PKI
+   messages.
+
+   The PKIBody contains message-specific information.
+
+   The PKIProtection, when used, contains bits that protect the PKI
+   message.
+
+   The extraCerts field can contain certificates that may be useful to
+   the recipient.  For example, this can be used by a CA or RA to
+   present an end entity with certificates that it needs to verify its
+   own new certificate (if, for example, the CA that issued the end
+   entity's certificate is not a root CA for the end entity).  Note that
+   this field does not necessarily contain a certification path; the
+   recipient may have to sort, select from, or otherwise process the
+   extra certificates in order to use them.
+
+5.1.1.  PKI Message Header
+
+   All PKI messages require some header information for addressing and
+   transaction identification.  Some of this information will also be
+   present in a transport-specific envelope.  However, if the PKI
+   message is protected, then this information is also protected (i.e.,
+   we make no assumption about secure transport).
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 24]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The following data structure is used to contain this information:
+
+     PKIHeader ::= SEQUENCE {
+         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
+         sender              GeneralName,
+         recipient           GeneralName,
+         messageTime     [0] GeneralizedTime         OPTIONAL,
+         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
+         senderKID       [2] KeyIdentifier           OPTIONAL,
+         recipKID        [3] KeyIdentifier           OPTIONAL,
+         transactionID   [4] OCTET STRING            OPTIONAL,
+         senderNonce     [5] OCTET STRING            OPTIONAL,
+         recipNonce      [6] OCTET STRING            OPTIONAL,
+         freeText        [7] PKIFreeText             OPTIONAL,
+         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
+                             InfoTypeAndValue     OPTIONAL
+     }
+     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
+
+   The pvno field is fixed (at 2) for this version of this
+   specification.
+
+   The sender field contains the name of the sender of the PKIMessage.
+   This name (in conjunction with senderKID, if supplied) should be
+   sufficient to indicate the key to use to verify the protection on the
+   message.  If nothing about the sender is known to the sending entity
+   (e.g., in the init. req. message, where the end entity may not know
+   its own Distinguished Name (DN), e-mail name, IP address, etc.), then
+   the "sender" field MUST contain a "NULL" value; that is, the SEQUENCE
+   OF relative distinguished names is of zero length.  In such a case,
+   the senderKID field MUST hold an identifier (i.e., a reference
+   number) that indicates to the receiver the appropriate shared secret
+   information to use to verify the message.
+
+   The recipient field contains the name of the recipient of the
+   PKIMessage.  This name (in conjunction with recipKID, if supplied)
+   should be usable to verify the protection on the message.
+
+   The protectionAlg field specifies the algorithm used to protect the
+   message.  If no protection bits are supplied (note that PKIProtection
+   is OPTIONAL) then this field MUST be omitted; if protection bits are
+   supplied, then this field MUST be supplied.
+
+   senderKID and recipKID are usable to indicate which keys have been
+   used to protect the message (recipKID will normally only be required
+   where protection of the message uses Diffie-Hellman (DH) keys).
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 25]
+
+RFC 4210                          CMP                     September 2005
+
+
+   These fields MUST be used if required to uniquely identify a key
+   (e.g., if more than one key is associated with a given sender name)
+   and SHOULD be omitted otherwise.
+
+   The transactionID field within the message header is to be used to
+   allow the recipient of a message to correlate this with an ongoing
+   transaction.  This is needed for all transactions that consist of
+   more than just a single request/response pair.  For transactions that
+   consist of a single request/response pair, the rules are as follows.
+   A client MAY populate the transactionID field of the request.  If a
+   server receives such a request that has the transactionID field set,
+   then it MUST set the transactionID field of the response to the same
+   value.  If a server receives such request with a missing
+   transactionID field, then it MAY set transactionID field of the
+   response.
+
+   For transactions that consist of more than just a single
+   request/response pair, the rules are as follows.  Clients SHOULD
+   generate a transactionID for the first request.  If a server receives
+   such a request that has the transactionID field set, then it MUST set
+   the transactionID field of the response to the same value.  If a
+   server receives such request with a missing transactionID field, then
+   it MUST populate the transactionID field of the response with a
+   server-generated ID.  Subsequent requests and responses MUST all set
+   the transactionID field to the thus established value.  In all cases
+   where a transactionID is being used, a given client MUST NOT have
+   more than one transaction with the same transactionID in progress at
+   any time (to a given server).  Servers are free to require uniqueness
+   of the transactionID or not, as long as they are able to correctly
+   associate messages with the corresponding transaction.  Typically,
+   this means that a server will require the {client, transactionID}
+   tuple to be unique, or even the transactionID alone to be unique, if
+   it cannot distinguish clients based on transport-level information.
+   A server receiving the first message of a transaction (which requires
+   more than a single request/response pair) that contains a
+   transactionID that does not allow it to meet the above constraints
+   (typically because the transactionID is already in use) MUST send
+   back an ErrorMsgContent with a PKIFailureInfo of transactionIdInUse.
+   It is RECOMMENDED that the clients fill the transactionID field with
+   128 bits of (pseudo-) random data for the start of a transaction to
+   reduce the probability of having the transactionID in use at the
+   server.
+
+   The senderNonce and recipNonce fields protect the PKIMessage against
+   replay attacks.  The senderNonce will typically be 128 bits of
+   (pseudo-) random data generated by the sender, whereas the recipNonce
+   is copied from the senderNonce of the previous message in the
+   transaction.
+
+
+
+Adams, et al.               Standards Track                    [Page 26]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The messageTime field contains the time at which the sender created
+   the message.  This may be useful to allow end entities to
+   correct/check their local time for consistency with the time on a
+   central system.
+
+   The freeText field may be used to send a human-readable message to
+   the recipient (in any number of languages).  The first language used
+   in this sequence indicates the desired language for replies.
+
+   The generalInfo field may be used to send machine-processable
+   additional data to the recipient.  The following generalInfo
+   extensions are defined and MAY be supported.
+
+5.1.1.1.  ImplicitConfirm
+
+   This is used by the EE to inform the CA that it does not wish to send
+   a certificate confirmation for issued certificates.
+
+         implicitConfirm OBJECT IDENTIFIER ::= {id-it 13}
+         ImplicitConfirmValue ::= NULL
+
+   If the CA grants the request to the EE, it MUST put the same
+   extension in the PKIHeader of the response.  If the EE does not find
+   the extension in the response, it MUST send the certificate
+   confirmation.
+
+5.1.1.2.  ConfirmWaitTime
+
+   This is used by the CA to inform the EE how long it intends to wait
+   for the certificate confirmation before revoking the certificate and
+   deleting the transaction.
+
+         confirmWaitTime OBJECT IDENTIFIER ::= {id-it 14}
+         ConfirmWaitTimeValue ::= GeneralizedTime
+
+5.1.2.  PKI Message Body
+
+        PKIBody ::= CHOICE {
+          ir       [0]  CertReqMessages,       --Initialization Req
+          ip       [1]  CertRepMessage,        --Initialization Resp
+          cr       [2]  CertReqMessages,       --Certification Req
+          cp       [3]  CertRepMessage,        --Certification Resp
+          p10cr    [4]  CertificationRequest,  --PKCS #10 Cert.  Req.
+          popdecc  [5]  POPODecKeyChallContent --pop Challenge
+          popdecr  [6]  POPODecKeyRespContent, --pop Response
+          kur      [7]  CertReqMessages,       --Key Update Request
+          kup      [8]  CertRepMessage,        --Key Update Response
+          krr      [9]  CertReqMessages,       --Key Recovery Req
+
+
+
+Adams, et al.               Standards Track                    [Page 27]
+
+RFC 4210                          CMP                     September 2005
+
+
+          krp      [10] KeyRecRepContent,      --Key Recovery Resp
+          rr       [11] RevReqContent,         --Revocation Request
+          rp       [12] RevRepContent,         --Revocation Response
+          ccr      [13] CertReqMessages,       --Cross-Cert.  Request
+          ccp      [14] CertRepMessage,        --Cross-Cert.  Resp
+          ckuann   [15] CAKeyUpdAnnContent,    --CA Key Update Ann.
+          cann     [16] CertAnnContent,        --Certificate Ann.
+          rann     [17] RevAnnContent,         --Revocation Ann.
+          crlann   [18] CRLAnnContent,         --CRL Announcement
+          pkiconf  [19] PKIConfirmContent,     --Confirmation
+          nested   [20] NestedMessageContent,  --Nested Message
+          genm     [21] GenMsgContent,         --General Message
+          genp     [22] GenRepContent,         --General Response
+          error    [23] ErrorMsgContent,       --Error Message
+          certConf [24] CertConfirmContent,    --Certificate confirm
+          pollReq  [25] PollReqContent,        --Polling request
+          pollRep  [26] PollRepContent         --Polling response
+          }
+
+   The specific types are described in Section 5.3 below.
+
+5.1.3.  PKI Message Protection
+
+   Some PKI messages will be protected for integrity.  (Note that if an
+   asymmetric algorithm is used to protect a message and the relevant
+   public component has been certified already, then the origin of the
+   message can also be authenticated.  On the other hand, if the public
+   component is uncertified, then the message origin cannot be
+   automatically authenticated, but may be authenticated via out-of-band
+   means.)
+
+   When protection is applied, the following structure is used:
+
+        PKIProtection ::= BIT STRING
+
+   The input to the calculation of PKIProtection is the DER encoding of
+   the following data structure:
+
+        ProtectedPart ::= SEQUENCE {
+            header    PKIHeader,
+            body      PKIBody
+        }
+
+   There MAY be cases in which the PKIProtection BIT STRING is
+   deliberately not used to protect a message (i.e., this OPTIONAL field
+   is omitted) because other protection, external to PKIX, will be
+   applied instead.  Such a choice is explicitly allowed in this
+   specification.  Examples of such external protection include PKCS #7
+
+
+
+Adams, et al.               Standards Track                    [Page 28]
+
+RFC 4210                          CMP                     September 2005
+
+
+   [PKCS7] and Security Multiparts [RFC1847] encapsulation of the
+   PKIMessage (or simply the PKIBody (omitting the CHOICE tag), if the
+   relevant PKIHeader information is securely carried in the external
+   mechanism).  It is noted, however, that many such external mechanisms
+   require that the end entity already possesses a public-key
+   certificate, and/or a unique Distinguished Name, and/or other such
+   infrastructure-related information.  Thus, they may not be
+   appropriate for initial registration, key-recovery, or any other
+   process with "boot-strapping" characteristics.  For those cases it
+   may be necessary that the PKIProtection parameter be used.  In the
+   future, if/when external mechanisms are modified to accommodate
+   boot-strapping scenarios, the use of PKIProtection may become rare or
+   non-existent.
+
+   Depending on the circumstances, the PKIProtection bits may contain a
+   Message Authentication Code (MAC) or signature.  Only the following
+   cases can occur:
+
+5.1.3.1.  Shared Secret Information
+
+   In this case, the sender and recipient share secret information
+   (established via out-of-band means or from a previous PKI management
+   operation).  PKIProtection will contain a MAC value and the
+   protectionAlg will be the following (see also Appendix D.2):
+
+     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
+     PBMParameter ::= SEQUENCE {
+       salt                OCTET STRING,
+       owf                 AlgorithmIdentifier,
+       iterationCount      INTEGER,
+       mac                 AlgorithmIdentifier
+     }
+
+   In the above protectionAlg, the salt value is appended to the shared
+   secret input.  The OWF is then applied iterationCount times, where
+   the salted secret is the input to the first iteration and, for each
+   successive iteration, the input is set to be the output of the
+   previous iteration.  The output of the final iteration (called
+   "BASEKEY" for ease of reference, with a size of "H") is what is used
+   to form the symmetric key.  If the MAC algorithm requires a K-bit key
+   and K <= H, then the most significant K bits of BASEKEY are used.  If
+   K > H, then all of BASEKEY is used for the most significant H bits of
+   the key, OWF("1" || BASEKEY) is used for the next most significant H
+   bits of the key, OWF("2" || BASEKEY) is used for the next most
+   significant H bits of the key, and so on, until all K bits have been
+   derived.  [Here "N" is the ASCII byte encoding the number N and "||"
+   represents concatenation.]
+
+
+
+
+Adams, et al.               Standards Track                    [Page 29]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Note: it is RECOMMENDED that the fields of PBMParameter remain
+   constant throughout the messages of a single transaction (e.g.,
+   ir/ip/certConf/pkiConf) in order to reduce the overhead associated
+   with PasswordBasedMac computation).
+
+5.1.3.2.  DH Key Pairs
+
+   Where the sender and receiver possess Diffie-Hellman certificates
+   with compatible DH parameters, in order to protect the message the
+   end entity must generate a symmetric key based on its private DH key
+   value and the DH public key of the recipient of the PKI message.
+   PKIProtection will contain a MAC value keyed with this derived
+   symmetric key and the protectionAlg will be the following:
+
+        id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
+
+        DHBMParameter ::= SEQUENCE {
+            owf                 AlgorithmIdentifier,
+            -- AlgId for a One-Way Function (SHA-1 recommended)
+            mac                 AlgorithmIdentifier
+            -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+        }   -- or HMAC [RFC2104, RFC2202])
+
+   In the above protectionAlg, OWF is applied to the result of the
+   Diffie-Hellman computation.  The OWF output (called "BASEKEY" for
+   ease of reference, with a size of "H") is what is used to form the
+   symmetric key.  If the MAC algorithm requires a K-bit key and K <= H,
+   then the most significant K bits of BASEKEY are used.  If K > H, then
+   all of BASEKEY is used for the most significant H bits of the key,
+   OWF("1" || BASEKEY) is used for the next most significant H bits of
+   the key, OWF("2" || BASEKEY) is used for the next most significant H
+   bits of the key, and so on, until all K bits have been derived.
+   [Here "N" is the ASCII byte encoding the number N and "||" represents
+   concatenation.]
+
+5.1.3.3.  Signature
+
+   In this case, the sender possesses a signature key pair and simply
+   signs the PKI message.  PKIProtection will contain the signature
+   value and the protectionAlg will be an AlgorithmIdentifier for a
+   digital signature (e.g., md5WithRSAEncryption or dsaWithSha-1).
+
+5.1.3.4.  Multiple Protection
+
+   In cases where an end entity sends a protected PKI message to an RA,
+   the RA MAY forward that message to a CA, attaching its own protection
+   (which MAY be a MAC or a signature, depending on the information and
+   certificates shared between the RA and the CA).  This is accomplished
+
+
+
+Adams, et al.               Standards Track                    [Page 30]
+
+RFC 4210                          CMP                     September 2005
+
+
+   by nesting the entire message sent by the end entity within a new PKI
+   message.  The structure used is as follows.
+
+          NestedMessageContent ::= PKIMessages
+
+   (The use of PKIMessages, a SEQUENCE OF PKIMessage, lets the RA batch
+   the requests of several EEs in a single new message.  For simplicity,
+   all messages in the batch MUST be of the same type (e.g., ir).)  If
+   the RA wishes to modify the message(s) in some way (e.g., add
+   particular field values or new extensions), then it MAY create its
+   own desired PKIBody.  The original PKIMessage from the EE MAY be
+   included in the generalInfo field of PKIHeader (to accommodate, for
+   example, cases in which the CA wishes to check POP or other
+   information on the original EE message).  The infoType to be used in
+   this situation is {id-it 15} (see Section 5.3.19 for the value of
+   id-it) and the infoValue is PKIMessages (contents MUST be in the same
+   order as the requests in PKIBody).
+
+5.2.  Common Data Structures
+
+   Before specifying the specific types that may be placed in a PKIBody,
+   we define some data structures that are used in more than one case.
+
+5.2.1.  Requested Certificate Contents
+
+   Various PKI management messages require that the originator of the
+   message indicate some of the fields that are required to be present
+   in a certificate.  The CertTemplate structure allows an end entity or
+   RA to specify as much as it wishes about the certificate it requires.
+   CertTemplate is identical to a Certificate, but with all fields
+   optional.
+
+   Note that even if the originator completely specifies the contents of
+   a certificate it requires, a CA is free to modify fields within the
+   certificate actually issued.  If the modified certificate is
+   unacceptable to the requester, the requester MUST send back a
+   certConf message that either does not include this certificate (via a
+   CertHash), or does include this certificate (via a CertHash) along
+   with a status of "rejected".  See Section 5.3.18 for the definition
+   and use of CertHash and the certConf message.
+
+   See Appendix C and [CRMF] for CertTemplate syntax.
+
+5.2.2.  Encrypted Values
+
+   Where encrypted values (restricted, in this specification, to be
+   either private keys or certificates) are sent in PKI messages, the
+   EncryptedValue data structure is used.
+
+
+
+Adams, et al.               Standards Track                    [Page 31]
+
+RFC 4210                          CMP                     September 2005
+
+
+   See [CRMF] for EncryptedValue syntax.
+
+   Use of this data structure requires that the creator and intended
+   recipient be able to encrypt and decrypt, respectively.  Typically,
+   this will mean that the sender and recipient have, or are able to
+   generate, a shared secret key.
+
+   If the recipient of the PKIMessage already possesses a private key
+   usable for decryption, then the encSymmKey field MAY contain a
+   session key encrypted using the recipient's public key.
+
+5.2.3.  Status codes and Failure Information for PKI Messages
+
+   All response messages will include some status information.  The
+   following values are defined.
+
+        PKIStatus ::= INTEGER {
+            accepted               (0),
+            grantedWithMods        (1),
+            rejection              (2),
+            waiting                (3),
+            revocationWarning      (4),
+            revocationNotification (5),
+            keyUpdateWarning       (6)
+        }
+
+   Responders may use the following syntax to provide more information
+   about failure cases.
+
+        PKIFailureInfo ::= BIT STRING {
+            badAlg              (0),
+            badMessageCheck     (1),
+            badRequest          (2),
+            badTime             (3),
+            badCertId           (4),
+            badDataFormat       (5),
+            wrongAuthority      (6),
+            incorrectData       (7),
+            missingTimeStamp    (8),
+            badPOP              (9),
+            certRevoked         (10),
+            certConfirmed       (11),
+            wrongIntegrity      (12),
+            badRecipientNonce   (13),
+            timeNotAvailable    (14),
+            unacceptedPolicy    (15),
+            unacceptedExtension (16),
+            addInfoNotAvailable (17),
+
+
+
+Adams, et al.               Standards Track                    [Page 32]
+
+RFC 4210                          CMP                     September 2005
+
+
+            badSenderNonce      (18),
+            badCertTemplate     (19),
+            signerNotTrusted    (20),
+            transactionIdInUse  (21),
+            unsupportedVersion  (22),
+            notAuthorized       (23),
+            systemUnavail       (24),
+            systemFailure       (25),
+            duplicateCertReq    (26)
+        }
+
+        PKIStatusInfo ::= SEQUENCE {
+            status        PKIStatus,
+            statusString  PKIFreeText     OPTIONAL,
+            failInfo      PKIFailureInfo  OPTIONAL
+        }
+
+5.2.4.  Certificate Identification
+
+   In order to identify particular certificates, the CertId data
+   structure is used.
+
+   See [CRMF] for CertId syntax.
+
+5.2.5.  Out-of-band root CA Public Key
+
+   Each root CA must be able to publish its current public key via some
+   "out-of-band" means.  While such mechanisms are beyond the scope of
+   this document, we define data structures that can support such
+   mechanisms.
+
+   There are generally two methods available: either the CA directly
+   publishes its self-signed certificate, or this information is
+   available via the Directory (or equivalent) and the CA publishes a
+   hash of this value to allow verification of its integrity before use.
+
+        OOBCert ::= Certificate
+
+   The fields within this certificate are restricted as follows:
+
+   o  The certificate MUST be self-signed (i.e., the signature must be
+      verifiable using the SubjectPublicKeyInfo field);
+
+   o  The subject and issuer fields MUST be identical;
+
+   o  If the subject field is NULL, then both subjectAltNames and
+      issuerAltNames extensions MUST be present and have exactly the
+      same value;
+
+
+
+Adams, et al.               Standards Track                    [Page 33]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  The values of all other extensions must be suitable for a self-
+      signed certificate (e.g., key identifiers for subject and issuer
+      must be the same).
+
+        OOBCertHash ::= SEQUENCE {
+            hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
+            certId      [1] CertId                  OPTIONAL,
+            hashVal         BIT STRING
+        }
+
+   The intention of the hash value is that anyone who has securely
+   received the hash value (via the out-of-band means) can verify a
+   self-signed certificate for that CA.
+
+5.2.6.  Archive Options
+
+   Requesters may indicate that they wish the PKI to archive a private
+   key value using the PKIArchiveOptions structure.
+
+   See [CRMF] for PKIArchiveOptions syntax.
+
+5.2.7.  Publication Information
+
+   Requesters may indicate that they wish the PKI to publish a
+   certificate using the PKIPublicationInfo structure.
+
+   See [CRMF] for PKIPublicationInfo syntax.
+
+5.2.8.  Proof-of-Possession Structures
+
+   If the certification request is for a signing key pair (i.e., a
+   request for a verification certificate), then the proof-of-possession
+   of the private signing key is demonstrated through use of the
+   POPOSigningKey structure.
+
+   See Appendix C and [CRMF] for POPOSigningKey syntax, but note that
+   POPOSigningKeyInput has the following semantic stipulations in this
+   specification.
+
+        POPOSigningKeyInput ::= SEQUENCE {
+            authInfo            CHOICE {
+                sender              [0] GeneralName,
+                publicKeyMAC            PKMACValue
+            },
+            publicKey           SubjectPublicKeyInfo
+        }
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 34]
+
+RFC 4210                          CMP                     September 2005
+
+
+   On the other hand, if the certification request is for an encryption
+   key pair (i.e., a request for an encryption certificate), then the
+   proof-of-possession of the private decryption key may be demonstrated
+   in one of three ways.
+
+5.2.8.1.  Inclusion of the Private Key
+
+   By the inclusion of the private key (encrypted) in the CertRequest
+   (in the thisMessage field of POPOPrivKey (see Appendix C) or in the
+   PKIArchiveOptions control structure, depending upon whether or not
+   archival of the private key is also desired).
+
+5.2.8.2.  Indirect Method
+
+   By having the CA return not the certificate, but an encrypted
+   certificate (i.e., the certificate encrypted under a randomly-
+   generated symmetric key, and the symmetric key encrypted under the
+   public key for which the certification request is being made) -- this
+   is the "indirect" method mentioned previously in Section 4.3.2. The
+   end entity proves knowledge of the private decryption key to the CA
+   by providing the correct CertHash for this certificate in the
+   certConf message.  This demonstrates POP because the EE can only
+   compute the correct CertHash if it is able to recover the
+   certificate, and it can only recover the certificate if it is able to
+   decrypt the symmetric key using the required private key.  Clearly,
+   for this to work, the CA MUST NOT publish the certificate until the
+   certConf message arrives (when certHash is to be used to demonstrate
+   POP).  See Section 5.3.18 for further details.
+
+5.2.8.3.  Challenge-Response Protocol
+
+   By having the end entity engage in a challenge-response protocol
+   (using the messages POPODecKeyChall and POPODecKeyResp; see below)
+   between CertReqMessages and CertRepMessage -- this is the "direct"
+   method mentioned previously in Section 4.3.2.  (This method would
+   typically be used in an environment in which an RA verifies POP and
+   then makes a certification request to the CA on behalf of the end
+   entity.  In such a scenario, the CA trusts the RA to have done POP
+   correctly before the RA requests a certificate for the end entity.)
+   The complete protocol then looks as follows (note that req' does not
+   necessarily encapsulate req as a nested message):
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 35]
+
+RFC 4210                          CMP                     September 2005
+
+
+                   EE            RA            CA
+                    ---- req ---->
+                    <--- chall ---
+                    ---- resp --->
+                                  ---- req' --->
+                                  <--- rep -----
+                                  ---- conf --->
+                                  <--- ack -----
+                    <--- rep -----
+                    ---- conf --->
+                    <--- ack -----
+
+   This protocol is obviously much longer than the 3-way exchange given
+   in choice (2) above, but allows a local Registration Authority to be
+   involved and has the property that the certificate itself is not
+   actually created until the proof-of-possession is complete.  In some
+   environments, a different order of the above messages may be
+   required, such as the following (this may be determined by policy):
+
+                   EE            RA            CA
+                    ---- req ---->
+                    <--- chall ---
+                    ---- resp --->
+                                  ---- req' --->
+                                  <--- rep -----
+                    <--- rep -----
+                    ---- conf --->
+                                  ---- conf --->
+                                  <--- ack -----
+                    <--- ack -----
+
+   If the cert. request is for a key agreement key (KAK) pair, then the
+   POP can use any of the 3 ways described above for enc. key pairs,
+   with the following changes: (1) the parenthetical text of bullet 2)
+   is replaced with "(i.e., the certificate encrypted under the
+   symmetric key derived from the CA's private KAK and the public key
+   for which the certification request is being made)"; (2) the first
+   parenthetical text of the challenge field of "Challenge" below is
+   replaced with "(using PreferredSymmAlg (see Section 5.3.19.4 and
+   Appendix E.5) and a symmetric key derived from the CA's private KAK
+   and the public key for which the certification request is being
+   made)".  Alternatively, the POP can use the POPOSigningKey structure
+   given in [CRMF] (where the alg field is DHBasedMAC and the signature
+   field is the MAC) as a fourth alternative for demonstrating POP if
+   the CA already has a D-H certificate that is known to the EE.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 36]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The challenge-response messages for proof-of-possession of a private
+   decryption key are specified as follows (see [MvOV97], p.404 for
+   details).  Note that this challenge-response exchange is associated
+   with the preceding cert. request message (and subsequent cert.
+   response and confirmation messages) by the transactionID used in the
+   PKIHeader and by the protection (MACing or signing) applied to the
+   PKIMessage.
+
+        POPODecKeyChallContent ::= SEQUENCE OF Challenge
+        Challenge ::= SEQUENCE {
+            owf                 AlgorithmIdentifier  OPTIONAL,
+            witness             OCTET STRING,
+            challenge           OCTET STRING
+        }
+
+   Note that the size of Rand needs to be appropriate for encryption
+   under the public key of the requester.  Given that "int" will
+   typically not be longer than 64 bits, this leaves well over 100 bytes
+   of room for the "sender" field when the modulus is 1024 bits.  If, in
+   some environment, names are so long that they cannot fit (e.g., very
+   long DNs), then whatever portion will fit should be used (as long as
+   it includes at least the common name, and as long as the receiver is
+   able to deal meaningfully with the abbreviation).
+
+        POPODecKeyRespContent ::= SEQUENCE OF INTEGER
+
+5.2.8.4.  Summary of PoP Options
+
+   The text in this section provides several options with respect to POP
+   techniques.  Using "SK" for "signing key", "EK" for "encryption key",
+   and "KAK" for "key agreement key", the techniques may be summarized
+   as follows:
+
+         RAVerified;
+         SKPOP;
+         EKPOPThisMessage;
+         KAKPOPThisMessage;
+         KAKPOPThisMessageDHMAC;
+         EKPOPEncryptedCert;
+         KAKPOPEncryptedCert;
+         EKPOPChallengeResp; and
+         KAKPOPChallengeResp.
+
+   Given this array of options, it is natural to ask how an end entity
+   can know what is supported by the CA/RA (i.e., which options it may
+   use when requesting certificates).  The following guidelines should
+   clarify this situation for EE implementers.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 37]
+
+RFC 4210                          CMP                     September 2005
+
+
+   RAVerified.  This is not an EE decision; the RA uses this if and only
+   if it has verified POP before forwarding the request on to the CA, so
+   it is not possible for the EE to choose this technique.
+
+   SKPOP.  If the EE has a signing key pair, this is the only POP method
+   specified for use in the request for a corresponding certificate.
+
+   EKPOPThisMessage and KAKPOPThisMessage.  Whether or not to give up
+   its private key to the CA/RA is an EE decision.  If the EE decides to
+   reveal its key, then these are the only POP methods available in this
+   specification to achieve this (and the key pair type will determine
+   which of these two methods to use).
+
+   KAKPOPThisMessageDHMAC.  The EE can only use this method if (1) the
+   CA has a DH certificate available for this purpose, and (2) the EE
+   already has a copy of this certificate.  If both these conditions
+   hold, then this technique is clearly supported and may be used by the
+   EE, if desired.
+
+   EKPOPEncryptedCert, KAKPOPEncryptedCert, EKPOPChallengeResp,
+   KAKPOPChallengeResp.  The EE picks one of these (in the
+   subsequentMessage field) in the request message, depending upon
+   preference and key pair type.  The EE is not doing POP at this point;
+   it is simply indicating which method it wants to use.  Therefore, if
+   the CA/RA replies with a "badPOP" error, the EE can re-request using
+   the other POP method chosen in subsequentMessage.  Note, however,
+   that this specification encourages the use of the EncryptedCert
+   choice and, furthermore, says that the challenge-response would
+   typically be used when an RA is involved and doing POP verification.
+   Thus, the EE should be able to make an intelligent decision regarding
+   which of these POP methods to choose in the request message.
+
+5.3.  Operation-Specific Data Structures
+
+5.3.1.  Initialization Request
+
+   An Initialization request message contains as the PKIBody a
+   CertReqMessages data structure, which specifies the requested
+   certificate(s).  Typically, SubjectPublicKeyInfo, KeyId, and Validity
+   are the template fields which may be supplied for each certificate
+   requested (see Appendix D profiles for further information).  This
+   message is intended to be used for entities when first initializing
+   into the PKI.
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 38]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.2.  Initialization Response
+
+   An Initialization response message contains as the PKIBody an
+   CertRepMessage data structure, which has for each certificate
+   requested a PKIStatusInfo field, a subject certificate, and possibly
+   a private key (normally encrypted with a session key, which is itself
+   encrypted with the protocolEncrKey).
+
+   See Section 5.3.4 for CertRepMessage syntax.  Note that if the PKI
+   Message Protection is "shared secret information" (see Section
+   5.1.3), then any certificate transported in the caPubs field may be
+   directly trusted as a root CA certificate by the initiator.
+
+5.3.3.  Certification Request
+
+   A Certification request message contains as the PKIBody a
+   CertReqMessages data structure, which specifies the requested
+   certificates.  This message is intended to be used for existing PKI
+   entities who wish to obtain additional certificates.
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+   Alternatively, the PKIBody MAY be a CertificationRequest (this
+   structure is fully specified by the ASN.1 structure
+   CertificationRequest given in [PKCS10]).  This structure may be
+   required for certificate requests for signing key pairs when
+   interoperation with legacy systems is desired, but its use is
+   strongly discouraged whenever not absolutely necessary.
+
+5.3.4.  Certification Response
+
+   A Certification response message contains as the PKIBody a
+   CertRepMessage data structure, which has a status value for each
+   certificate requested, and optionally has a CA public key, failure
+   information, a subject certificate, and an encrypted private key.
+
+     CertRepMessage ::= SEQUENCE {
+         caPubs          [1] SEQUENCE SIZE (1..MAX) OF Certificate
+                             OPTIONAL,
+         response            SEQUENCE OF CertResponse
+     }
+
+     CertResponse ::= SEQUENCE {
+         certReqId           INTEGER,
+         status              PKIStatusInfo,
+         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
+         rspInfo             OCTET STRING        OPTIONAL
+         -- analogous to the id-regInfo-utf8Pairs string defined
+
+
+
+Adams, et al.               Standards Track                    [Page 39]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- for regInfo in CertReqMsg [CRMF]
+     }
+
+     CertifiedKeyPair ::= SEQUENCE {
+         certOrEncCert       CertOrEncCert,
+         privateKey      [0] EncryptedValue      OPTIONAL,
+         -- see [CRMF] for comment on encoding
+         publicationInfo [1] PKIPublicationInfo  OPTIONAL
+     }
+
+     CertOrEncCert ::= CHOICE {
+         certificate     [0] Certificate,
+         encryptedCert   [1] EncryptedValue
+     }
+
+   Only one of the failInfo (in PKIStatusInfo) and certificate (in
+   CertifiedKeyPair) fields can be present in each CertResponse
+   (depending on the status).  For some status values (e.g., waiting),
+   neither of the optional fields will be present.
+
+   Given an EncryptedCert and the relevant decryption key, the
+   certificate may be obtained.  The purpose of this is to allow a CA to
+   return the value of a certificate, but with the constraint that only
+   the intended recipient can obtain the actual certificate.  The
+   benefit of this approach is that a CA may reply with a certificate
+   even in the absence of a proof that the requester is the end entity
+   that can use the relevant private key (note that the proof is not
+   obtained until the certConf message is received by the CA).  Thus,
+   the CA will not have to revoke that certificate in the event that
+   something goes wrong with the proof-of-possession (but MAY do so
+   anyway, depending upon policy).
+
+5.3.5.  Key Update Request Content
+
+   For key update requests the CertReqMessages syntax is used.
+   Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template
+   fields that may be supplied for each key to be updated.  This message
+   is intended to be used to request updates to existing (non-revoked
+   and non-expired) certificates (therefore, it is sometimes referred to
+   as a "Certificate Update" operation).  An update is a replacement
+   certificate containing either a new subject public key or the current
+   subject public key (although the latter practice may not be
+   appropriate for some environments).
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 40]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.6.  Key Update Response Content
+
+   For key update responses, the CertRepMessage syntax is used.  The
+   response is identical to the initialization response.
+
+   See Section 5.3.4 for CertRepMessage syntax.
+
+5.3.7.  Key Recovery Request Content
+
+   For key recovery requests the syntax used is identical to the
+   initialization request CertReqMessages.  Typically,
+   SubjectPublicKeyInfo and KeyId are the template fields that may be
+   used to supply a signature public key for which a certificate is
+   required (see Appendix D profiles for further information).
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.  Note that if a
+   key history is required, the requester must supply a Protocol
+   Encryption Key control in the request message.
+
+5.3.8.  Key Recovery Response Content
+
+   For key recovery responses, the following syntax is used.  For some
+   status values (e.g., waiting) none of the optional fields will be
+   present.
+
+    KeyRecRepContent ::= SEQUENCE {
+        status          PKIStatusInfo,
+        newSigCert  [0] Certificate                   OPTIONAL,
+        caCerts     [1] SEQUENCE SIZE (1..MAX) OF
+                                     Certificate      OPTIONAL,
+        keyPairHist [2] SEQUENCE SIZE (1..MAX) OF
+                                     CertifiedKeyPair OPTIONAL
+    }
+
+5.3.9.  Revocation Request Content
+
+   When requesting revocation of a certificate (or several
+   certificates), the following data structure is used.  The name of the
+   requester is present in the PKIHeader structure.
+
+    RevReqContent ::= SEQUENCE OF RevDetails
+
+    RevDetails ::= SEQUENCE {
+        certDetails         CertTemplate,
+        crlEntryDetails     Extensions       OPTIONAL
+    }
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 41]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.10.  Revocation Response Content
+
+   The revocation response is the response to the above message.  If
+   produced, this is sent to the requester of the revocation.  (A
+   separate revocation announcement message MAY be sent to the subject
+   of the certificate for which revocation was requested.)
+
+     RevRepContent ::= SEQUENCE {
+         status        SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+         revCerts  [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
+         crls      [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+                       OPTIONAL
+     }
+
+5.3.11.  Cross Certification Request Content
+
+   Cross certification requests use the same syntax (CertReqMessages) as
+   normal certification requests, with the restriction that the key pair
+   MUST have been generated by the requesting CA and the private key
+   MUST NOT be sent to the responding CA.  This request MAY also be used
+   by subordinate CAs to get their certificates signed by the parent CA.
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+5.3.12.  Cross Certification Response Content
+
+   Cross certification responses use the same syntax (CertRepMessage) as
+   normal certification responses, with the restriction that no
+   encrypted private key can be sent.
+
+   See Section 5.3.4 for CertRepMessage syntax.
+
+5.3.13.  CA Key Update Announcement Content
+
+   When a CA updates its own key pair, the following data structure MAY
+   be used to announce this event.
+
+    CAKeyUpdAnnContent ::= SEQUENCE {
+       oldWithNew         Certificate,
+       newWithOld         Certificate,
+       newWithNew         Certificate
+    }
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 42]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.14.  Certificate Announcement
+
+   This structure MAY be used to announce the existence of certificates.
+
+   Note that this message is intended to be used for those cases (if
+   any) where there is no pre-existing method for publication of
+   certificates; it is not intended to be used where, for example, X.500
+   is the method for publication of certificates.
+
+        CertAnnContent ::= Certificate
+
+5.3.15.  Revocation Announcement
+
+   When a CA has revoked, or is about to revoke, a particular
+   certificate, it MAY issue an announcement of this (possibly upcoming)
+   event.
+
+        RevAnnContent ::= SEQUENCE {
+            status              PKIStatus,
+            certId              CertId,
+            willBeRevokedAt     GeneralizedTime,
+            badSinceDate        GeneralizedTime,
+            crlDetails          Extensions  OPTIONAL
+        }
+
+   A CA MAY use such an announcement to warn (or notify) a subject that
+   its certificate is about to be (or has been) revoked.  This would
+   typically be used where the request for revocation did not come from
+   the subject concerned.
+
+   The willBeRevokedAt field contains the time at which a new entry will
+   be added to the relevant CRLs.
+
+5.3.16.  CRL Announcement
+
+   When a CA issues a new CRL (or set of CRLs) the following data
+   structure MAY be used to announce this event.
+
+        CRLAnnContent ::= SEQUENCE OF CertificateList
+
+5.3.17.  PKI Confirmation Content
+
+   This data structure is used in the protocol exchange as the final
+   PKIMessage.  Its content is the same in all cases -- actually there
+   is no content since the PKIHeader carries all the required
+   information.
+
+        PKIConfirmContent ::= NULL
+
+
+
+Adams, et al.               Standards Track                    [Page 43]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Use of this message for certificate confirmation is NOT RECOMMENDED;
+   certConf SHOULD be used instead.  Upon receiving a PKIConfirm for a
+   certificate response, the recipient MAY treat it as a certConf with
+   all certificates being accepted.
+
+5.3.18.  Certificate Confirmation Content
+
+   This data structure is used by the client to send a confirmation to
+   the CA/RA to accept or reject certificates.
+
+         CertConfirmContent ::= SEQUENCE OF CertStatus
+
+         CertStatus ::= SEQUENCE {
+            certHash    OCTET STRING,
+            certReqId   INTEGER,
+            statusInfo  PKIStatusInfo OPTIONAL
+         }
+
+   For any particular CertStatus, omission of the statusInfo field
+   indicates ACCEPTANCE of the specified certificate.  Alternatively,
+   explicit status details (with respect to acceptance or rejection) MAY
+   be provided in the statusInfo field, perhaps for auditing purposes at
+   the CA/RA.
+
+   Within CertConfirmContent, omission of a CertStatus structure
+   corresponding to a certificate supplied in the previous response
+   message indicates REJECTION of the certificate.  Thus, an empty
+   CertConfirmContent (a zero-length SEQUENCE) MAY be used to indicate
+   rejection of all supplied certificates.  See Section 5.2.8, item (2),
+   for a discussion of the certHash field with respect to proof-of-
+   possession.
+
+5.3.19.  PKI General Message Content
+
+     InfoTypeAndValue ::= SEQUENCE {
+         infoType               OBJECT IDENTIFIER,
+         infoValue              ANY DEFINED BY infoType  OPTIONAL
+     }
+     -- where {id-it} = {id-pkix 4} = {1 3 6 1 5 5 7 4}
+     GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
+
+5.3.19.1.  CA Protocol Encryption Certificate
+
+   This MAY be used by the EE to get a certificate from the CA to use to
+   protect sensitive information during the protocol.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 44]
+
+RFC 4210                          CMP                     September 2005
+
+
+      GenMsg:    {id-it 1}, < absent >
+      GenRep:    {id-it 1}, Certificate | < absent >
+
+   EEs MUST ensure that the correct certificate is used for this
+   purpose.
+
+5.3.19.2.  Signing Key Pair Types
+
+   This MAY be used by the EE to get the list of signature algorithms
+   (e.g., RSA, DSA) whose subject public key values the CA is willing to
+   certify.  Note that for the purposes of this exchange, rsaEncryption
+   and rsaWithSHA1, for example, are considered to be equivalent; the
+   question being asked is, "Is the CA willing to certify an RSA public
+   key?"
+
+      GenMsg:    {id-it 2}, < absent >
+      GenRep:    {id-it 2}, SEQUENCE SIZE (1..MAX) OF
+                            AlgorithmIdentifier
+
+5.3.19.3.  Encryption/Key Agreement Key Pair Types
+
+   This MAY be used by the client to get the list of encryption/key
+   agreement algorithms whose subject public key values the CA is
+   willing to certify.
+
+      GenMsg:    {id-it 3}, < absent >
+      GenRep:    {id-it 3}, SEQUENCE SIZE (1..MAX) OF
+                            AlgorithmIdentifier
+
+5.3.19.4.  Preferred Symmetric Algorithm
+
+   This MAY be used by the client to get the CA-preferred symmetric
+   encryption algorithm for any confidential information that needs to
+   be exchanged between the EE and the CA (for example, if the EE wants
+   to send its private decryption key to the CA for archival purposes).
+
+      GenMsg:    {id-it 4}, < absent >
+      GenRep:    {id-it 4}, AlgorithmIdentifier
+
+5.3.19.5.  Updated CA Key Pair
+
+   This MAY be used by the CA to announce a CA key update event.
+
+      GenMsg:    {id-it 5}, CAKeyUpdAnnContent
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 45]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.19.6.  CRL
+
+   This MAY be used by the client to get a copy of the latest CRL.
+
+      GenMsg:    {id-it 6}, < absent >
+      GenRep:    {id-it 6}, CertificateList
+
+5.3.19.7.  Unsupported Object Identifiers
+
+   This is used by the server to return a list of object identifiers
+   that it does not recognize or support from the list submitted by the
+   client.
+
+      GenRep:    {id-it 7}, SEQUENCE SIZE (1..MAX) OF OBJECT IDENTIFIER
+
+5.3.19.8.  Key Pair Parameters
+
+   This MAY be used by the EE to request the domain parameters to use
+   for generating the key pair for certain public-key algorithms.  It
+   can be used, for example, to request the appropriate P, Q, and G to
+   generate the DH/DSA key, or to request a set of well-known elliptic
+   curves.
+
+      GenMsg:    {id-it 10}, OBJECT IDENTIFIER -- (Algorithm object-id)
+      GenRep:    {id-it 11}, AlgorithmIdentifier | < absent >
+
+   An absent infoValue in the GenRep indicates that the algorithm
+   specified in GenMsg is not supported.
+
+   EEs MUST ensure that the parameters are acceptable to it and that the
+   GenRep message is authenticated (to avoid substitution attacks).
+
+5.3.19.9.  Revocation Passphrase
+
+   This MAY be used by the EE to send a passphrase to a CA/RA for the
+   purpose of authenticating a later revocation request (in the case
+   that the appropriate signing private key is no longer available to
+   authenticate the request).  See Appendix B for further details on the
+   use of this mechanism.
+
+      GenMsg:    {id-it 12}, EncryptedValue
+      GenRep:    {id-it 12}, < absent >
+
+5.3.19.10.  ImplicitConfirm
+
+   See Section 5.1.1.1 for the definition and use of {id-it 13}.
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 46]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.19.11.  ConfirmWaitTime
+
+   See Section 5.1.1.2 for the definition and use of {id-it 14}.
+
+5.3.19.12 Original PKIMessage
+
+   See Section 5.1.3 for the definition and use of {id-it 15}.
+
+5.3.19.13.  Supported Language Tags
+
+   This MAY be used to determine the appropriate language tag to use in
+   subsequent messages.  The sender sends its list of supported
+   languages (in order, most preferred to least); the receiver returns
+   the one it wishes to use.  (Note: each UTF8String MUST include a
+   language tag.)  If none of the offered tags are supported, an error
+   MUST be returned.
+
+      GenMsg:    {id-it 16}, SEQUENCE SIZE (1..MAX) OF UTF8String
+      GenRep:    {id-it 16}, SEQUENCE SIZE (1) OF UTF8String
+
+5.3.20.  PKI General Response Content
+
+      GenRepContent ::= SEQUENCE OF InfoTypeAndValue
+
+   Examples of GenReps that MAY be supported include those listed in the
+   subsections of Section 5.3.19.
+
+5.3.21.  Error Message Content
+
+   This data structure MAY be used by EE, CA, or RA to convey error
+   info.
+
+    ErrorMsgContent ::= SEQUENCE {
+        pKIStatusInfo          PKIStatusInfo,
+        errorCode              INTEGER           OPTIONAL,
+        errorDetails           PKIFreeText       OPTIONAL
+    }
+
+   This message MAY be generated at any time during a PKI transaction.
+   If the client sends this request, the server MUST respond with a
+   PKIConfirm response, or another ErrorMsg if any part of the header is
+   not valid.  Both sides MUST treat this message as the end of the
+   transaction (if a transaction is in progress).
+
+   If protection is desired on the message, the client MUST protect it
+   using the same technique (i.e., signature or MAC) as the starting
+   message of the transaction.  The CA MUST always sign it with a
+   signature key.
+
+
+
+Adams, et al.               Standards Track                    [Page 47]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.22.  Polling Request and Response
+
+   This pair of messages is intended to handle scenarios in which the
+   client needs to poll the server in order to determine the status of
+   an outstanding ir, cr, or kur transaction (i.e., when the "waiting"
+   PKIStatus has been received).
+
+    PollReqContent ::= SEQUENCE OF SEQUENCE {
+        certReqId    INTEGER }
+
+    PollRepContent ::= SEQUENCE OF SEQUENCE {
+        certReqId    INTEGER,
+        checkAfter   INTEGER,  -- time in seconds
+        reason       PKIFreeText OPTIONAL }
+
+   The following clauses describe when polling messages are used, and
+   how they are used.  It is assumed that multiple certConf messages can
+   be sent during transactions.  There will be one sent in response to
+   each ip, cp, or kup that contains a CertStatus for an issued
+   certificate.
+
+   1.  In response to an ip, cp, or kup message, an EE will send a
+       certConf for all issued certificates and, following the ack, a
+       pollReq for all pending certificates.
+
+   2.  In response to a pollReq, a CA/RA will return an ip, cp, or kup
+       if one or more of the pending certificates is ready; otherwise,
+       it will return a pollRep.
+
+   3.  If the EE receives a pollRep, it will wait for at least as long
+       as the checkAfter value before sending another pollReq.
+
+   4.  If an ip, cp, or kup is received in response to a pollReq, then
+       it will be treated in the same way as the initial response.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 48]
+
+RFC 4210                          CMP                     September 2005
+
+
+                               START
+                                 |
+                                 v
+                              Send ir
+                                 | ip
+                                 v
+                            Check status
+                            of returned <------------------------+
+                               certs                             |
+                                 |                               |
+       +------------------------>|<------------------+           |
+       |                         |                   |           |
+       |        (issued)         v       (waiting)   |           |
+     Add to <----------- Check CertResponse ------> Add to       |
+    conf list           for each certificate      pending list   |
+                                 /                               |
+                                /                                |
+                   (conf list) /     (empty conf list)           |
+                              /                     ip           |
+                             /                 +----------------+
+      (empty pending list)  /                  |    pRep
+        END <---- Send certConf         Send pReq------------>Wait
+                         |                 ^   ^               |
+                         |                 |   |               |
+                         +-----------------+   +---------------+
+                            (pending list)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 49]
+
+RFC 4210                          CMP                     September 2005
+
+
+   In the following exchange, the end entity is enrolling for two
+   certificates in one request.
+
+    Step  End Entity                       PKI
+    --------------------------------------------------------------------
+    1   Format ir
+    2                    -> ir      ->
+    3                                    Handle ir
+    4                                    Manual intervention is
+                                         required for both certs.
+    5                    <- ip      <-
+    6   Process ip
+    7   Format pReq
+    8                    -> pReq     ->
+    9                                    Check status of cert requests
+    10                                   Certificates not ready
+    11                                   Format pRep
+    12                   <- pRep     <-
+    13  Wait
+    14  Format pReq
+    15                   -> pReq     ->
+    16                                   Check status of cert requests
+    17                                   One certificate is ready
+    18                                   Format ip
+    19                   <- ip       <-
+    20  Handle ip
+    21  Format certConf
+    22                   -> certConf ->
+    23                                   Handle certConf
+    24                                   Format ack
+    25                   <- pkiConf   <-
+    26  Format pReq
+    27                   -> pReq     ->
+    28                                   Check status of certificate
+    29                                   Certificate is ready
+    30                                   Format ip
+    31                   <- ip       <-
+    31  Handle ip
+    32  Format certConf
+    33                   -> certConf ->
+    34                                   Handle certConf
+    35                                   Format ack
+    36                   <- pkiConf  <-
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 50]
+
+RFC 4210                          CMP                     September 2005
+
+
+6.  Mandatory PKI Management Functions
+
+   Some of the PKI management functions outlined in Section 3.1 above
+   are described in this section.
+
+   This section deals with functions that are "mandatory" in the sense
+   that all end entity and CA/RA implementations MUST be able to provide
+   the functionality described.  This part is effectively the profile of
+   the PKI management functionality that MUST be supported.  Note,
+   however, that the management functions described in this section do
+   not need to be accomplished using the PKI messages defined in Section
+   5 if alternate means are suitable for a given environment (see
+   Appendix D for profiles of the PKIMessages that MUST be supported).
+
+6.1.  Root CA Initialization
+
+   [See Section 3.1.1.2 for this document's definition of "root CA".]
+
+   A newly created root CA must produce a "self-certificate", which is a
+   Certificate structure with the profile defined for the "newWithNew"
+   certificate issued following a root CA key update.
+
+   In order to make the CA's self certificate useful to end entities
+   that do not acquire the self certificate via "out-of-band" means, the
+   CA must also produce a fingerprint for its certificate.  End entities
+   that acquire this fingerprint securely via some "out-of-band" means
+   can then verify the CA's self-certificate and, hence, the other
+   attributes contained therein.
+
+   The data structure used to carry the fingerprint is the OOBCertHash.
+
+6.2.  Root CA Key Update
+
+   CA keys (as all other keys) have a finite lifetime and will have to
+   be updated on a periodic basis.  The certificates NewWithNew,
+   NewWithOld, and OldWithNew (see Section 4.4.1) MAY be issued by the
+   CA to aid existing end entities who hold the current self-signed CA
+   certificate (OldWithOld) to transition securely to the new self-
+   signed CA certificate (NewWithNew), and to aid new end entities who
+   will hold NewWithNew to acquire OldWithOld securely for verification
+   of existing data.
+
+6.3.  Subordinate CA Initialization
+
+   [See Section 3.1.1.2 for this document's definition of "subordinate
+   CA".]
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 51]
+
+RFC 4210                          CMP                     September 2005
+
+
+   From the perspective of PKI management protocols, the initialization
+   of a subordinate CA is the same as the initialization of an end
+   entity.  The only difference is that the subordinate CA must also
+   produce an initial revocation list.
+
+6.4.  CRL production
+
+   Before issuing any certificates, a newly established CA (which issues
+   CRLs) must produce "empty" versions of each CRL which are to be
+   periodically produced.
+
+6.5.  PKI Information Request
+
+   When a PKI entity (CA, RA, or EE) wishes to acquire information about
+   the current status of a CA, it MAY send that CA a request for such
+   information.
+
+   The CA MUST respond to the request by providing (at least) all of the
+   information requested by the requester.  If some of the information
+   cannot be provided, then an error must be conveyed to the requester.
+
+   If PKIMessages are used to request and supply this PKI information,
+   then the request MUST be the GenMsg message, the response MUST be the
+   GenRep message, and the error MUST be the Error message.  These
+   messages are protected using a MAC based on shared secret information
+   (i.e., PasswordBasedMAC) or using any other authenticated means (if
+   the end entity has an existing certificate).
+
+6.6.  Cross Certification
+
+   The requester CA is the CA that will become the subject of the
+   cross-certificate; the responder CA will become the issuer of the
+   cross-certificate.
+
+   The requester CA must be "up and running" before initiating the
+   cross-certification operation.
+
+6.6.1.  One-Way Request-Response Scheme:
+
+   The cross-certification scheme is essentially a one way operation;
+   that is, when successful, this operation results in the creation of
+   one new cross-certificate.  If the requirement is that cross-
+   certificates be created in "both directions", then each CA, in turn,
+   must initiate a cross-certification operation (or use another
+   scheme).
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 52]
+
+RFC 4210                          CMP                     September 2005
+
+
+   This scheme is suitable where the two CAs in question can already
+   verify each other's signatures (they have some common points of
+   trust) or where there is an out-of-band verification of the origin of
+   the certification request.
+
+   Detailed Description:
+
+   Cross certification is initiated at one CA known as the responder.
+   The CA administrator for the responder identifies the CA it wants to
+   cross certify and the responder CA equipment generates an
+   authorization code.  The responder CA administrator passes this
+   authorization code by out-of-band means to the requester CA
+   administrator.  The requester CA administrator enters the
+   authorization code at the requester CA in order to initiate the on-
+   line exchange.
+
+   The authorization code is used for authentication and integrity
+   purposes.  This is done by generating a symmetric key based on the
+   authorization code and using the symmetric key for generating Message
+   Authentication Codes (MACs) on all messages exchanged.
+   (Authentication may alternatively be done using signatures instead of
+   MACs, if the CAs are able to retrieve and validate the required
+   public keys by some means, such as an out-of-band hash comparison.)
+
+   The requester CA initiates the exchange by generating a cross-
+   certification request (ccr) with a fresh random number (requester
+   random number).  The requester CA then sends the ccr message to the
+   responder CA.  The fields in this message are protected from
+   modification with a MAC based on the authorization code.
+
+   Upon receipt of the ccr message, the responder CA validates the
+   message and the MAC, saves the requester random number, and generates
+   its own random number (responder random number).  It then generates
+   (and archives, if desired) a new requester certificate that contains
+   the requester CA public key and is signed with the responder CA
+   signature private key.  The responder CA responds with the cross
+   certification response (ccp) message.  The fields in this message are
+   protected from modification with a MAC based on the authorization
+   code.
+
+   Upon receipt of the ccp message, the requester CA validates the
+   message (including the received random numbers) and the MAC.  The
+   requester CA responds with the certConf message.  The fields in this
+   message are protected from modification with a MAC based on the
+   authorization code.  The requester CA MAY write the requester
+   certificate to the Repository as an aid to later certificate path
+   construction.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 53]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Upon receipt of the certConf message, the responder CA validates the
+   message and the MAC, and sends back an acknowledgement using the
+   PKIConfirm message.  It MAY also publish the requester certificate as
+   an aid to later path construction.
+
+   Notes:
+
+   1.  The ccr message must contain a "complete" certification request;
+       that is, all fields except the serial number (including, e.g., a
+       BasicConstraints extension) must be specified by the requester
+       CA.
+
+   2.  The ccp message SHOULD contain the verification certificate of
+       the responder CA; if present, the requester CA must then verify
+       this certificate (for example, via the "out-of-band" mechanism).
+
+   (A simpler, non-interactive model of cross-certification may also be
+   envisioned, in which the issuing CA acquires the subject CA's public
+   key from some repository, verifies it via some out-of-band mechanism,
+   and creates and publishes the cross-certificate without the subject
+   CA's explicit involvement.  This model may be perfectly legitimate
+   for many environments, but since it does not require any protocol
+   message exchanges, its detailed description is outside the scope of
+   this specification.)
+
+6.7.  End Entity Initialization
+
+   As with CAs, end entities must be initialized.  Initialization of end
+   entities requires at least two steps:
+
+   o  acquisition of PKI information
+
+   o  out-of-band verification of one root-CA public key
+
+   (other possible steps include the retrieval of trust condition
+   information and/or out-of-band verification of other CA public keys).
+
+6.7.1.  Acquisition of PKI Information
+
+   The information REQUIRED is:
+
+   o  the current root-CA public key
+
+   o  (if the certifying CA is not a root-CA) the certification path
+      from the root CA to the certifying CA together with appropriate
+      revocation lists
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 54]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  the algorithms and algorithm parameters that the certifying CA
+      supports for each relevant usage
+
+   Additional information could be required (e.g., supported extensions
+   or CA policy information) in order to produce a certification request
+   that will be successful.  However, for simplicity we do not mandate
+   that the end entity acquires this information via the PKI messages.
+   The end result is simply that some certification requests may fail
+   (e.g., if the end entity wants to generate its own encryption key,
+   but the CA doesn't allow that).
+
+   The required information MAY be acquired as described in Section 6.5.
+
+6.7.2.  Out-of-Band Verification of Root-CA Key
+
+   An end entity must securely possess the public key of its root CA.
+   One method to achieve this is to provide the end entity with the CA's
+   self-certificate fingerprint via some secure "out-of-band" means.
+   The end entity can then securely use the CA's self-certificate.
+
+   See Section 6.1 for further details.
+
+6.8.  Certificate Request
+
+   An initialized end entity MAY request an additional certificate at
+   any time (for any purpose).  This request will be made using the
+   certification request (cr) message.  If the end entity already
+   possesses a signing key pair (with a corresponding verification
+   certificate), then this cr message will typically be protected by the
+   entity's digital signature.  The CA returns the new certificate (if
+   the request is successful) in a CertRepMessage.
+
+6.9.  Key Update
+
+   When a key pair is due to expire, the relevant end entity MAY request
+   a key update; that is, it MAY request that the CA issue a new
+   certificate for a new key pair (or, in certain circumstances, a new
+   certificate for the same key pair).  The request is made using a key
+   update request (kur) message (referred to, in some environments, as a
+   "Certificate Update" operation).  If the end entity already possesses
+   a signing key pair (with a corresponding verification certificate),
+   then this message will typically be protected by the entity's digital
+   signature.  The CA returns the new certificate (if the request is
+   successful) in a key update response (kup) message, which is
+   syntactically identical to a CertRepMessage.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 55]
+
+RFC 4210                          CMP                     September 2005
+
+
+7.  Version Negotiation
+
+   This section defines the version negotiation used to support older
+   protocols between client and servers.
+
+   If a client knows the protocol version(s) supported by the server
+   (e.g., from a previous PKIMessage exchange or via some out-of-band
+   means), then it MUST send a PKIMessage with the highest version
+   supported by both it and the server.  If a client does not know what
+   version(s) the server supports, then it MUST send a PKIMessage using
+   the highest version it supports.
+
+   If a server receives a message with a version that it supports, then
+   the version of the response message MUST be the same as the received
+   version.  If a server receives a message with a version higher or
+   lower than it supports, then it MUST send back an ErrorMsg with the
+   unsupportedVersion bit set (in the failureInfo field of the
+   pKIStatusInfo).  If the received version is higher than the highest
+   supported version, then the version in the error message MUST be the
+   highest version the server supports; if the received version is lower
+   than the lowest supported version then the version in the error
+   message MUST be the lowest version the server supports.
+
+   If a client gets back an ErrorMsgContent with the unsupportedVersion
+   bit set and a version it supports, then it MAY retry the request with
+   that version.
+
+7.1.  Supporting RFC 2510 Implementations
+
+   RFC 2510 did not specify the behaviour of implementations receiving
+   versions they did not understand since there was only one version in
+   existence.  With the introduction of the present revision of the
+   specification, the following versioning behaviour is recommended.
+
+7.1.1.  Clients Talking to RFC 2510 Servers
+
+   If, after sending a cmp2000 message, a client receives an
+   ErrorMsgContent with a version of cmp1999, then it MUST abort the
+   current transaction.  It MAY subsequently retry the transaction using
+   version cmp1999 messages.
+
+   If a client receives a non-error PKIMessage with a version of
+   cmp1999, then it MAY decide to continue the transaction (if the
+   transaction hasn't finished) using RFC 2510 semantics.  If it does
+   not choose to do so and the transaction is not finished, then it MUST
+   abort the transaction and send an ErrorMsgContent with a version of
+   cmp1999.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 56]
+
+RFC 4210                          CMP                     September 2005
+
+
+7.1.2.  Servers Receiving Version cmp1999 PKIMessages
+
+   If a server receives a version cmp1999 message it MAY revert to RFC
+   2510 behaviour and respond with version cmp1999 messages.  If it does
+   not choose to do so, then it MUST send back an ErrorMsgContent as
+   described above in Section 7.
+
+8.  Security Considerations
+
+8.1.  Proof-Of-Possession with a Decryption Key
+
+   Some cryptographic considerations are worth explicitly spelling out.
+   In the protocols specified above, when an end entity is required to
+   prove possession of a decryption key, it is effectively challenged to
+   decrypt something (its own certificate).  This scheme (and many
+   others!) could be vulnerable to an attack if the possessor of the
+   decryption key in question could be fooled into decrypting an
+   arbitrary challenge and returning the cleartext to an attacker.
+   Although in this specification a number of other failures in security
+   are required in order for this attack to succeed, it is conceivable
+   that some future services (e.g., notary, trusted time) could
+   potentially be vulnerable to such attacks.  For this reason, we re-
+   iterate the general rule that implementations should be very careful
+   about decrypting arbitrary "ciphertext" and revealing recovered
+   "plaintext" since such a practice can lead to serious security
+   vulnerabilities.
+
+8.2.  Proof-Of-Possession by Exposing the Private Key
+
+   Note also that exposing a private key to the CA/RA as a proof-of-
+   possession technique can carry some security risks (depending upon
+   whether or not the CA/RA can be trusted to handle such material
+   appropriately).  Implementers are advised to:
+
+      Exercise caution in selecting and using this particular POP
+      mechanism
+
+      When appropriate, have the user of the application explicitly
+      state that they are willing to trust the CA/RA to have a copy of
+      their private key before proceeding to reveal the private key.
+
+8.3.  Attack Against Diffie-Hellman Key Exchange
+
+   A small subgroup attack during a Diffie-Hellman key exchange may be
+   carried out as follows.  A malicious end entity may deliberately
+   choose D-H parameters that enable him/her to derive (a significant
+   number of bits of) the D-H private key of the CA during a key
+   archival or key recovery operation.  Armed with this knowledge, the
+
+
+
+Adams, et al.               Standards Track                    [Page 57]
+
+RFC 4210                          CMP                     September 2005
+
+
+   EE would then be able to retrieve the decryption private key of
+   another unsuspecting end entity, EE2, during EE2's legitimate key
+   archival or key recovery operation with that CA.  In order to avoid
+   the possibility of such an attack, two courses of action are
+   available.  (1) The CA may generate a fresh D-H key pair to be used
+   as a protocol encryption key pair for each EE with which it
+
+   interacts.  (2) The CA may enter into a key validation protocol (not
+   specified in this document) with each requesting end entity to ensure
+   that the EE's protocol encryption key pair will not facilitate this
+   attack.  Option (1) is clearly simpler (requiring no extra protocol
+   exchanges from either party) and is therefore RECOMMENDED.
+
+9.  IANA Considerations
+
+   The PKI General Message types are identified by object identifiers
+   (OIDs).  The OIDs for the PKI General Message types defined in this
+   document were assigned from an arc delegated by the IANA to the PKIX
+   Working Group.
+
+   The cryptographic algorithms referred to in this document are
+   identified by object identifiers (OIDs).  The OIDs for cryptographic
+   algorithms were assigned from several arcs owned by various
+   organizations, including RSA Security, Entrust Technologies, IANA and
+   IETF.
+
+   Should additional encryption algorithms be introduced, the advocates
+   for such algorithms are expected to assign the necessary OIDs from
+   their own arcs.
+
+   No further action by the IANA is necessary for this document or any
+   anticipated updates.
+
+Normative References
+
+   [X509]       International Organization for Standardization and
+                International Telecommunications Union, "Information
+                technology - Open Systems Interconnection - The
+                Directory:  Public-key and attribute certificate
+                frameworks", ISO Standard 9594-8:2001, ITU-T
+                Recommendation X.509, March 2000.
+
+   [MvOV97]     Menezes, A., van Oorschot, P. and S. Vanstone, "Handbook
+                of Applied Cryptography", CRC Press ISBN 0-8493-8523-7,
+                1996.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 58]
+
+RFC 4210                          CMP                     September 2005
+
+
+   [RFC2104]    Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
+                Keyed-Hashing for Message Authentication", RFC 2104,
+                February 1997.
+
+   [RFC2119]    Bradner, S., "Key words for use in RFCs to Indicate
+                Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2202]    Cheng, P. and R. Glenn, "Test Cases for HMAC-MD5 and
+                HMAC-SHA-1", RFC 2202, September 1997.
+
+   [RFC3629]    Yergeau, F., "UTF-8, a transformation format of ISO
+                10646", STD 63, RFC 3629, November 2003.
+
+   [RFC2482]    Whistler, K. and G. Adams, "Language Tagging in Unicode
+                Plain Text", RFC 2482, January 1999.
+
+   [CRMF]       Schaad, J., "Internet X.509 Public Key Infrastructure
+                Certificate Request Message Format (CRMF)", RFC 4211,
+                September 2005.
+
+   [RFC3066]    Alvestrand, H., "Tags for the Identification of
+                Languages", BCP 47, RFC 3066, January 2001.
+
+Informative References
+
+   [CMPtrans]   Kapoor, A., Tschalar, R. and T. Kause, "Internet X.509
+                Public Key Infrastructure -- Transport Protocols for
+                CMP", Work in Progress.  2004.
+
+   [PKCS7]      RSA Laboratories, "The Public-Key Cryptography Standards
+                - Cryptographic Message Syntax Standard.  Version 1.5",
+                PKCS 7, November 1993.
+
+   [PKCS10]     Nystrom, M., and B. Kaliski, "The Public-Key
+                Cryptography Standards - Certification Request Syntax
+                Standard, Version 1.7", RFC 2986, May 2000.
+
+   [PKCS11]     RSA Laboratories, "The Public-Key Cryptography Standards
+                - Cryptographic Token Interface Standard.  Version
+                2.10", PKCS 11, December 1999.
+
+   [RFC1847]    Galvin, J., Murphy, S., Crocker, S., and N. Freed,
+                "Security Multiparts for MIME: Multipart/Signed and
+                Multipart/Encrypted", RFC 1847, October 1995.
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 59]
+
+RFC 4210                          CMP                     September 2005
+
+
+   [RFC2559]    Boeyen, S., Howes, T. and P. Richard, "Internet X.509
+                Public Key Infrastructure Operational Protocols -
+                LDAPv2", RFC 2559, April 1999.
+
+   [RFC2585]    Housley, R. and P. Hoffman, "Internet X.509 Public Key
+                Infrastructure Operational Protocols: FTP and HTTP", RFC
+                2585, May 1999.
+
+   [FIPS-180]   National Institute of Standards and Technology, "Secure
+                Hash Standard", FIPS PUB 180-1, May 1994.
+
+   [FIPS-186]   National Institute of Standards and Technology, "Digital
+                Signature Standard", FIPS PUB 186, May 1994.
+
+   [ANSI-X9.42] American National Standards Institute, "Public Key
+                Cryptography for The Financial Services Industry:
+                Agreement of Symmetric Keys Using Discrete Logarithm
+                Cryptography", ANSI X9.42, February 2000.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 60]
+
+RFC 4210                          CMP                     September 2005
+
+
+Appendix A.  Reasons for the Presence of RAs
+
+   The reasons that justify the presence of an RA can be split into
+   those that are due to technical factors and those which are
+   organizational in nature.  Technical reasons include the following.
+
+   o  If hardware tokens are in use, then not all end entities will have
+      the equipment needed to initialize these; the RA equipment can
+      include the necessary functionality (this may also be a matter of
+      policy).
+
+   o  Some end entities may not have the capability to publish
+      certificates; again, the RA may be suitably placed for this.
+
+   o  The RA will be able to issue signed revocation requests on behalf
+      of end entities associated with it, whereas the end entity may not
+      be able to do this (if the key pair is completely lost).
+
+   Some of the organizational reasons that argue for the presence of an
+   RA are the following.
+
+   o  It may be more cost effective to concentrate functionality in the
+      RA equipment than to supply functionality to all end entities
+      (especially if special token initialization equipment is to be
+      used).
+
+   o  Establishing RAs within an organization can reduce the number of
+      CAs required, which is sometimes desirable.
+
+   o  RAs may be better placed to identify people with their
+      "electronic" names, especially if the CA is physically remote from
+      the end entity.
+
+   o  For many applications, there will already be in place some
+      administrative structure so that candidates for the role of RA are
+      easy to find (which may not be true of the CA).
+
+Appendix B.  The Use of Revocation Passphrase
+
+   A revocation request must incorporate suitable security mechanisms,
+   including proper authentication, in order to reduce the probability
+   of successful denial-of-service attacks.  A digital signature on the
+   request -- MANDATORY to support within this specification if
+   revocation requests are supported -- can provide the authentication
+   required, but there are circumstances under which an alternative
+   mechanism may be desirable (e.g., when the private key is no longer
+   accessible and the entity wishes to request a revocation prior to
+   re-certification of another key pair).  In order to accommodate such
+
+
+
+Adams, et al.               Standards Track                    [Page 61]
+
+RFC 4210                          CMP                     September 2005
+
+
+   circumstances, a PasswordBasedMAC on the request is also MANDATORY to
+   support within this specification (subject to local security policy
+   for a given environment) if revocation requests are supported and if
+   shared secret information can be established between the requester
+   and the responder prior to the need for revocation.
+
+   A mechanism that has seen use in some environments is "revocation
+   passphrase", in which a value of sufficient entropy (i.e., a
+   relatively long passphrase rather than a short password) is shared
+   between (only) the entity and the CA/RA at some point prior to
+   revocation; this value is later used to authenticate the revocation
+   request.
+
+   In this specification, the following technique to establish shared
+   secret information (i.e., a revocation passphrase) is OPTIONAL to
+   support.  Its precise use in CMP messages is as follows.
+
+   o  The OID and value specified in Section 5.3.19.9 MAY be sent in a
+      GenMsg message at any time, or MAY be sent in the generalInfo
+      field of the PKIHeader of any PKIMessage at any time.  (In
+      particular, the EncryptedValue may be sent in the header of the
+      certConf message that confirms acceptance of certificates
+      requested in an initialization request or certificate request
+      message.)  This conveys a revocation passphrase chosen by the
+      entity (i.e., the decrypted bytes of the encValue field) to the
+      relevant CA/RA; furthermore, the transfer is accomplished with
+      appropriate confidentiality characteristics (because the
+      passphrase is encrypted under the CA/RA's protocolEncryptionKey).
+
+   o  If a CA/RA receives the revocation passphrase (OID and value
+      specified in Section 5.3.19.9) in a GenMsg, it MUST construct and
+      send a GenRep message that includes the OID (with absent value)
+      specified in Section 5.3.19.9. If the CA/RA receives the
+      revocation passphrase in the generalInfo field of a PKIHeader of
+      any PKIMessage, it MUST include the OID (with absent value) in the
+      generalInfo field of the PKIHeader of the corresponding response
+      PKIMessage.  If the CA/RA is unable to return the appropriate
+      response message for any reason, it MUST send an error message
+      with a status of "rejection" and, optionally, a failInfo reason
+      set.
+
+   o  The valueHint field of EncryptedValue MAY contain a key identifier
+      (chosen by the entity, along with the passphrase itself) to assist
+      in later retrieval of the correct passphrase (e.g., when the
+      revocation request is constructed by the entity and received by
+      the CA/RA).
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 62]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  The revocation request message is protected by a PasswordBasedMAC,
+      with the revocation passphrase as the key.  If appropriate, the
+      senderKID field in the PKIHeader MAY contain the value previously
+      transmitted in valueHint.
+
+   Using the technique specified above, the revocation passphrase may be
+   initially established and updated at any time without requiring extra
+   messages or out-of-band exchanges.  For example, the revocation
+   request message itself (protected and authenticated through a MAC
+   that uses the revocation passphrase as a key) may contain, in the
+   PKIHeader, a new revocation passphrase to be used for authenticating
+   future revocation requests for any of the entity's other
+   certificates.  In some environments this may be preferable to
+   mechanisms that reveal the passphrase in the revocation request
+   message, since this can allow a denial-of-service attack in which the
+   revealed passphrase is used by an unauthorized third party to
+   authenticate revocation requests on the entity's other certificates.
+   However, because the passphrase is not revealed in the request
+   message, there is no requirement that the passphrase must always be
+   updated when a revocation request is made (that is, the same
+   passphrase MAY be used by an entity to authenticate revocation
+   requests for different certificates at different times).
+
+   Furthermore, the above technique can provide strong cryptographic
+   protection over the entire revocation request message even when a
+   digital signature is not used.  Techniques that do authentication of
+   the revocation request by simply revealing the revocation passphrase
+   typically do not provide cryptographic protection over the fields of
+   the request message (so that a request for revocation of one
+   certificate may be modified by an unauthorized third party to a
+   request for revocation of another certificate for that entity).
+
+Appendix C.  Request Message Behavioral Clarifications
+
+   In the case of updates to [CRMF], which cause interpretation or
+   interoperability issues, [CRMF] SHALL be the normative document.
+
+   The following definitions are from [CRMF].  They are included here in
+   order to codify behavioral clarifications to that request message;
+   otherwise, all syntax and semantics are identical to [CRMF].
+
+   CertRequest ::= SEQUENCE {
+       certReqId     INTEGER,
+       certTemplate  CertTemplate,
+       controls      Controls OPTIONAL }
+
+   -- If certTemplate is an empty SEQUENCE (i.e., all fields
+   -- omitted), then controls MAY contain the
+
+
+
+Adams, et al.               Standards Track                    [Page 63]
+
+RFC 4210                          CMP                     September 2005
+
+
+   -- id-regCtrl-altCertTemplate control, specifying a template
+   -- for a certificate other than an X.509v3 public-key
+   -- certificate.  Conversely, if certTemplate is not empty
+   -- (i.e., at least one field is present), then controls MUST
+   -- NOT contain id-regCtrl- altCertTemplate.  The new control is
+   -- defined as follows:
+
+   id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= {id-regCtrl 7}
+   AltCertTemplate ::= AttributeTypeAndValue
+
+   POPOSigningKey ::= SEQUENCE {
+       poposkInput           [0] POPOSigningKeyInput OPTIONAL,
+       algorithmIdentifier   AlgorithmIdentifier,
+       signature             BIT STRING }
+
+   -- **********
+   -- * For the purposes of this specification, the ASN.1 comment
+   -- * given in [CRMF] pertains not only to certTemplate, but
+   -- * also to the altCertTemplate control.  That is,
+   -- **********
+   -- * The signature (using "algorithmIdentifier") is on the
+   -- * DER-encoded value of poposkInput (i.e., the "value" OCTETs
+   -- * of the POPOSigningKeyInput DER).  NOTE: If CertReqMsg
+   -- * certReq certTemplate (or the altCertTemplate control)
+   -- * contains the subject and publicKey values, then poposkInput
+   -- * MUST be omitted and the signature MUST be computed on the
+   -- * DER-encoded value of CertReqMsg certReq (or the DER-
+   -- * encoded value of AltCertTemplate).  If
+   -- * certTemplate/altCertTemplate does not contain both the
+   -- * subject and public key values (i.e., if it contains only
+   -- * one of these, or neither), then poposkInput MUST be present
+   -- * and MUST be signed.
+   -- **********
+
+   POPOPrivKey ::= CHOICE {
+       thisMessage       [0] BIT STRING,
+
+   -- **********
+   -- * the type of "thisMessage" is given as BIT STRING in
+   -- * [CRMF]; it should be "EncryptedValue" (in accordance
+   -- * with Section 5.2.2, "Encrypted Values", of this specification).
+   -- * Therefore, this document makes the behavioral clarification
+   -- * of specifying that the contents of "thisMessage" MUST be encoded
+   -- * as an EncryptedValue and then wrapped in a BIT STRING.  This
+   -- * allows the necessary conveyance and protection of the
+   -- * private key while maintaining bits-on-the-wire compatibility
+   -- * with [CRMF].
+   -- **********
+
+
+
+Adams, et al.               Standards Track                    [Page 64]
+
+RFC 4210                          CMP                     September 2005
+
+
+       subsequentMessage [1] SubsequentMessage,
+       dhMAC             [2] BIT STRING }
+
+Appendix D.  PKI Management Message Profiles (REQUIRED).
+
+   This appendix contains detailed profiles for those PKIMessages that
+   MUST be supported by conforming implementations (see Section 6).
+
+   Profiles for the PKIMessages used in the following PKI management
+   operations are provided:
+
+   o  initial registration/certification
+
+   o  basic authenticated scheme
+
+   o  certificate request
+
+   o  key update
+
+D.1.  General Rules for Interpretation of These Profiles.
+
+   1.  Where OPTIONAL or DEFAULT fields are not mentioned in individual
+       profiles, they SHOULD be absent from the relevant message (i.e.,
+       a receiver can validly reject a message containing such fields as
+       being syntactically incorrect).  Mandatory fields are not
+       mentioned if they have an obvious value (e.g., in this version of
+       the specification, pvno is always 2).
+
+   2.  Where structures occur in more than one message, they are
+       separately profiled as appropriate.
+
+   3.  The algorithmIdentifiers from PKIMessage structures are profiled
+       separately.
+
+   4.  A "special" X.500 DN is called the "NULL-DN"; this means a DN
+       containing a zero-length SEQUENCE OF RelativeDistinguishedNames
+       (its DER encoding is then '3000'H).
+
+   5.  Where a GeneralName is required for a field, but no suitable
+       value is available (e.g., an end entity produces a request before
+       knowing its name), then the GeneralName is to be an X.500 NULL-DN
+       (i.e., the Name field of the CHOICE is to contain a NULL-DN).
+       This special value can be called a "NULL-GeneralName".
+
+   6.  Where a profile omits to specify the value for a GeneralName,
+       then the NULL-GeneralName value is to be present in the relevant
+       PKIMessage field.  This occurs with the sender field of the
+       PKIHeader for some messages.
+
+
+
+Adams, et al.               Standards Track                    [Page 65]
+
+RFC 4210                          CMP                     September 2005
+
+
+   7.  Where any ambiguity arises due to naming of fields, the profile
+       names these using a "dot" notation (e.g., "certTemplate.subject"
+       means the subject field within a field called certTemplate).
+
+   8.  Where a "SEQUENCE OF types" is part of a message, a zero-based
+       array notation is used to describe fields within the SEQUENCE OF
+       (e.g., crm[0].certReq.certTemplate.subject refers to a subfield
+       of the first CertReqMsg contained in a request message).
+
+   9.  All PKI message exchanges in Appendix D.4 to D.6 require a
+       certConf message to be sent by the initiating entity and a
+       PKIConfirm to be sent by the responding entity.  The PKIConfirm
+       is not included in some of the profiles given since its body is
+       NULL and its header contents are clear from the context.  Any
+       authenticated means can be used for the protectionAlg (e.g.,
+       password-based MAC, if shared secret information is known, or
+       signature).
+
+D.2.  Algorithm Use Profile
+
+   The following table contains definitions of algorithm uses within PKI
+   management protocols.  The columns in the table are:
+
+   Name: an identifier used for message profiles
+
+   Use: description of where and for what the algorithm is used
+
+   Mandatory: an AlgorithmIdentifier which MUST be supported by
+      conforming implementations
+
+   Others: alternatives to the mandatory AlgorithmIdentifier
+
+    Name         Use                      Mandatory        Others
+
+    MSG_SIG_ALG  Protection of PKI        DSA/SHA-1        RSA/MD5,
+                 messages using signature                  ECDSA, ...
+    MSG_MAC_ALG  protection of PKI        PasswordBasedMac HMAC,
+                 messages using MACing                     X9.9...
+    SYM_PENC_ALG symmetric encryption of  3-DES (3-key-    AES,RC5,
+                 an end entity's private  EDE, CBC mode)   CAST-128...
+                 key where symmetric
+                 key is distributed
+                 out-of-band
+    PROT_ENC_ALG asymmetric algorithm     D-H              RSA,
+                 used for encryption of                    ECDH, ...
+                 (symmetric keys for
+                 encryption of) private
+                 keys transported in
+
+
+
+Adams, et al.               Standards Track                    [Page 66]
+
+RFC 4210                          CMP                     September 2005
+
+
+                 PKIMessages
+    PROT_SYM_ALG symmetric encryption     3-DES (3-key-    AES,RC5,
+                 algorithm used for       EDE, CBC mode)   CAST-128...
+                 encryption of private
+                 key bits (a key of this
+                 type is encrypted using
+                 PROT_ENC_ALG)
+
+   Mandatory AlgorithmIdentifiers and Specifications:
+
+   DSA/SHA-1:
+     AlgId: {1 2 840 10040 4 3};
+
+   Digital Signature Standard [FIPS-186]
+
+     Public Modulus size: 1024 bits.
+
+   PasswordBasedMac:
+
+     AlgId: {1 2 840 113533 7 66 13}, with SHA-1 {1 3 14 3 2 26} as the
+            owf parameter and HMAC-SHA1 {1 3 6 1 5 5 8 1 2} as the mac
+            parameter;
+
+     (this specification), along with
+
+   Secure Hash Standard [FIPS-180] and [RFC2104]
+
+     HMAC key size:  160 bits (i.e., "K" = "H" in Section 5.1.3.1,
+                               "Shared secret information")
+
+   3-DES:
+
+     AlgId: {1 2 840 113549 3 7};
+     (used in RSA's BSAFE and in S/MIME).
+
+   D-H:
+
+     AlgId:  {1 2 840 10046 2 1};
+
+   [ANSI-X9.42]
+
+     Public Modulus Size:  1024 bits.
+     DomainParameters ::= SEQUENCE {
+        p       INTEGER, -- odd prime, p=jq +1
+        g       INTEGER, -- generator, g^q = 1 mod p
+        q       INTEGER, -- prime factor of p-1
+        j       INTEGER OPTIONAL, -- cofactor, j>=2
+        validationParms  ValidationParms OPTIONAL
+
+
+
+Adams, et al.               Standards Track                    [Page 67]
+
+RFC 4210                          CMP                     September 2005
+
+
+     }
+     ValidationParms ::= SEQUENCE {
+        seed          BIT STRING, -- seed for prime generation
+        pGenCounter   INTEGER     -- parameter verification
+     }
+
+D.3.  Proof-of-Possession Profile
+
+   POP fields for use (in signature field of pop field of
+   ProofOfPossession structure) when proving possession of a private
+   signing key that corresponds to a public verification key for which a
+   certificate has been requested.
+
+    Field               Value         Comment
+
+    algorithmIdentifier MSG_SIG_ALG   only signature protection is
+                                      allowed for this proof
+
+    signature           present       bits calculated using MSG_SIG_ALG
+
+   Proof-of-possession of a private decryption key that corresponds to a
+   public encryption key for which a certificate has been requested does
+   not use this profile; the CertHash field of the certConf message is
+   used instead.
+
+   Not every CA/RA will do Proof-of-Possession (of signing key,
+   decryption key, or key agreement key) in the PKIX-CMP in-band
+   certification request protocol (how POP is done MAY ultimately be a
+   policy issue that is made explicit for any given CA in its publicized
+   Policy OID and Certification Practice Statement).  However, this
+   specification MANDATES that CA/RA entities MUST do POP (by some
+   means) as part of the certification process.  All end entities MUST
+   be prepared to provide POP (i.e., these components of the PKIX-CMP
+   protocol MUST be supported).
+
+D.4.  Initial Registration/Certification (Basic Authenticated Scheme)
+
+   An (uninitialized) end entity requests a (first) certificate from a
+   CA.  When the CA responds with a message containing a certificate,
+   the end entity replies with a certificate confirmation.  The CA sends
+   a PKIConfirm back, closing the transaction.  All messages are
+   authenticated.
+
+   This scheme allows the end entity to request certification of a
+   locally-generated public key (typically a signature key).  The end
+   entity MAY also choose to request the centralized generation and
+   certification of another key pair (typically an encryption key pair).
+
+
+
+
+Adams, et al.               Standards Track                    [Page 68]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Certification may only be requested for one locally generated public
+   key (for more, use separate PKIMessages).
+
+   The end entity MUST support proof-of-possession of the private key
+   associated with the locally-generated public key.
+
+   Preconditions:
+
+   1.  The end entity can authenticate the CA's signature based on out-
+       of-band means
+
+   2.  The end entity and the CA share a symmetric MACing key
+
+   Message flow:
+
+    Step# End entity                           PKI
+      1   format ir
+      2                      ->   ir      ->
+      3                                        handle ir
+      4                                        format ip
+      5                      <-   ip      <-
+      6   handle ip
+      7   format certConf
+      8                      ->   certConf ->
+      9                                        handle certConf
+     10                                        format PKIConf
+     11                      <-   PKIConf  <-
+     12   handle PKIConf
+
+   For this profile, we mandate that the end entity MUST include all
+   (i.e., one or two) CertReqMsg in a single PKIMessage, and that the
+   PKI (CA) MUST produce a single response PKIMessage that contains the
+   complete response (i.e., including the OPTIONAL second key pair, if
+   it was requested and if centralized key generation is supported).
+   For simplicity, we also mandate that this message MUST be the final
+   one (i.e., no use of "waiting" status value).
+
+   The end entity has an out-of-band interaction with the CA/RA.  This
+   transaction established the shared secret, the referenceNumber and
+   OPTIONALLY the distinguished name used for both sender and subject
+   name in the certificate template.  It is RECOMMENDED that the shared
+   secret be at least 12 characters long.
+
+   Initialization Request -- ir
+
+   Field                Value
+
+   recipient            CA name
+
+
+
+Adams, et al.               Standards Track                    [Page 69]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- the name of the CA who is being asked to produce a certificate
+   protectionAlg        MSG_MAC_ALG
+     -- only MAC protection is allowed for this request, based
+     -- on initial authentication key
+   senderKID            referenceNum
+     -- the reference number which the CA has previously issued
+     -- to the end entity (together with the MACing key)
+   transactionID        present
+     -- implementation-specific value, meaningful to end
+     -- entity.
+     -- [If already in use at the CA, then a rejection message MUST
+     -- be produced by the CA]
+
+   senderNonce          present
+     -- 128 (pseudo-)random bits
+   freeText             any valid value
+   body                 ir (CertReqMessages)
+                        only one or two CertReqMsg
+                        are allowed
+     -- if more certificates are required, requests MUST be
+     -- packaged in separate PKIMessages
+
+   CertReqMsg           one or two present
+     -- see below for details, note: crm[0] means the first
+     -- (which MUST be present), crm[1] means the second (which
+     -- is OPTIONAL, and used to ask for a centrally-generated key)
+
+   crm[0].certReq.      fixed value of zero
+      certReqId
+     -- this is the index of the template within the message
+   crm[0].certReq       present
+      certTemplate
+     -- MUST include subject public key value, otherwise unconstrained
+   crm[0].pop...        optionally present if public key
+      POPOSigningKey    from crm[0].certReq.certTemplate is
+                        a signing key
+     -- proof-of-possession MAY be required in this exchange
+     -- (see Appendix D.3 for details)
+   crm[0].certReq.      optionally present
+      controls.archiveOptions
+     -- the end entity MAY request that the locally-generated
+     -- private key be archived
+
+   crm[0].certReq.      optionally present
+      controls.publicationInfo
+     -- the end entity MAY ask for publication of resulting cert.
+
+   crm[1].certReq       fixed value of one
+
+
+
+Adams, et al.               Standards Track                    [Page 70]
+
+RFC 4210                          CMP                     September 2005
+
+
+      certReqId
+     -- the index of the template within the message
+   crm[1].certReq       present
+      certTemplate
+      -- MUST NOT include actual public key bits, otherwise
+      -- unconstrained (e.g., the names need not be the same as in
+      -- crm[0]).  Note that subjectPublicKeyInfo MAY be present
+      -- and contain an AlgorithmIdentifier followed by a
+      -- zero-length BIT STRING for the subjectPublicKey if it is
+      -- desired to inform the CA/RA of algorithm and parameter
+      -- preferences regarding the to-be-generated key pair.
+
+   crm[1].certReq.      present [object identifier MUST be PROT_ENC_ALG]
+
+      controls.protocolEncrKey
+     -- if centralized key generation is supported by this CA,
+     -- this short-term asymmetric encryption key (generated by
+     -- the end entity) will be used by the CA to encrypt (a
+     -- symmetric key used to encrypt) a private key generated by
+     -- the CA on behalf of the end entity
+
+   crm[1].certReq.      optionally present
+      controls.archiveOptions
+   crm[1].certReq.      optionally present
+      controls.publicationInfo
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+
+   Initialization Response -- ip
+
+   Field                Value
+
+   sender               CA name
+     -- the name of the CA who produced the message
+   messageTime          present
+     -- time at which CA produced message
+   protectionAlg        MS_MAC_ALG
+     -- only MAC protection is allowed for this response
+   senderKID             referenceNum
+     -- the reference number that the CA has previously issued to the
+     -- end entity (together with the MACing key)
+   transactionID        present
+     -- value from corresponding ir message
+   senderNonce          present
+     -- 128 (pseudo-)random bits
+   recipNonce           present
+     -- value from senderNonce in corresponding ir message
+   freeText             any valid value
+
+
+
+Adams, et al.               Standards Track                    [Page 71]
+
+RFC 4210                          CMP                     September 2005
+
+
+   body                 ip (CertRepMessage)
+                        contains exactly one response
+                        for each request
+
+     -- The PKI (CA) responds to either one or two requests as
+     -- appropriate.  crc[0] denotes the first (always present);
+     -- crc[1] denotes the second (only present if the ir message
+     -- contained two requests and if the CA supports centralized
+     -- key generation).
+   crc[0].              fixed value of zero
+      certReqId
+     -- MUST contain the response to the first request in the
+     -- corresponding ir message
+
+   crc[0].status.       present, positive values allowed:
+      status               "accepted", "grantedWithMods"
+                        negative values allowed:
+                           "rejection"
+   crc[0].status.       present if and only if
+      failInfo          crc[0].status.status is "rejection"
+   crc[0].              present if and only if
+      certifiedKeyPair  crc[0].status.status is
+                           "accepted" or "grantedWithMods"
+   certificate          present unless end entity's public
+                        key is an encryption key and POP
+                        is done in this in-band exchange
+   encryptedCert        present if and only if end entity's
+                        public key is an encryption key and
+                        POP done in this in-band exchange
+   publicationInfo      optionally present
+
+     -- indicates where certificate has been published (present
+     -- at discretion of CA)
+
+   crc[1].              fixed value of one
+      certReqId
+     -- MUST contain the response to the second request in the
+     -- corresponding ir message
+   crc[1].status.       present, positive values allowed:
+      status               "accepted", "grantedWithMods"
+                        negative values allowed:
+                           "rejection"
+   crc[1].status.       present if and only if
+      failInfo          crc[0].status.status is "rejection"
+   crc[1].              present if and only if
+      certifiedKeyPair  crc[0].status.status is "accepted"
+                        or "grantedWithMods"
+   certificate          present
+
+
+
+Adams, et al.               Standards Track                    [Page 72]
+
+RFC 4210                          CMP                     September 2005
+
+
+   privateKey           present
+     -- see Appendix C, Request Message Behavioral Clarifications
+   publicationInfo      optionally present
+     -- indicates where certificate has been published (present
+     -- at discretion of CA)
+
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+   extraCerts           optionally present
+     -- the CA MAY provide additional certificates to the end
+     -- entity
+
+   Certificate confirm; certConf
+
+   Field                Value
+
+   sender               present
+     -- same as in ir
+   recipient            CA name
+     -- the name of the CA who was asked to produce a certificate
+   transactionID        present
+     -- value from corresponding ir and ip messages
+   senderNonce          present
+     -- 128 (pseudo-) random bits
+   recipNonce           present
+     -- value from senderNonce in corresponding ip message
+   protectionAlg        MSG_MAC_ALG
+     -- only MAC protection is allowed for this message.  The
+     -- MAC is based on the initial authentication key shared
+     -- between the EE and the CA.
+
+   senderKID            referenceNum
+     -- the reference number which the CA has previously issued
+     -- to the end entity (together with the MACing key)
+
+   body                 certConf
+     -- see Section 5.3.18, "PKI Confirmation Content", for the
+     -- contents of the certConf fields.
+     -- Note: two CertStatus structures are required if both an
+     -- encryption and a signing certificate were sent.
+
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+
+   Confirmation; PKIConf
+
+   Field                Value
+
+
+
+
+Adams, et al.               Standards Track                    [Page 73]
+
+RFC 4210                          CMP                     September 2005
+
+
+   sender               present
+     -- same as in ip
+   recipient            present
+     -- sender name from certConf
+   transactionID        present
+     -- value from certConf message
+   senderNonce          present
+     -- 128 (pseudo-) random bits
+   recipNonce           present
+     -- value from senderNonce from certConf message
+   protectionAlg        MSG_MAC_ALG
+     -- only MAC protection is allowed for this message.
+   senderKID            referenceNum
+   body                 PKIConf
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+
+D.5.  Certificate Request
+
+   An (initialized) end entity requests a certificate from a CA (for any
+   reason).  When the CA responds with a message containing a
+   certificate, the end entity replies with a certificate confirmation.
+   The CA replies with a PKIConfirm, to close the transaction.  All
+   messages are authenticated.
+
+   The profile for this exchange is identical to that given in Appendix
+   D.4, with the following exceptions:
+
+   o  sender name SHOULD be present
+
+   o  protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY
+      also be supported) in request, response, certConfirm, and
+      PKIConfirm messages;
+
+   o  senderKID and recipKID are only present if required for message
+      verification;
+
+   o  body is cr or cp;
+
+   o  body may contain one or two CertReqMsg structures, but either
+      CertReqMsg may be used to request certification of a locally-
+      generated public key or a centrally-generated public key (i.e.,
+      the position-dependence requirement of Appendix D.4 is removed);
+
+   o  protection bits are calculated according to the protectionAlg
+      field.
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 74]
+
+RFC 4210                          CMP                     September 2005
+
+
+D.6.  Key Update Request
+
+   An (initialized) end entity requests a certificate from a CA (to
+   update the key pair and/or corresponding certificate that it already
+   possesses).  When the CA responds with a message containing a
+   certificate, the end entity replies with a certificate confirmation.
+   The CA replies with a PKIConfirm, to close the transaction.  All
+   messages are authenticated.
+
+   The profile for this exchange is identical to that given in Appendix
+   D.4, with the following exceptions:
+
+   1.  sender name SHOULD be present
+
+   2.  protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY
+       also be supported) in request, response, certConfirm, and
+       PKIConfirm messages;
+
+   3.  senderKID and recipKID are only present if required for message
+       verification;
+
+   4.  body is kur or kup;
+
+   5.  body may contain one or two CertReqMsg structures, but either
+       CertReqMsg may be used to request certification of a locally-
+       generated public key or a centrally-generated public key (i.e.,
+       the position-dependence requirement of Appendix D.4 is removed);
+
+   6.  protection bits are calculated according to the protectionAlg
+       field;
+
+   7.  regCtrl OldCertId SHOULD be used (unless it is clear to both
+       sender and receiver -- by means not specified in this document --
+       that it is not needed).
+
+Appendix E.  PKI Management Message Profiles (OPTIONAL).
+
+   This appendix contains detailed profiles for those PKIMessages that
+   MAY be supported by implementations (in addition to the messages
+   which MUST be supported; see Section 6 and Appendix D).
+
+   Profiles for the PKIMessages used in the following PKI management
+   operations are provided:
+
+   o  root CA key update
+
+   o  information request/response
+
+
+
+
+Adams, et al.               Standards Track                    [Page 75]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  cross-certification request/response (1-way)
+
+   o  in-band initialization using external identity certificate
+
+   Later versions of this document may extend the above to include
+   profiles for the operations listed below (along with other
+   operations, if desired).
+
+   o  revocation request
+
+   o  certificate publication
+
+   o  CRL publication
+
+E.1.  General Rules for Interpretation of These Profiles.
+
+   Identical to Appendix D.1.
+
+E.2.  Algorithm Use Profile
+
+   Identical to Appendix D.2.
+
+E.3.  Self-Signed Certificates
+
+   Profile of how a Certificate structure may be "self-signed".  These
+   structures are used for distribution of CA public keys.  This can
+   occur in one of three ways (see Section 4.4 above for a description
+   of the use of these structures):
+
+   Type          Function
+   -----------------------------------------------------------------
+   newWithNew a true "self-signed" certificate; the contained
+              public key MUST be usable to verify the signature
+              (though this provides only integrity and no
+              authentication whatsoever)
+   oldWithNew previous root CA public key signed with new private key
+   newWithOld new root CA public key signed with previous private key
+
+   Such certificates (including relevant extensions) must contain
+   "sensible" values for all fields.  For example, when present,
+   subjectAltName MUST be identical to issuerAltName, and, when present,
+   keyIdentifiers must contain appropriate values, et cetera.
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 76]
+
+RFC 4210                          CMP                     September 2005
+
+
+E.4.  Root CA Key Update
+
+   A root CA updates its key pair.  It then produces a CA key update
+   announcement message that can be made available (via some transport
+   mechanism) to the relevant end entities.  A confirmation message is
+   NOT REQUIRED from the end entities.
+
+   ckuann message:
+
+    Field        Value                        Comment
+   --------------------------------------------------------------
+    sender       CA name CA name
+    body         ckuann(CAKeyUpdAnnContent)
+    oldWithNew   present                  see Appendix E.3 above
+    newWithOld   present                  see Appendix E.3 above
+    newWithNew   present                  see Appendix E.3 above
+    extraCerts   optionally present       can be used to "publish"
+                                          certificates (e.g.,
+                                          certificates signed using
+                                          the new private key)
+
+E.5.  PKI Information Request/Response
+
+   The end entity sends a general message to the PKI requesting details
+   that will be required for later PKI management operations.  RA/CA
+   responds with a general response.  If an RA generates the response,
+   then it will simply forward the equivalent message that it previously
+   received from the CA, with the possible addition of certificates to
+   the extraCerts fields of the PKIMessage.  A confirmation message is
+   NOT REQUIRED from the end entity.
+
+   Message Flows:
+
+   Step# End entity                        PKI
+
+      1  format genm
+      2                ->   genm   ->
+      3                                    handle genm
+      4                                    produce genp
+      5                <-   genp   <-
+      6  handle genp
+
+   genM:
+
+   Field               Value
+
+   recipient           CA name
+     -- the name of the CA as contained in issuerAltName
+
+
+
+Adams, et al.               Standards Track                    [Page 77]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- extensions or issuer fields within certificates
+   protectionAlg       MSG_MAC_ALG or MSG_SIG_ALG
+     -- any authenticated protection alg.
+   SenderKID           present if required
+     -- must be present if required for verification of message
+     -- protection
+   freeText            any valid value
+   body                genr (GenReqContent)
+   GenMsgContent       empty SEQUENCE
+     -- all relevant information requested
+   protection          present
+     -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG
+
+   genP:
+
+   Field                Value
+
+   sender               CA name
+     -- name of the CA which produced the message
+   protectionAlg        MSG_MAC_ALG or MSG_SIG_ALG
+     -- any authenticated protection alg.
+   senderKID            present if required
+     -- must be present if required for verification of message
+     -- protection
+   body                 genp (GenRepContent)
+   CAProtEncCert        present (object identifier one
+                        of PROT_ENC_ALG), with relevant
+                        value
+     -- to be used if end entity needs to encrypt information for
+     -- the CA (e.g., private key for recovery purposes)
+
+   SignKeyPairTypes     present, with relevant value
+     -- the set of signature algorithm identifiers that this CA will
+     -- certify for subject public keys
+   EncKeyPairTypes      present, with relevant value
+     -- the set of encryption/key agreement algorithm identifiers that
+     -- this CA will certify for subject public keys
+   PreferredSymmAlg     present (object identifier one
+                        of PROT_SYM_ALG) , with relevant
+                        value
+     -- the symmetric algorithm that this CA expects to be used
+     -- in later PKI messages (for encryption)
+   CAKeyUpdateInfo      optionally present, with
+                        relevant value
+     -- the CA MAY provide information about a relevant root CA
+     -- key pair using this field (note that this does not imply
+     -- that the responding CA is the root CA in question)
+   CurrentCRL           optionally present, with relevant value
+
+
+
+Adams, et al.               Standards Track                    [Page 78]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- the CA MAY provide a copy of a complete CRL (i.e.,
+     -- fullest possible one)
+   protection           present
+     -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG
+   extraCerts           optionally present
+     -- can be used to send some certificates to the end
+     -- entity. An RA MAY add its certificate here.
+
+E.6.  Cross Certification Request/Response (1-way)
+
+   Creation of a single cross-certificate (i.e., not two at once).  The
+   requesting CA MAY choose who is responsible for publication of the
+   cross-certificate created by the responding CA through use of the
+   PKIPublicationInfo control.
+
+   Preconditions:
+
+   1.  Responding CA can verify the origin of the request (possibly
+       requiring out-of-band means) before processing the request.
+
+   2.  Requesting CA can authenticate the authenticity of the origin of
+       the response (possibly requiring out-of-band means) before
+       processing the response
+
+   The use of certificate confirmation and the corresponding server
+   confirmation is determined by the generalInfo field in the PKIHeader
+   (see Section 5.1.1).  The following profile does not mandate support
+   for either confirmation.
+
+   Message Flows:
+
+   Step# Requesting CA                       Responding CA
+     1   format ccr
+     2                   ->    ccr    ->
+     3                                       handle ccr
+     4                                       produce ccp
+     5                   <-    ccp    <-
+     6   handle ccp
+
+   ccr:
+
+   Field                 Value
+
+   sender                Requesting CA name
+     -- the name of the CA who produced the message
+   recipient             Responding CA name
+     -- the name of the CA who is being asked to produce a certificate
+   messageTime           time of production of message
+
+
+
+Adams, et al.               Standards Track                    [Page 79]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- current time at requesting CA
+   protectionAlg         MSG_SIG_ALG
+     -- only signature protection is allowed for this request
+   senderKID             present if required
+     -- must be present if required for verification of message
+     -- protection
+   recipKID             present if required
+     -- must be present if required for verification of message
+     -- protection
+   transactionID         present
+     -- implementation-specific value, meaningful to requesting CA.
+     -- [If already in use at responding CA then a rejection message
+     -- MUST be produced by responding CA]
+   senderNonce           present
+     -- 128 (pseudo-)random bits
+   freeText              any valid value
+   body                  ccr (CertReqMessages)
+                         only one CertReqMsg
+                         allowed
+     -- if multiple cross certificates are required, they MUST be
+     -- packaged in separate PKIMessages
+   certTemplate          present
+     -- details follow
+   version               v1 or v3
+     -- v3 STRONGLY RECOMMENDED
+   signingAlg            present
+     -- the requesting CA must know in advance with which algorithm it
+     -- wishes the certificate to be signed
+
+   subject               present
+     -- may be NULL-DN only if subjectAltNames extension value proposed
+   validity              present
+     -- MUST be completely specified (i.e., both fields present)
+   issuer                present
+     -- may be NULL-DN only if issuerAltNames extension value proposed
+   publicKey             present
+     -- the key to be certified (which must be for a signing algorithm)
+   extensions            optionally present
+     -- a requesting CA must propose values for all extensions
+     -- that it requires to be in the cross-certificate
+   POPOSigningKey        present
+     -- see Section D3: Proof-of-possession profile
+   protection            present
+     -- bits calculated using MSG_SIG_ALG
+   extraCerts            optionally present
+     -- MAY contain any additional certificates that requester wishes
+     -- to include
+
+
+
+
+Adams, et al.               Standards Track                    [Page 80]
+
+RFC 4210                          CMP                     September 2005
+
+
+   ccp:
+
+   Field                 Value
+
+   sender                Responding CA name
+     -- the name of the CA who produced the message
+   recipient             Requesting CA name
+     -- the name of the CA who asked for production of a certificate
+   messageTime           time of production of message
+     -- current time at responding CA
+   protectionAlg         MSG_SIG_ALG
+     -- only signature protection is allowed for this message
+   senderKID             present if required
+     -- must be present if required for verification of message
+     -- protection
+   recipKID              present if required
+   transactionID         present
+     -- value from corresponding ccr message
+   senderNonce           present
+     -- 128 (pseudo-)random bits
+   recipNonce            present
+   -- senderNonce from corresponding ccr message
+   freeText              any valid value
+   body                  ccp (CertRepMessage)
+                         only one CertResponse allowed
+     -- if multiple cross certificates are required they MUST be
+     -- packaged in separate PKIMessages
+   response              present
+   status                present
+
+   PKIStatusInfo.status  present
+     -- if PKIStatusInfo.status is one of:
+     --   accepted, or
+     --   grantedWithMods,
+     -- then certifiedKeyPair MUST be present and failInfo MUST
+     -- be absent
+
+   failInfo              present depending on
+                         PKIStatusInfo.status
+     -- if PKIStatusInfo.status is:
+     --   rejection
+     -- then certifiedKeyPair MUST be absent and failInfo MUST be
+     -- present and contain appropriate bit settings
+
+   certifiedKeyPair      present depending on
+                         PKIStatusInfo.status
+   certificate           present depending on
+                         certifiedKeyPair
+
+
+
+Adams, et al.               Standards Track                    [Page 81]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- content of actual certificate must be examined by requesting CA
+     -- before publication
+   protection            present
+     -- bits calculated using MSG_SIG_ALG
+   extraCerts            optionally present
+     -- MAY contain any additional certificates that responder wishes
+     -- to include
+
+E.7.  In-Band Initialization Using External Identity Certificate
+
+   An (uninitialized) end entity wishes to initialize into the PKI with
+   a CA, CA-1.  It uses, for authentication purposes, a pre-existing
+   identity certificate issued by another (external) CA, CA-X.  A trust
+   relationship must already have been established between CA-1 and CA-X
+   so that CA-1 can validate the EE identity certificate signed by CA-X.
+   Furthermore, some mechanism must already have been established within
+   the Personal Security Environment (PSE) of the EE that would allow it
+   to authenticate and verify PKIMessages signed by CA-1 (as one
+   example, the PSE may contain a certificate issued for the public key
+   of CA-1, signed by another CA that the EE trusts on the basis of
+   out-of-band authentication techniques).
+
+   The EE sends an initialization request to start the transaction.
+   When CA-1 responds with a message containing the new certificate, the
+   end entity replies with a certificate confirmation.  CA-1 replies
+   with a PKIConfirm to close the transaction.  All messages are signed
+   (the EE messages are signed using the private key that corresponds to
+   the public key in its external identity certificate; the CA-1
+   messages are signed using the private key that corresponds to the
+   public key in a
+
+   certificate that can be chained to a trust anchor in the EE's PSE).
+
+   The profile for this exchange is identical to that given in Appendix
+   D.4, with the following exceptions:
+
+   o  the EE and CA-1 do not share a symmetric MACing key (i.e., there
+      is no out-of-band shared secret information between these
+      entities);
+
+   o  sender name in ir MUST be present (and identical to the subject
+      name present in the external identity certificate);
+
+   o  protectionAlg of MSG_SIG_ALG MUST be used in all messages;
+
+   o  external identity cert.  MUST be carried in ir extraCerts field
+
+   o  senderKID and recipKID are not used;
+
+
+
+Adams, et al.               Standards Track                    [Page 82]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  body is ir or ip;
+
+   o  protection bits are calculated according to the protectionAlg
+      field.
+
+Appendix F.  Compilable ASN.1 Definitions
+
+     PKIXCMP {iso(1) identified-organization(3)
+           dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+           id-mod(0) id-mod-cmp2000(16)}
+
+     DEFINITIONS EXPLICIT TAGS ::=
+
+     BEGIN
+
+     -- EXPORTS ALL --
+
+     IMPORTS
+
+         Certificate, CertificateList, Extensions, AlgorithmIdentifier,
+         UTF8String -- if required; otherwise, comment out
+                FROM PKIX1Explicit88 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-pkix1-explicit-88(1)}
+
+         GeneralName, KeyIdentifier
+                FROM PKIX1Implicit88 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-pkix1-implicit-88(2)}
+
+         CertTemplate, PKIPublicationInfo, EncryptedValue, CertId,
+         CertReqMessages
+                FROM PKIXCRMF-2005 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-mod-crmf2005(36)}
+
+         -- see also the behavioral clarifications to CRMF codified in
+         -- Appendix C of this specification
+
+         CertificationRequest
+                FROM PKCS-10 {iso(1) member-body(2)
+                              us(840) rsadsi(113549)
+                              pkcs(1) pkcs-10(10) modules(1) pkcs-10(1)}
+
+         -- (specified in RFC 2986 with 1993 ASN.1 syntax and IMPLICIT
+         -- tags).  Alternatively, implementers may directly include
+         -- the [PKCS10] syntax in this module
+
+
+
+
+Adams, et al.               Standards Track                    [Page 83]
+
+RFC 4210                          CMP                     September 2005
+
+
+         ;
+
+   -- the rest of the module contains locally-defined OIDs and
+   -- constructs
+
+      CMPCertificate ::= CHOICE {
+         x509v3PKCert        Certificate
+      }
+   -- This syntax, while bits-on-the-wire compatible with the
+   -- standard X.509 definition of "Certificate", allows the
+   -- possibility of future certificate types (such as X.509
+   -- attribute certificates, WAP WTLS certificates, or other kinds
+   -- of certificates) within this certificate management protocol,
+   -- should a need ever arise to support such generality.  Those
+   -- implementations that do not foresee a need to ever support
+   -- other certificate types MAY, if they wish, comment out the
+   -- above structure and "un-comment" the following one prior to
+   -- compiling this ASN.1 module.  (Note that interoperability
+   -- with implementations that don't do this will be unaffected by
+   -- this change.)
+
+   -- CMPCertificate ::= Certificate
+
+      PKIMessage ::= SEQUENCE {
+         header           PKIHeader,
+         body             PKIBody,
+         protection   [0] PKIProtection OPTIONAL,
+         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL
+     }
+
+     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
+
+     PKIHeader ::= SEQUENCE {
+         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
+         sender              GeneralName,
+         -- identifies the sender
+         recipient           GeneralName,
+         -- identifies the intended recipient
+         messageTime     [0] GeneralizedTime         OPTIONAL,
+         -- time of production of this message (used when sender
+         -- believes that the transport will be "suitable"; i.e.,
+         -- that the time will still be meaningful upon receipt)
+         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
+         -- algorithm used for calculation of protection bits
+         senderKID       [2] KeyIdentifier           OPTIONAL,
+         recipKID        [3] KeyIdentifier           OPTIONAL,
+         -- to identify specific keys used for protection
+
+
+
+Adams, et al.               Standards Track                    [Page 84]
+
+RFC 4210                          CMP                     September 2005
+
+
+         transactionID   [4] OCTET STRING            OPTIONAL,
+         -- identifies the transaction; i.e., this will be the same in
+         -- corresponding request, response, certConf, and PKIConf
+         -- messages
+         senderNonce     [5] OCTET STRING            OPTIONAL,
+         recipNonce      [6] OCTET STRING            OPTIONAL,
+         -- nonces used to provide replay protection, senderNonce
+         -- is inserted by the creator of this message; recipNonce
+         -- is a nonce previously inserted in a related message by
+         -- the intended recipient of this message
+         freeText        [7] PKIFreeText             OPTIONAL,
+         -- this may be used to indicate context-specific instructions
+         -- (this field is intended for human consumption)
+         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
+                                InfoTypeAndValue     OPTIONAL
+         -- this may be used to convey context-specific information
+         -- (this field not primarily intended for human consumption)
+     }
+
+     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
+         -- text encoded as UTF-8 String [RFC3629] (note: each
+         -- UTF8String MAY include an [RFC3066] language tag
+         -- to indicate the language of the contained text
+         -- see [RFC2482] for details)
+
+     PKIBody ::= CHOICE {       -- message-specific body elements
+         ir       [0]  CertReqMessages,        --Initialization Request
+         ip       [1]  CertRepMessage,         --Initialization Response
+         cr       [2]  CertReqMessages,        --Certification Request
+         cp       [3]  CertRepMessage,         --Certification Response
+         p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
+         popdecc  [5]  POPODecKeyChallContent, --pop Challenge
+         popdecr  [6]  POPODecKeyRespContent,  --pop Response
+         kur      [7]  CertReqMessages,        --Key Update Request
+         kup      [8]  CertRepMessage,         --Key Update Response
+         krr      [9]  CertReqMessages,        --Key Recovery Request
+         krp      [10] KeyRecRepContent,       --Key Recovery Response
+         rr       [11] RevReqContent,          --Revocation Request
+         rp       [12] RevRepContent,          --Revocation Response
+         ccr      [13] CertReqMessages,        --Cross-Cert. Request
+         ccp      [14] CertRepMessage,         --Cross-Cert. Response
+         ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
+         cann     [16] CertAnnContent,         --Certificate Ann.
+         rann     [17] RevAnnContent,          --Revocation Ann.
+         crlann   [18] CRLAnnContent,          --CRL Announcement
+         pkiconf  [19] PKIConfirmContent,      --Confirmation
+         nested   [20] NestedMessageContent,   --Nested Message
+         genm     [21] GenMsgContent,          --General Message
+
+
+
+Adams, et al.               Standards Track                    [Page 85]
+
+RFC 4210                          CMP                     September 2005
+
+
+         genp     [22] GenRepContent,          --General Response
+         error    [23] ErrorMsgContent,        --Error Message
+         certConf [24] CertConfirmContent,     --Certificate confirm
+         pollReq  [25] PollReqContent,         --Polling request
+         pollRep  [26] PollRepContent          --Polling response
+     }
+
+     PKIProtection ::= BIT STRING
+
+     ProtectedPart ::= SEQUENCE {
+         header    PKIHeader,
+         body      PKIBody
+     }
+
+     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
+     PBMParameter ::= SEQUENCE {
+         salt                OCTET STRING,
+         -- note:  implementations MAY wish to limit acceptable sizes
+         -- of this string to values appropriate for their environment
+         -- in order to reduce the risk of denial-of-service attacks
+         owf                 AlgorithmIdentifier,
+         -- AlgId for a One-Way Function (SHA-1 recommended)
+         iterationCount      INTEGER,
+         -- number of times the OWF is applied
+         -- note:  implementations MAY wish to limit acceptable sizes
+         -- of this integer to values appropriate for their environment
+         -- in order to reduce the risk of denial-of-service attacks
+         mac                 AlgorithmIdentifier
+         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+     }   -- or HMAC [RFC2104, RFC2202])
+
+     id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
+     DHBMParameter ::= SEQUENCE {
+         owf                 AlgorithmIdentifier,
+         -- AlgId for a One-Way Function (SHA-1 recommended)
+         mac                 AlgorithmIdentifier
+         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+     }   -- or HMAC [RFC2104, RFC2202])
+
+
+     NestedMessageContent ::= PKIMessages
+
+     PKIStatus ::= INTEGER {
+         accepted                (0),
+         -- you got exactly what you asked for
+         grantedWithMods        (1),
+         -- you got something like what you asked for; the
+         -- requester is responsible for ascertaining the differences
+
+
+
+Adams, et al.               Standards Track                    [Page 86]
+
+RFC 4210                          CMP                     September 2005
+
+
+         rejection              (2),
+         -- you don't get it, more information elsewhere in the message
+         waiting                (3),
+         -- the request body part has not yet been processed; expect to
+         -- hear more later (note: proper handling of this status
+         -- response MAY use the polling req/rep PKIMessages specified
+         -- in Section 5.3.22; alternatively, polling in the underlying
+         -- transport layer MAY have some utility in this regard)
+         revocationWarning      (4),
+         -- this message contains a warning that a revocation is
+         -- imminent
+         revocationNotification (5),
+         -- notification that a revocation has occurred
+         keyUpdateWarning       (6)
+         -- update already done for the oldCertId specified in
+         -- CertReqMsg
+     }
+
+     PKIFailureInfo ::= BIT STRING {
+     -- since we can fail in more than one way!
+     -- More codes may be added in the future if/when required.
+         badAlg              (0),
+         -- unrecognized or unsupported Algorithm Identifier
+         badMessageCheck     (1),
+         -- integrity check failed (e.g., signature did not verify)
+         badRequest          (2),
+         -- transaction not permitted or supported
+         badTime             (3),
+         -- messageTime was not sufficiently close to the system time,
+         -- as defined by local policy
+         badCertId           (4),
+         -- no certificate could be found matching the provided criteria
+         badDataFormat       (5),
+         -- the data submitted has the wrong format
+         wrongAuthority      (6),
+         -- the authority indicated in the request is different from the
+         -- one creating the response token
+         incorrectData       (7),
+         -- the requester's data is incorrect (for notary services)
+         missingTimeStamp    (8),
+         -- when the timestamp is missing but should be there
+         -- (by policy)
+         badPOP              (9),
+         -- the proof-of-possession failed
+         certRevoked         (10),
+            -- the certificate has already been revoked
+         certConfirmed       (11),
+            -- the certificate has already been confirmed
+
+
+
+Adams, et al.               Standards Track                    [Page 87]
+
+RFC 4210                          CMP                     September 2005
+
+
+         wrongIntegrity      (12),
+            -- invalid integrity, password based instead of signature or
+            -- vice versa
+         badRecipientNonce   (13),
+            -- invalid recipient nonce, either missing or wrong value
+         timeNotAvailable    (14),
+            -- the TSA's time source is not available
+         unacceptedPolicy    (15),
+            -- the requested TSA policy is not supported by the TSA.
+         unacceptedExtension (16),
+            -- the requested extension is not supported by the TSA.
+         addInfoNotAvailable (17),
+            -- the additional information requested could not be
+            -- understood or is not available
+         badSenderNonce      (18),
+            -- invalid sender nonce, either missing or wrong size
+         badCertTemplate     (19),
+            -- invalid cert. template or missing mandatory information
+         signerNotTrusted    (20),
+            -- signer of the message unknown or not trusted
+         transactionIdInUse  (21),
+            -- the transaction identifier is already in use
+         unsupportedVersion  (22),
+            -- the version of the message is not supported
+         notAuthorized       (23),
+            -- the sender was not authorized to make the preceding
+            -- request or perform the preceding action
+         systemUnavail       (24),
+         -- the request cannot be handled due to system unavailability
+         systemFailure       (25),
+         -- the request cannot be handled due to system failure
+         duplicateCertReq    (26)
+         -- certificate cannot be issued because a duplicate
+         -- certificate already exists
+     }
+
+     PKIStatusInfo ::= SEQUENCE {
+         status        PKIStatus,
+         statusString  PKIFreeText     OPTIONAL,
+         failInfo      PKIFailureInfo  OPTIONAL
+     }
+
+     OOBCert ::= CMPCertificate
+
+     OOBCertHash ::= SEQUENCE {
+         hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
+         certId      [1] CertId                  OPTIONAL,
+         hashVal         BIT STRING
+
+
+
+Adams, et al.               Standards Track                    [Page 88]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- hashVal is calculated over the DER encoding of the
+         -- self-signed certificate with the identifier certID.
+     }
+
+     POPODecKeyChallContent ::= SEQUENCE OF Challenge
+     -- One Challenge per encryption key certification request (in the
+     -- same order as these requests appear in CertReqMessages).
+
+     Challenge ::= SEQUENCE {
+         owf                 AlgorithmIdentifier  OPTIONAL,
+
+         -- MUST be present in the first Challenge; MAY be omitted in
+         -- any subsequent Challenge in POPODecKeyChallContent (if
+         -- omitted, then the owf used in the immediately preceding
+         -- Challenge is to be used).
+
+         witness             OCTET STRING,
+         -- the result of applying the one-way function (owf) to a
+         -- randomly-generated INTEGER, A.  [Note that a different
+         -- INTEGER MUST be used for each Challenge.]
+         challenge           OCTET STRING
+         -- the encryption (under the public key for which the cert.
+         -- request is being made) of Rand, where Rand is specified as
+         --   Rand ::= SEQUENCE {
+         --      int      INTEGER,
+         --       - the randomly-generated INTEGER A (above)
+         --      sender   GeneralName
+         --       - the sender's name (as included in PKIHeader)
+         --   }
+     }
+
+     POPODecKeyRespContent ::= SEQUENCE OF INTEGER
+     -- One INTEGER per encryption key certification request (in the
+     -- same order as these requests appear in CertReqMessages).  The
+     -- retrieved INTEGER A (above) is returned to the sender of the
+     -- corresponding Challenge.
+
+     CertRepMessage ::= SEQUENCE {
+         caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL,
+         response         SEQUENCE OF CertResponse
+     }
+
+     CertResponse ::= SEQUENCE {
+         certReqId           INTEGER,
+         -- to match this response with corresponding request (a value
+         -- of -1 is to be used if certReqId is not specified in the
+         -- corresponding request)
+
+
+
+Adams, et al.               Standards Track                    [Page 89]
+
+RFC 4210                          CMP                     September 2005
+
+
+         status              PKIStatusInfo,
+         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
+         rspInfo             OCTET STRING        OPTIONAL
+         -- analogous to the id-regInfo-utf8Pairs string defined
+         -- for regInfo in CertReqMsg [CRMF]
+     }
+
+     CertifiedKeyPair ::= SEQUENCE {
+         certOrEncCert       CertOrEncCert,
+         privateKey      [0] EncryptedValue      OPTIONAL,
+         -- see [CRMF] for comment on encoding
+         publicationInfo [1] PKIPublicationInfo  OPTIONAL
+     }
+
+     CertOrEncCert ::= CHOICE {
+         certificate     [0] CMPCertificate,
+         encryptedCert   [1] EncryptedValue
+     }
+
+     KeyRecRepContent ::= SEQUENCE {
+         status                  PKIStatusInfo,
+         newSigCert          [0] CMPCertificate OPTIONAL,
+         caCerts             [1] SEQUENCE SIZE (1..MAX) OF
+                                             CMPCertificate OPTIONAL,
+         keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
+                                             CertifiedKeyPair OPTIONAL
+     }
+
+     RevReqContent ::= SEQUENCE OF RevDetails
+
+     RevDetails ::= SEQUENCE {
+         certDetails         CertTemplate,
+         -- allows requester to specify as much as they can about
+         -- the cert. for which revocation is requested
+         -- (e.g., for cases in which serialNumber is not available)
+         crlEntryDetails     Extensions       OPTIONAL
+         -- requested crlEntryExtensions
+     }
+
+     RevRepContent ::= SEQUENCE {
+         status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+         -- in same order as was sent in RevReqContent
+         revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
+                                             OPTIONAL,
+         -- IDs for which revocation was requested
+         -- (same order as status)
+         crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+                                             OPTIONAL
+
+
+
+Adams, et al.               Standards Track                    [Page 90]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- the resulting CRLs (there may be more than one)
+     }
+
+     CAKeyUpdAnnContent ::= SEQUENCE {
+         oldWithNew   CMPCertificate, -- old pub signed with new priv
+         newWithOld   CMPCertificate, -- new pub signed with old priv
+         newWithNew   CMPCertificate  -- new pub signed with new priv
+     }
+
+     CertAnnContent ::= CMPCertificate
+
+     RevAnnContent ::= SEQUENCE {
+         status              PKIStatus,
+         certId              CertId,
+         willBeRevokedAt     GeneralizedTime,
+         badSinceDate        GeneralizedTime,
+         crlDetails          Extensions  OPTIONAL
+         -- extra CRL details (e.g., crl number, reason, location, etc.)
+     }
+
+     CRLAnnContent ::= SEQUENCE OF CertificateList
+
+     CertConfirmContent ::= SEQUENCE OF CertStatus
+
+     CertStatus ::= SEQUENCE {
+        certHash    OCTET STRING,
+        -- the hash of the certificate, using the same hash algorithm
+        -- as is used to create and verify the certificate signature
+        certReqId   INTEGER,
+        -- to match this confirmation with the corresponding req/rep
+        statusInfo  PKIStatusInfo OPTIONAL
+     }
+
+     PKIConfirmContent ::= NULL
+
+     InfoTypeAndValue ::= SEQUENCE {
+         infoType               OBJECT IDENTIFIER,
+         infoValue              ANY DEFINED BY infoType  OPTIONAL
+     }
+     -- Example InfoTypeAndValue contents include, but are not limited
+     -- to, the following (un-comment in this ASN.1 module and use as
+     -- appropriate for a given environment):
+     --
+     --   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
+     --      CAProtEncCertValue      ::= CMPCertificate
+     --   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
+     --      SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
+     --   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
+
+
+
+Adams, et al.               Standards Track                    [Page 91]
+
+RFC 4210                          CMP                     September 2005
+
+
+     --      EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
+     --   id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
+     --      PreferredSymmAlgValue   ::= AlgorithmIdentifier
+     --   id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
+     --      CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
+     --   id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
+     --      CurrentCRLValue         ::= CertificateList
+     --   id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
+     --      UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
+     --   id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
+     --      KeyPairParamReqValue    ::= OBJECT IDENTIFIER
+     --   id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
+     --      KeyPairParamRepValue    ::= AlgorithmIdentifer
+     --   id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
+     --      RevPassphraseValue      ::= EncryptedValue
+     --   id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
+     --      ImplicitConfirmValue    ::= NULL
+     --   id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
+     --      ConfirmWaitTimeValue    ::= GeneralizedTime
+     --   id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
+     --      OrigPKIMessageValue     ::= PKIMessages
+     --   id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
+     --      SuppLangTagsValue       ::= SEQUENCE OF UTF8String
+     --
+     -- where
+     --
+     --   id-pkix OBJECT IDENTIFIER ::= {
+     --      iso(1) identified-organization(3)
+     --      dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
+     -- and
+     --   id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
+     --
+     --
+     -- This construct MAY also be used to define new PKIX Certificate
+     -- Management Protocol request and response messages, or general-
+     -- purpose (e.g., announcement) messages for future needs or for
+     -- specific environments.
+
+     GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
+
+     -- May be sent by EE, RA, or CA (depending on message content).
+     -- The OPTIONAL infoValue parameter of InfoTypeAndValue will
+     -- typically be omitted for some of the examples given above.
+     -- The receiver is free to ignore any contained OBJ. IDs that it
+     -- does not recognize. If sent from EE to CA, the empty set
+     -- indicates that the CA may send
+     -- any/all information that it wishes.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 92]
+
+RFC 4210                          CMP                     September 2005
+
+
+     GenRepContent ::= SEQUENCE OF InfoTypeAndValue
+     -- Receiver MAY ignore any contained OIDs that it does not
+     -- recognize.
+
+     ErrorMsgContent ::= SEQUENCE {
+         pKIStatusInfo          PKIStatusInfo,
+         errorCode              INTEGER           OPTIONAL,
+         -- implementation-specific error codes
+         errorDetails           PKIFreeText       OPTIONAL
+         -- implementation-specific error details
+     }
+
+     PollReqContent ::= SEQUENCE OF SEQUENCE {
+         certReqId              INTEGER
+     }
+
+     PollRepContent ::= SEQUENCE OF SEQUENCE {
+         certReqId              INTEGER,
+         checkAfter             INTEGER,  -- time in seconds
+         reason                 PKIFreeText OPTIONAL
+     }
+
+     END -- of CMP module
+
+Appendix G.  Acknowledgements
+
+   The authors gratefully acknowledge the contributions of various
+   members of the IETF PKIX Working Group and the ICSA CA-talk mailing
+   list (a list solely devoted to discussing CMP interoperability
+   efforts).  Many of these contributions significantly clarified and
+   improved the utility of this specification.  Tomi Kause thanks Vesa
+   Suontama and Toni Tammisalo for review and comments.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 93]
+
+RFC 4210                          CMP                     September 2005
+
+
+Authors' Addresses
+
+   Carlisle Adams
+   University of Ottawa
+   800 King Edward Avenue
+   P.O.Box 450, Station A
+   Ottawa, Ontario  K1N 6N5
+   CA
+
+   Phone: (613) 562-5800 ext. 2345
+   Fax:   (613) 562-5664
+   EMail: cadams@site.uottawa.ca
+
+
+   Stephen Farrell
+   Trinity College Dublin
+   Distributed Systems Group
+   Computer Science Department
+   Dublin
+   IE
+
+   Phone: +353-1-608-2945
+   EMail: stephen.farrell@cs.tcd.ie
+
+
+   Tomi Kause
+   SSH Communications Security Corp
+   Valimotie 17
+   Helsinki  00380
+   FI
+
+   Phone: +358 20 500 7415
+   EMail: toka@ssh.com
+
+
+   Tero Mononen
+   SafeNet, Inc.
+   Fredrikinkatu 47
+   Helsinki  00100
+   FI
+
+   Phone: +358 20 500 7814
+   EMail: tmononen@safenet-inc.com
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 94]
+
+RFC 4210                          CMP                     September 2005
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2005).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 95]
+
diff -Naur crypto/crmf/crmf_asn.c crypto-/crmf/crmf_asn.c
--- cryptoold/crmf/crmf_asn.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/crmf/crmf_asn.c	2017-04-20 21:19:02.897277923 +0700
@@ -0,0 +1,1509 @@
+/* vim: set cino={1s noet ts=4 sts=4 sw=4: */
+/* crmf_asn.c
+ * OpenSSL ASN.1 definitions for CRMF (RFC 4211)
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <openssl/opensslconf.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+
+static const ASN1_TEMPLATE CRMF_PRIVATEKEYINFO_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PRIVATEKEYINFO, version),
+		.field_name = "version",
+		.item = &ASN1_INTEGER_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PRIVATEKEYINFO, AlgorithmIdentifier),
+		.field_name = "AlgorithmIdentifier",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PRIVATEKEYINFO, privateKey),
+		.field_name = "privateKey",
+		.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_PRIVATEKEYINFO, attributes),
+		.field_name = "attributes",
+		.item = &X509_ATTRIBUTE_it,
+		}
+};
+
+const ASN1_ITEM CRMF_PRIVATEKEYINFO_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_PRIVATEKEYINFO_seq_tt,
+	.tcount = sizeof(CRMF_PRIVATEKEYINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_PRIVATEKEYINFO),
+	.sname = "CRMF_PRIVATEKEYINFO",
+};
+
+	CRMF_PRIVATEKEYINFO *
+d2i_CRMF_PRIVATEKEYINFO(CRMF_PRIVATEKEYINFO **a, const unsigned char **in, long len)
+{
+	return (CRMF_PRIVATEKEYINFO*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_PRIVATEKEYINFO_it);
+}
+
+	int
+i2d_CRMF_PRIVATEKEYINFO(CRMF_PRIVATEKEYINFO *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_PRIVATEKEYINFO_it);
+}
+
+	CRMF_PRIVATEKEYINFO *
+CRMF_PRIVATEKEYINFO_new(void)
+{
+	return (CRMF_PRIVATEKEYINFO *)ASN1_item_new(&CRMF_PRIVATEKEYINFO_it);
+}
+
+void CRMF_PRIVATEKEYINFO_free(CRMF_PRIVATEKEYINFO *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_PRIVATEKEYINFO_it);
+}
+
+
+static const ASN1_TEMPLATE CRMF_ENCKEYWITHID_IDENTIFIER_ch_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 0,
+		.offset = offsetof(CRMF_ENCKEYWITHID_IDENTIFIER, value.string),
+		.field_name = "value.string",
+		.item = &ASN1_UTF8STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 1,
+		.offset = offsetof(CRMF_ENCKEYWITHID_IDENTIFIER, value.generalName),
+		.field_name = "value.generalName",
+		.item = &GENERAL_NAME_it,
+		}
+};
+
+const ASN1_ITEM CRMF_ENCKEYWITHID_IDENTIFIER_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CRMF_ENCKEYWITHID_IDENTIFIER, type),
+	.templates = CRMF_ENCKEYWITHID_IDENTIFIER_ch_tt,
+	.tcount = sizeof(CRMF_ENCKEYWITHID_IDENTIFIER_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_ENCKEYWITHID_IDENTIFIER),
+	.sname = "CRMF_ENCKEYWITHID_IDENTIFIER",
+};
+
+	CRMF_ENCKEYWITHID_IDENTIFIER *
+d2i_CRMF_ENCKEYWITHID_IDENTIFIER(CRMF_ENCKEYWITHID_IDENTIFIER **a, const unsigned char **in, long len)
+{
+	return (CRMF_ENCKEYWITHID_IDENTIFIER*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_ENCKEYWITHID_IDENTIFIER_it);
+}
+	int
+i2d_CRMF_ENCKEYWITHID_IDENTIFIER(CRMF_ENCKEYWITHID_IDENTIFIER *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_ENCKEYWITHID_IDENTIFIER_it);
+}
+
+	CRMF_ENCKEYWITHID_IDENTIFIER *
+CRMF_ENCKEYWITHID_IDENTIFIER_new(void)
+{
+	return (CRMF_ENCKEYWITHID_IDENTIFIER *)ASN1_item_new(&CRMF_ENCKEYWITHID_IDENTIFIER_it);
+}
+
+void CRMF_ENCKEYWITHID_IDENTIFIER_free(CRMF_ENCKEYWITHID_IDENTIFIER *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_ENCKEYWITHID_IDENTIFIER_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_ENCKEYWITHID_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_ENCKEYWITHID, privateKey),
+		.field_name = "privateKey",
+		.item = &CRMF_PRIVATEKEYINFO_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_ENCKEYWITHID, identifier),
+		.field_name = "identifier",
+		.item = &CRMF_ENCKEYWITHID_IDENTIFIER_it,
+		}
+};
+
+const ASN1_ITEM CRMF_ENCKEYWITHID_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_ENCKEYWITHID_seq_tt,
+	.tcount = sizeof(CRMF_ENCKEYWITHID_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_ENCKEYWITHID),
+	.sname = "CRMF_ENCKEYWITHID",
+};
+
+	CRMF_ENCKEYWITHID *
+d2i_CRMF_ENCKEYWITHID(CRMF_ENCKEYWITHID **a, const unsigned char **in, long len)
+{
+	return (CRMF_ENCKEYWITHID*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_ENCKEYWITHID_it);
+}
+	int
+i2d_CRMF_ENCKEYWITHID(CRMF_ENCKEYWITHID *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_ENCKEYWITHID_it);
+}
+
+	CRMF_ENCKEYWITHID *
+CRMF_ENCKEYWITHID_new(void)
+{
+	return (CRMF_ENCKEYWITHID *)ASN1_item_new(&CRMF_ENCKEYWITHID_it);
+}
+
+void CRMF_ENCKEYWITHID_free(CRMF_ENCKEYWITHID *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_ENCKEYWITHID_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_CERTID_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTID, issuer),
+		.field_name = "issuer",
+		.item = &GENERAL_NAME_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTID, serialNumber),
+		.field_name = "serialNumber",
+		.item = &ASN1_INTEGER_it,
+		}
+};
+
+const ASN1_ITEM CRMF_CERTID_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_CERTID_seq_tt,
+	.tcount = sizeof(CRMF_CERTID_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_CERTID),
+	.sname = "CRMF_CERTID",
+};
+
+	CRMF_CERTID *
+d2i_CRMF_CERTID(CRMF_CERTID **a, const unsigned char **in, long len)
+{
+	return (CRMF_CERTID*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_CERTID_it);
+}
+	int
+i2d_CRMF_CERTID(CRMF_CERTID *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_CERTID_it);
+}
+
+	CRMF_CERTID *
+CRMF_CERTID_new(void)
+{
+	return (CRMF_CERTID *)ASN1_item_new(&CRMF_CERTID_it);
+}
+
+void CRMF_CERTID_free(CRMF_CERTID *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_CERTID_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_ENCRYPTEDVALUE_seq_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_ENCRYPTEDVALUE, intendedAlg),
+		.field_name = "intendedAlg",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 1,
+		.offset = offsetof(CRMF_ENCRYPTEDVALUE, symmAlg),
+		.field_name = "symmAlg",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 2,
+		.offset = offsetof(CRMF_ENCRYPTEDVALUE, encSymmKey),
+		.field_name = "encSymmKey",
+		.item = &ASN1_BIT_STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 3,
+		.offset = offsetof(CRMF_ENCRYPTEDVALUE, keyAlg),
+		.field_name = "keyAlg",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 4,
+		.offset = offsetof(CRMF_ENCRYPTEDVALUE, valueHint),
+		.field_name = "valueHint",
+		.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_ENCRYPTEDVALUE, encValue),
+		.field_name = "encValue",
+		.item = &ASN1_BIT_STRING_it,
+		}
+};
+
+const ASN1_ITEM CRMF_ENCRYPTEDVALUE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_ENCRYPTEDVALUE_seq_tt,
+	.tcount = sizeof(CRMF_ENCRYPTEDVALUE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_ENCRYPTEDVALUE),
+	.sname = "CRMF_ENCRYPTEDVALUE",
+};
+
+	CRMF_ENCRYPTEDVALUE *
+d2i_CRMF_ENCRYPTEDVALUE(CRMF_ENCRYPTEDVALUE **a, const unsigned char **in, long len)
+{
+	return (CRMF_ENCRYPTEDVALUE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_ENCRYPTEDVALUE_it);
+}
+	int
+i2d_CRMF_ENCRYPTEDVALUE(CRMF_ENCRYPTEDVALUE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_ENCRYPTEDVALUE_it);
+}
+
+	CRMF_ENCRYPTEDVALUE *
+CRMF_ENCRYPTEDVALUE_new(void)
+{
+	return (CRMF_ENCRYPTEDVALUE *)ASN1_item_new(&CRMF_ENCRYPTEDVALUE_it);
+}
+
+void CRMF_ENCRYPTEDVALUE_free(CRMF_ENCRYPTEDVALUE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_ENCRYPTEDVALUE_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_ENCRYPTEDKEY_ch_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 0,
+		.offset = offsetof(CRMF_ENCRYPTEDKEY, value.encryptedValue),
+		.field_name = "value.encryptedValue",
+		.item = &CRMF_ENCRYPTEDVALUE_it,
+		},
+		/* TODO: This is not ASN1_NULL but CMS_ENVELOPEDDATA which should be somehow taken from crypto/cms which exists now - this is not used anywhere so far */
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 1,
+		.offset = offsetof(CRMF_ENCRYPTEDKEY, value.envelopedData),
+		.field_name = "value.envelopedData",
+		.item = &ASN1_NULL_it,
+		}
+};
+
+const ASN1_ITEM CRMF_ENCRYPTEDKEY_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CRMF_ENCRYPTEDKEY, type),
+	.templates = CRMF_ENCRYPTEDKEY_ch_tt,
+	.tcount = sizeof(CRMF_ENCRYPTEDKEY_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_ENCRYPTEDKEY),
+	.sname = "CRMF_ENCRYPTEDKEY",
+};
+
+	CRMF_ENCRYPTEDKEY *
+d2i_CRMF_ENCRYPTEDKEY(CRMF_ENCRYPTEDKEY **a, const unsigned char **in, long len)
+{
+	return (CRMF_ENCRYPTEDKEY*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_ENCRYPTEDKEY_it);
+}
+	int
+i2d_CRMF_ENCRYPTEDKEY(CRMF_ENCRYPTEDKEY *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_ENCRYPTEDKEY_it);
+}
+
+	CRMF_ENCRYPTEDKEY *
+CRMF_ENCRYPTEDKEY_new(void)
+{
+	return (CRMF_ENCRYPTEDKEY *)ASN1_item_new(&CRMF_ENCRYPTEDKEY_it);
+}
+
+void CRMF_ENCRYPTEDKEY_free(CRMF_ENCRYPTEDKEY *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_ENCRYPTEDKEY_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_PKIARCHIVEOPTIONS_ch_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 0,
+		.offset = offsetof(CRMF_PKIARCHIVEOPTIONS, value.encryptedPrivKey),
+		.field_name = "value.encryptedPrivKey",
+		.item = &CRMF_ENCRYPTEDKEY_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 1,
+		.offset = offsetof(CRMF_PKIARCHIVEOPTIONS, value.keyGenParameters),
+		.field_name = "value.keyGenParameters",
+		.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 2,
+		.offset = offsetof(CRMF_PKIARCHIVEOPTIONS, value.archiveRemGenPrivKey),
+		.field_name = "value.archiveRemGenPrivKey",
+		.item = &ASN1_BOOLEAN_it,
+		}
+};
+
+const ASN1_ITEM CRMF_PKIARCHIVEOPTIONS_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CRMF_PKIARCHIVEOPTIONS, type),
+	.templates = CRMF_PKIARCHIVEOPTIONS_ch_tt,
+	.tcount = sizeof(CRMF_PKIARCHIVEOPTIONS_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_PKIARCHIVEOPTIONS),
+	.sname = "CRMF_PKIARCHIVEOPTIONS",
+};
+
+	CRMF_PKIARCHIVEOPTIONS *
+d2i_CRMF_PKIARCHIVEOPTIONS(CRMF_PKIARCHIVEOPTIONS **a, const unsigned char **in, long len)
+{
+	return (CRMF_PKIARCHIVEOPTIONS*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_PKIARCHIVEOPTIONS_it);
+}
+	int
+i2d_CRMF_PKIARCHIVEOPTIONS(CRMF_PKIARCHIVEOPTIONS *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_PKIARCHIVEOPTIONS_it);
+}
+
+	CRMF_PKIARCHIVEOPTIONS *
+CRMF_PKIARCHIVEOPTIONS_new(void)
+{
+	return (CRMF_PKIARCHIVEOPTIONS *)ASN1_item_new(&CRMF_PKIARCHIVEOPTIONS_it);
+}
+
+void CRMF_PKIARCHIVEOPTIONS_free(CRMF_PKIARCHIVEOPTIONS *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_PKIARCHIVEOPTIONS_it);
+}
+
+
+CRMF_PKIARCHIVEOPTIONS * CRMF_PKIARCHIVEOPTIONS_dup(CRMF_PKIARCHIVEOPTIONS *x)
+{
+	return ASN1_item_dup(&CRMF_PKIARCHIVEOPTIONS_it, x);
+}
+
+
+
+static const ASN1_TEMPLATE CRMF_SINGLEPUBINFO_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_SINGLEPUBINFO, pubMethod),
+		.field_name = "pubMethod",
+		.item = &ASN1_INTEGER_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_SINGLEPUBINFO, pubLocation),
+		.field_name = "pubLocation",
+		.item = &GENERAL_NAME_it,
+		}
+};
+
+const ASN1_ITEM CRMF_SINGLEPUBINFO_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_SINGLEPUBINFO_seq_tt,
+	.tcount = sizeof(CRMF_SINGLEPUBINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_SINGLEPUBINFO),
+	.sname = "CRMF_SINGLEPUBINFO",
+};
+
+	CRMF_SINGLEPUBINFO *
+d2i_CRMF_SINGLEPUBINFO(CRMF_SINGLEPUBINFO **a, const unsigned char **in, long len)
+{
+	return (CRMF_SINGLEPUBINFO*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_SINGLEPUBINFO_it);
+}
+	int
+i2d_CRMF_SINGLEPUBINFO(CRMF_SINGLEPUBINFO *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_SINGLEPUBINFO_it);
+}
+
+	CRMF_SINGLEPUBINFO *
+CRMF_SINGLEPUBINFO_new(void)
+{
+	return (CRMF_SINGLEPUBINFO *)ASN1_item_new(&CRMF_SINGLEPUBINFO_it);
+}
+
+void CRMF_SINGLEPUBINFO_free(CRMF_SINGLEPUBINFO *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_SINGLEPUBINFO_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_PKIPUBLICATIONINFO_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PKIPUBLICATIONINFO, action),
+		.field_name = "action",
+		.item = &ASN1_INTEGER_it,
+		},
+		{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_PKIPUBLICATIONINFO, pubinfos),
+		.field_name = "pubinfos",
+		.item = &GENERAL_NAME_it,
+		}
+};
+
+const ASN1_ITEM CRMF_PKIPUBLICATIONINFO_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_PKIPUBLICATIONINFO_seq_tt,
+	.tcount = sizeof(CRMF_PKIPUBLICATIONINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_PKIPUBLICATIONINFO),
+	.sname = "CRMF_PKIPUBLICATIONINFO",
+};
+
+	CRMF_PKIPUBLICATIONINFO *
+d2i_CRMF_PKIPUBLICATIONINFO(CRMF_PKIPUBLICATIONINFO **a, const unsigned char **in, long len)
+{
+	return (CRMF_PKIPUBLICATIONINFO*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_PKIPUBLICATIONINFO_it);
+}
+	int
+i2d_CRMF_PKIPUBLICATIONINFO(CRMF_PKIPUBLICATIONINFO *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_PKIPUBLICATIONINFO_it);
+}
+
+	CRMF_PKIPUBLICATIONINFO *
+CRMF_PKIPUBLICATIONINFO_new(void)
+{
+	return (CRMF_PKIPUBLICATIONINFO *)ASN1_item_new(&CRMF_PKIPUBLICATIONINFO_it);
+}
+
+void CRMF_PKIPUBLICATIONINFO_free(CRMF_PKIPUBLICATIONINFO *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_PKIPUBLICATIONINFO_it);
+}
+
+
+CRMF_PKIPUBLICATIONINFO * CRMF_PKIPUBLICATIONINFO_dup(CRMF_PKIPUBLICATIONINFO *x)
+{
+	return ASN1_item_dup(&CRMF_PKIPUBLICATIONINFO_it, x);
+}
+
+
+
+static const ASN1_TEMPLATE CRMF_PKMACVALUE_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PKMACVALUE, algId),
+		.field_name = "algId",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PKMACVALUE, value),
+		.field_name = "value",
+		.item = &ASN1_BIT_STRING_it,
+		}
+};
+
+const ASN1_ITEM CRMF_PKMACVALUE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_PKMACVALUE_seq_tt,
+	.tcount = sizeof(CRMF_PKMACVALUE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_PKMACVALUE),
+	.sname = "CRMF_PKMACVALUE",
+};
+
+	CRMF_PKMACVALUE *
+d2i_CRMF_PKMACVALUE(CRMF_PKMACVALUE **a, const unsigned char **in, long len)
+{
+	return (CRMF_PKMACVALUE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_PKMACVALUE_it);
+}
+	int
+i2d_CRMF_PKMACVALUE(CRMF_PKMACVALUE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_PKMACVALUE_it);
+}
+
+	CRMF_PKMACVALUE *
+CRMF_PKMACVALUE_new(void)
+{
+	return (CRMF_PKMACVALUE *)ASN1_item_new(&CRMF_PKMACVALUE_it);
+}
+
+void CRMF_PKMACVALUE_free(CRMF_PKMACVALUE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_PKMACVALUE_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_POPOPRIVKEY_ch_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOPRIVKEY, value.thisMessage),
+		.field_name = "value.thisMessage",
+		.item = &ASN1_BIT_STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 1,
+		.offset = offsetof(CRMF_POPOPRIVKEY, value.subsequentMessage),
+		.field_name = "value.subsequentMessage",
+		.item = &ASN1_INTEGER_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 2,
+		.offset = offsetof(CRMF_POPOPRIVKEY, value.dhMAC),
+		.field_name = "value.dhMAC",
+		.item = &ASN1_BIT_STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 3,
+		.offset = offsetof(CRMF_POPOPRIVKEY, value.agreeMAC),
+		.field_name = "value.agreeMAC",
+		.item = &CRMF_PKMACVALUE_it,
+		},
+		/* TODO: This is not ASN1_NULL but CMS_ENVELOPEDDATA which should be somehow taken from crypto/cms which exists now - this is not used anywhere so far */
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 4,
+		.offset = offsetof(CRMF_POPOPRIVKEY, value.encryptedKey),
+		.field_name = "value.encryptedKey",
+		.item = &ASN1_NULL_it,
+		},
+};
+
+const ASN1_ITEM CRMF_POPOPRIVKEY_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CRMF_POPOPRIVKEY, type),
+	.templates = CRMF_POPOPRIVKEY_ch_tt,
+	.tcount = sizeof(CRMF_POPOPRIVKEY_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_POPOPRIVKEY),
+	.sname = "CRMF_POPOPRIVKEY",
+};
+
+	CRMF_POPOPRIVKEY *
+d2i_CRMF_POPOPRIVKEY(CRMF_POPOPRIVKEY **a, const unsigned char **in, long len)
+{
+	return (CRMF_POPOPRIVKEY*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_POPOPRIVKEY_it);
+}
+	int
+i2d_CRMF_POPOPRIVKEY(CRMF_POPOPRIVKEY *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_POPOPRIVKEY_it);
+}
+
+	CRMF_POPOPRIVKEY *
+CRMF_POPOPRIVKEY_new(void)
+{
+	return (CRMF_POPOPRIVKEY *)ASN1_item_new(&CRMF_POPOPRIVKEY_it);
+}
+
+void CRMF_POPOPRIVKEY_free(CRMF_POPOPRIVKEY *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_POPOPRIVKEY_it);
+}
+
+static const ASN1_TEMPLATE CRMF_PBMPARAMETER_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PBMPARAMETER, salt),
+		.field_name = "salt",
+		.item = &ASN1_OCTET_STRING_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PBMPARAMETER, owf),
+		.field_name = "owf",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PBMPARAMETER, iterationCount),
+		.field_name = "iterationCount",
+		.item = &ASN1_INTEGER_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_PBMPARAMETER, mac),
+		.field_name = "mac",
+		.item = &X509_ALGOR_it,
+		}
+};
+
+const ASN1_ITEM CRMF_PBMPARAMETER_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_PBMPARAMETER_seq_tt,
+	.tcount = sizeof(CRMF_PBMPARAMETER_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_PBMPARAMETER),
+	.sname = "CRMF_PBMPARAMETER",
+};
+
+	CRMF_PBMPARAMETER *
+d2i_CRMF_PBMPARAMETER(CRMF_PBMPARAMETER **a, const unsigned char **in, long len)
+{
+	return (CRMF_PBMPARAMETER*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_PBMPARAMETER_it);
+}
+	int
+i2d_CRMF_PBMPARAMETER(CRMF_PBMPARAMETER *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_PBMPARAMETER_it);
+}
+
+	CRMF_PBMPARAMETER *
+CRMF_PBMPARAMETER_new(void)
+{
+	return (CRMF_PBMPARAMETER *)ASN1_item_new(&CRMF_PBMPARAMETER_it);
+}
+
+void CRMF_PBMPARAMETER_free(CRMF_PBMPARAMETER *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_PBMPARAMETER_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_ch_tt[] = {
+		{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO, value.sender),
+		.field_name = "value.sender",
+		.item = &GENERAL_NAME_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO, value.publicKeyMAC),
+		.field_name = "value.publicKeyMAC",
+		.item = &CRMF_PKMACVALUE_it,
+		}
+};
+
+const ASN1_ITEM CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO, type),
+	.templates = CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_ch_tt,
+	.tcount = sizeof(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO),
+	.sname = "CRMF_POPOSIGNINGKEYINPUT_AUTHINFO",
+};
+
+	CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *
+d2i_CRMF_POPOSIGNINGKEYINPUT_AUTHINFO(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO **a, const unsigned char **in, long len)
+{
+	return (CRMF_POPOSIGNINGKEYINPUT_AUTHINFO*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it);
+}
+	int
+i2d_CRMF_POPOSIGNINGKEYINPUT_AUTHINFO(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it);
+}
+
+	CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *
+CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_new(void)
+{
+	return (CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *)ASN1_item_new(&CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it);
+}
+
+void CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_free(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_POPOSIGNINGKEYINPUT_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEYINPUT, authinfo),
+		.field_name = "authinfo",
+		.item = &CRMF_POPOSIGNINGKEYINPUT_AUTHINFO_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEYINPUT, publicKey),
+		.field_name = "publicKey",
+		.item = &X509_PUBKEY_it,
+		}
+};
+
+const ASN1_ITEM CRMF_POPOSIGNINGKEYINPUT_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_POPOSIGNINGKEYINPUT_seq_tt,
+	.tcount = sizeof(CRMF_POPOSIGNINGKEYINPUT_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_POPOSIGNINGKEYINPUT),
+	.sname = "CRMF_POPOSIGNINGKEYINPUT",
+};
+
+	CRMF_POPOSIGNINGKEYINPUT *
+d2i_CRMF_POPOSIGNINGKEYINPUT(CRMF_POPOSIGNINGKEYINPUT **a, const unsigned char **in, long len)
+{
+	return (CRMF_POPOSIGNINGKEYINPUT*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_POPOSIGNINGKEYINPUT_it);
+}
+	int
+i2d_CRMF_POPOSIGNINGKEYINPUT(CRMF_POPOSIGNINGKEYINPUT *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_POPOSIGNINGKEYINPUT_it);
+}
+
+	CRMF_POPOSIGNINGKEYINPUT *
+CRMF_POPOSIGNINGKEYINPUT_new(void)
+{
+	return (CRMF_POPOSIGNINGKEYINPUT *)ASN1_item_new(&CRMF_POPOSIGNINGKEYINPUT_it);
+}
+
+void CRMF_POPOSIGNINGKEYINPUT_free(CRMF_POPOSIGNINGKEYINPUT *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_POPOSIGNINGKEYINPUT_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_POPOSIGNINGKEY_seq_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEY, poposkInput),
+		.field_name = "poposkInput",
+		.item = &CRMF_POPOSIGNINGKEYINPUT_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEY, algorithmIdentifier),
+		.field_name = "algorithmIdentifier",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_POPOSIGNINGKEY, signature),
+		.field_name = "signature",
+		.item = &ASN1_BIT_STRING_it,
+		}
+};
+
+const ASN1_ITEM CRMF_POPOSIGNINGKEY_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_POPOSIGNINGKEY_seq_tt,
+	.tcount = sizeof(CRMF_POPOSIGNINGKEY_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_POPOSIGNINGKEY),
+	.sname = "CRMF_POPOSIGNINGKEY",
+};
+
+	CRMF_POPOSIGNINGKEY *
+d2i_CRMF_POPOSIGNINGKEY(CRMF_POPOSIGNINGKEY **a, const unsigned char **in, long len)
+{
+	return (CRMF_POPOSIGNINGKEY*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_POPOSIGNINGKEY_it);
+}
+	int
+i2d_CRMF_POPOSIGNINGKEY(CRMF_POPOSIGNINGKEY *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_POPOSIGNINGKEY_it);
+}
+
+	CRMF_POPOSIGNINGKEY *
+CRMF_POPOSIGNINGKEY_new(void)
+{
+	return (CRMF_POPOSIGNINGKEY *)ASN1_item_new(&CRMF_POPOSIGNINGKEY_it);
+}
+
+void CRMF_POPOSIGNINGKEY_free(CRMF_POPOSIGNINGKEY *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_POPOSIGNINGKEY_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_PROOFOFPOSSESION_ch_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 0,
+		.offset = offsetof(CRMF_PROOFOFPOSSESION, value.raVerified),
+		.field_name = "value.raVerified",
+		.item = &ASN1_NULL_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 1,
+		.offset = offsetof(CRMF_PROOFOFPOSSESION, value.signature),
+		.field_name = "value.signature",
+		.item = &CRMF_POPOSIGNINGKEY_it,
+		},
+		{
+		.flags = ASN1_TFLG_EXPLICIT,
+		.tag = 2,
+		.offset = offsetof(CRMF_PROOFOFPOSSESION, value.keyEncipherment),
+		.field_name = "value.keyEncipherment",
+		.item = &CRMF_POPOPRIVKEY_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT,
+		.tag = 3,
+		.offset = offsetof(CRMF_PROOFOFPOSSESION, value.keyAgreement),
+		.field_name = "value.keyAgreement",
+		.item = &CRMF_POPOPRIVKEY_it,
+		}
+};
+
+const ASN1_ITEM CRMF_PROOFOFPOSSESION_it = {
+	.itype = ASN1_ITYPE_CHOICE,
+	.utype = offsetof(CRMF_PROOFOFPOSSESION, type),
+	.templates = CRMF_PROOFOFPOSSESION_ch_tt,
+	.tcount = sizeof(CRMF_PROOFOFPOSSESION_ch_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_PROOFOFPOSSESION),
+	.sname = "CRMF_PROOFOFPOSSESION",
+};
+
+	CRMF_PROOFOFPOSSESION *
+d2i_CRMF_PROOFOFPOSSESION(CRMF_PROOFOFPOSSESION **a, const unsigned char **in, long len)
+{
+	return (CRMF_PROOFOFPOSSESION*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_PROOFOFPOSSESION_it);
+}
+	int
+i2d_CRMF_PROOFOFPOSSESION(CRMF_PROOFOFPOSSESION *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_PROOFOFPOSSESION_it);
+}
+
+	CRMF_PROOFOFPOSSESION *
+CRMF_PROOFOFPOSSESION_new(void)
+{
+	return (CRMF_PROOFOFPOSSESION *)ASN1_item_new(&CRMF_PROOFOFPOSSESION_it);
+}
+
+void CRMF_PROOFOFPOSSESION_free(CRMF_PROOFOFPOSSESION *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_PROOFOFPOSSESION_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE attributetypeandvalue_default_tt = {
+	.flags = ASN1_TFLG_OPTIONAL,
+	.tag = 0,
+	.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.other),
+	.field_name = "value.other",
+	.item = &ASN1_ANY_it,
+};
+static const ASN1_ADB_TABLE CRMF_ATTRIBUTETYPEANDVALUE_adbtbl[] = {
+		{
+		.value = NID_id_regCtrl_regToken,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.regToken),
+			.field_name = "value.regToken",
+			.item = &ASN1_UTF8STRING_it,
+		}
+
+		},
+		{
+		.value = NID_id_regCtrl_authenticator,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.authenticator),
+			.field_name = "value.authenticator",
+			.item = &ASN1_UTF8STRING_it,
+		}
+		,
+		},
+		{
+		.value = NID_id_regCtrl_pkiPublicationInfo,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.pkiPublicationInfo),
+			.field_name = "value.pkiPublicationInfo",
+			.item = &CRMF_PKIPUBLICATIONINFO_it,
+		}
+		},
+		{
+		.value = NID_id_regCtrl_pkiArchiveOptions,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.pkiArchiveOptions),
+			.field_name = "value.pkiArchiveOptions",
+			.item = & CRMF_PKIARCHIVEOPTIONS_it,
+		}
+		},
+		{
+		.value = NID_id_regCtrl_oldCertID,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.oldCertId),
+			.field_name = "value.oldCertId",
+			.item = &CRMF_CERTID_it,
+		}
+
+		},
+		{
+		.value = NID_id_regCtrl_protocolEncrKey,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.protocolEncrKey),
+			.field_name = "value.protocolEncrKey",
+			.item = &   X509_PUBKEY_it
+		},
+		},
+		{
+		.value = NID_id_regInfo_utf8Pairs,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.utf8pairs),
+			.field_name = "value.utf8pairs",
+			.item = &ASN1_UTF8STRING_it,
+		}
+
+		},
+		{
+		.value = NID_id_regInfo_certReq,
+		.tt = {
+			.flags = 0,
+			.tag = 0,
+			.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, value.certReq),
+			.field_name = "value.certReq",
+			.item = &CRMF_CERTREQUEST_it,
+		}
+
+		}
+};
+static const ASN1_ADB CRMF_ATTRIBUTETYPEANDVALUE_adb = {
+	.flags = 0,
+	.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, type),
+	.app_items = 0,
+	.tbl = CRMF_ATTRIBUTETYPEANDVALUE_adbtbl,
+	.tblcount = sizeof(CRMF_ATTRIBUTETYPEANDVALUE_adbtbl) / sizeof(ASN1_ADB_TABLE),
+	.default_tt = &attributetypeandvalue_default_tt,
+	.null_tt = NULL,
+};
+
+
+
+static const ASN1_TEMPLATE CRMF_ATTRIBUTETYPEANDVALUE_seq_tt[] =
+{
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_ATTRIBUTETYPEANDVALUE, type),
+		.field_name = "type",
+		.item = &ASN1_OBJECT_it,
+		},
+		{
+  .flags = ASN1_TFLG_ADB_OID,
+  .tag = -1,
+  .offset = 0,
+  .field_name = "CRMF_ATTRIBUTETYPEANDVALUE",
+  .item = (const ASN1_ITEM*)&CRMF_ATTRIBUTETYPEANDVALUE_adb,
+}
+
+};
+
+const ASN1_ITEM CRMF_ATTRIBUTETYPEANDVALUE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_ATTRIBUTETYPEANDVALUE_seq_tt,
+	.tcount = sizeof(CRMF_ATTRIBUTETYPEANDVALUE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_ATTRIBUTETYPEANDVALUE),
+	.sname = "CRMF_ATTRIBUTETYPEANDVALUE",
+};
+
+
+	CRMF_ATTRIBUTETYPEANDVALUE *
+d2i_CRMF_ATTRIBUTETYPEANDVALUE(CRMF_ATTRIBUTETYPEANDVALUE **a, const unsigned char **in, long len)
+{
+	return (CRMF_ATTRIBUTETYPEANDVALUE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_ATTRIBUTETYPEANDVALUE_it);
+}
+	int
+i2d_CRMF_ATTRIBUTETYPEANDVALUE(CRMF_ATTRIBUTETYPEANDVALUE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_ATTRIBUTETYPEANDVALUE_it);
+}
+
+	CRMF_ATTRIBUTETYPEANDVALUE *
+CRMF_ATTRIBUTETYPEANDVALUE_new(void)
+{
+	return (CRMF_ATTRIBUTETYPEANDVALUE *)ASN1_item_new(&CRMF_ATTRIBUTETYPEANDVALUE_it);
+}
+
+void CRMF_ATTRIBUTETYPEANDVALUE_free(CRMF_ATTRIBUTETYPEANDVALUE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_ATTRIBUTETYPEANDVALUE_it);
+}
+
+
+CRMF_ATTRIBUTETYPEANDVALUE * CRMF_ATTRIBUTETYPEANDVALUE_dup(CRMF_ATTRIBUTETYPEANDVALUE *x)
+{
+	return ASN1_item_dup(&CRMF_ATTRIBUTETYPEANDVALUE_it, x);
+}
+
+
+
+static const ASN1_TEMPLATE CRMF_OPTIONALVALIDITY_seq_tt[] = {
+		{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_OPTIONALVALIDITY, notBefore),
+		.field_name = "notBefore",
+		.item = &ASN1_TIME_it,
+		},
+		{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 1,
+		.offset = offsetof(CRMF_OPTIONALVALIDITY, notAfter),
+		.field_name = "notAfter",
+		.item = &ASN1_TIME_it,
+		}
+};
+
+const ASN1_ITEM CRMF_OPTIONALVALIDITY_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_OPTIONALVALIDITY_seq_tt,
+	.tcount = sizeof(CRMF_OPTIONALVALIDITY_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_OPTIONALVALIDITY),
+	.sname = "CRMF_OPTIONALVALIDITY",
+};
+
+	CRMF_OPTIONALVALIDITY *
+d2i_CRMF_OPTIONALVALIDITY(CRMF_OPTIONALVALIDITY **a, const unsigned char **in, long len)
+{
+	return (CRMF_OPTIONALVALIDITY*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_OPTIONALVALIDITY_it);
+}
+	int
+i2d_CRMF_OPTIONALVALIDITY(CRMF_OPTIONALVALIDITY *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_OPTIONALVALIDITY_it);
+}
+
+	CRMF_OPTIONALVALIDITY *
+CRMF_OPTIONALVALIDITY_new(void)
+{
+	return (CRMF_OPTIONALVALIDITY *)ASN1_item_new(&CRMF_OPTIONALVALIDITY_it);
+}
+
+void CRMF_OPTIONALVALIDITY_free(CRMF_OPTIONALVALIDITY *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_OPTIONALVALIDITY_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_CERTTEMPLATE_seq_tt[] = {
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTTEMPLATE, version),
+		.field_name = "version",
+		.item = &ASN1_INTEGER_it,
+		},
+		/* serialNumber MUST be omitted.  This field is assigned by the CA
+		 * during certificate creation. */
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 1,
+		.offset = offsetof(CRMF_CERTTEMPLATE, serialNumber),
+		.field_name = "serialNumber",
+		.item = &ASN1_INTEGER_it,
+		},
+		/* signingAlg MUST be omitted.	This field is assigned by the CA
+		 * during certificate creation. */
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 2,
+		.offset = offsetof(CRMF_CERTTEMPLATE, signingAlg),
+		.field_name = "signingAlg",
+		.item = &X509_ALGOR_it,
+		},
+		{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 3,
+		.offset = offsetof(CRMF_CERTTEMPLATE, issuer),
+		.field_name = "issuer",
+		.item = &X509_NAME_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 4,
+		.offset = offsetof(CRMF_CERTTEMPLATE, validity),
+		.field_name = "validity",
+		.item = &CRMF_OPTIONALVALIDITY_it,
+		},
+		{
+		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 5,
+		.offset = offsetof(CRMF_CERTTEMPLATE, subject),
+		.field_name = "subject",
+		.item = &X509_NAME_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 6,
+		.offset = offsetof(CRMF_CERTTEMPLATE, publicKey),
+		.field_name = "publicKey",
+		.item = &X509_PUBKEY_it,
+		},
+		/* issuerUID is deprecated in version 2 */
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 7,
+		.offset = offsetof(CRMF_CERTTEMPLATE, issuerUID),
+		.field_name = "issuerUID",
+		.item = &ASN1_BIT_STRING_it,
+		},
+		/* subjectUID is deprecated in version 2 */
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
+		.tag = 8,
+		.offset = offsetof(CRMF_CERTTEMPLATE, subjectUID),
+		.field_name = "subjectUID",
+		.item = &ASN1_BIT_STRING_it,
+		},
+		{
+		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SEQUENCE_OF,
+		.tag = 9,
+		.offset = offsetof(CRMF_CERTTEMPLATE, extensions),
+		.field_name = "extensions",
+		.item = &X509_EXTENSION_it,
+	},
+};
+
+const ASN1_ITEM CRMF_CERTTEMPLATE_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_CERTTEMPLATE_seq_tt,
+	.tcount = sizeof(CRMF_CERTTEMPLATE_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_CERTTEMPLATE),
+	.sname = "CRMF_CERTTEMPLATE",
+};
+
+	CRMF_CERTTEMPLATE *
+d2i_CRMF_CERTTEMPLATE(CRMF_CERTTEMPLATE **a, const unsigned char **in, long len)
+{
+	return (CRMF_CERTTEMPLATE*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_CERTTEMPLATE_it);
+}
+	int
+i2d_CRMF_CERTTEMPLATE(CRMF_CERTTEMPLATE *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_CERTTEMPLATE_it);
+}
+
+	CRMF_CERTTEMPLATE *
+CRMF_CERTTEMPLATE_new(void)
+{
+	return (CRMF_CERTTEMPLATE *)ASN1_item_new(&CRMF_CERTTEMPLATE_it);
+}
+
+void CRMF_CERTTEMPLATE_free(CRMF_CERTTEMPLATE *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_CERTTEMPLATE_it);
+}
+
+
+
+
+static const ASN1_TEMPLATE CRMF_CERTREQUEST_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTREQUEST, certReqId),
+		.field_name = "certReqId",
+		.item = &ASN1_INTEGER_it,
+		},
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTREQUEST, certTemplate),
+		.field_name = "certTemplate",
+		.item = &CRMF_CERTTEMPLATE_it,
+		},
+		{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTREQUEST, controls),
+		.field_name = "controls",
+		.item = &CRMF_ATTRIBUTETYPEANDVALUE_it,
+		}
+};
+
+const ASN1_ITEM CRMF_CERTREQUEST_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_CERTREQUEST_seq_tt,
+	.tcount = sizeof(CRMF_CERTREQUEST_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_CERTREQUEST),
+	.sname = "CRMF_CERTREQUEST",
+};
+
+	CRMF_CERTREQUEST *
+d2i_CRMF_CERTREQUEST(CRMF_CERTREQUEST **a, const unsigned char **in, long len)
+{
+	return (CRMF_CERTREQUEST*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_CERTREQUEST_it);
+}
+	int
+i2d_CRMF_CERTREQUEST(CRMF_CERTREQUEST *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_CERTREQUEST_it);
+}
+
+	CRMF_CERTREQUEST *
+CRMF_CERTREQUEST_new(void)
+{
+	return (CRMF_CERTREQUEST *)ASN1_item_new(&CRMF_CERTREQUEST_it);
+}
+
+void CRMF_CERTREQUEST_free(CRMF_CERTREQUEST *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_CERTREQUEST_it);
+}
+
+
+CRMF_CERTREQUEST * CRMF_CERTREQUEST_dup(CRMF_CERTREQUEST *x)
+{
+	return ASN1_item_dup(&CRMF_CERTREQUEST_it, x);
+}
+
+static const ASN1_TEMPLATE CRMF_CERTREQMSG_seq_tt[] = {
+		{
+		.flags = 0,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTREQMSG, certReq),
+		.field_name = "certReq",
+		.item = &CRMF_CERTREQUEST_it,
+		},
+		{
+		.flags = ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTREQMSG, popo),
+		.field_name = "popo",
+		.item = &CRMF_PROOFOFPOSSESION_it,
+		},
+		{
+		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
+		.tag = 0,
+		.offset = offsetof(CRMF_CERTREQMSG, regInfo),
+		.field_name = "regInfo",
+		.item = &CRMF_ATTRIBUTETYPEANDVALUE_it,
+		}
+};
+
+const ASN1_ITEM CRMF_CERTREQMSG_it = {
+	.itype = ASN1_ITYPE_SEQUENCE,
+	.utype = V_ASN1_SEQUENCE,
+	.templates = CRMF_CERTREQMSG_seq_tt,
+	.tcount = sizeof(CRMF_CERTREQMSG_seq_tt) / sizeof(ASN1_TEMPLATE),
+	.funcs = NULL,
+	.size = sizeof(CRMF_CERTREQMSG),
+	.sname = "CRMF_CERTREQMSG",
+};
+
+	CRMF_CERTREQMSG *
+d2i_CRMF_CERTREQMSG(CRMF_CERTREQMSG **a, const unsigned char **in, long len)
+{
+	return (CRMF_CERTREQMSG*)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
+			&CRMF_CERTREQMSG_it);
+}
+	int
+i2d_CRMF_CERTREQMSG(CRMF_CERTREQMSG *a, unsigned char **out)
+{
+	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRMF_CERTREQMSG_it);
+}
+
+	CRMF_CERTREQMSG *
+CRMF_CERTREQMSG_new(void)
+{
+	return (CRMF_CERTREQMSG *)ASN1_item_new(&CRMF_CERTREQMSG_it);
+}
+
+void CRMF_CERTREQMSG_free(CRMF_CERTREQMSG *a)
+{
+	ASN1_item_free((ASN1_VALUE *)a, &CRMF_CERTREQMSG_it);
+}
+
+static const ASN1_TEMPLATE CRMF_CERTREQMESSAGES_item_tt = {
+
+		.flags = ASN1_TFLG_SEQUENCE_OF,
+		.tag = 0,
+		.offset = 0,
+		.field_name = "CRMF_CERTREQMESSAGES",
+		.item = &CRMF_CERTREQMSG_it,
+
+};
+
+const ASN1_ITEM CRMF_CERTREQMESSAGES_it = {
+	.itype = ASN1_ITYPE_PRIMITIVE,
+	.utype = -1,
+	.templates = &CRMF_CERTREQMESSAGES_item_tt,
+	.tcount = 0,
+	.funcs = NULL,
+	.size = 0,
+	.sname = "CRMF_CERTREQMESSAGES",
+};
+
diff -Naur crypto/crmf/crmf_err.c crypto-/crmf/crmf_err.c
--- cryptoold/crmf/crmf_err.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/crmf/crmf_err.c	2017-04-20 16:50:26.941043274 +0700
@@ -0,0 +1,142 @@
+/* crypto/crmf/crmf_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/crmf.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_CRMF,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_CRMF,0,reason)
+
+static ERR_STRING_DATA CRMF_str_functs[]=
+	{
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_CALC_AND_SET_POPO),	"CRMF_CERTREQMSG_calc_and_set_popo"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_PUSH0_CONTROL),	"CRMF_CERTREQMSG_push0_control"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_PUSH0_EXTENSION),	"CRMF_CERTREQMSG_push0_extension"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_PUSH0_REGINFO),	"CRMF_CERTREQMSG_push0_regInfo"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_AUTHENTICATOR),	"CRMF_CERTREQMSG_set1_control_authenticator"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_OLDCERTID),	"CRMF_CERTREQMSG_set1_control_oldCertId"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PKIARCHIVEOPTIONS),	"CRMF_CERTREQMSG_SET1_CONTROL_PKIARCHIVEOPTIONS"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PKIPUBLICATIONINFO),	"CRMF_CERTREQMSG_SET1_CONTROL_PKIPUBLICATIONINFO"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PROTOCOLENCRKEY),	"CRMF_CERTREQMSG_SET1_CONTROL_PROTOCOLENCRKEY"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_REGTOKEN),	"CRMF_CERTREQMSG_set1_control_regToken"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_PUBLICKEY),	"CRMF_CERTREQMSG_set1_publicKey"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_CERTREQ),	"CRMF_CERTREQMSG_SET1_REGINFO_CERTREQ"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_REGTOKEN),	"CRMF_CERTREQMSG_set1_regInfo_regToken"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_UTF8PAIRS),	"CRMF_CERTREQMSG_SET1_REGINFO_UTF8PAIRS"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_SUBJECT),	"CRMF_CERTREQMSG_set1_subject"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET_CERTREQID),	"CRMF_CERTREQMSG_set_certReqId"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET_VALIDITY),	"CRMF_CERTREQMSG_set_validity"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET_VERSION2),	"CRMF_CERTREQMSG_set_version2"},
+{ERR_FUNC(CRMF_F_CRMF_CR_NEW),	"CRMF_cr_new"},
+{ERR_FUNC(CRMF_F_CRMF_PASSWORDBASEDMAC_NEW),	"CRMF_passwordBasedMac_new"},
+{ERR_FUNC(CRMF_F_CRMF_POPOSIGNINGKEY_NEW),	"CRMF_poposigningkey_new"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_CONTROL_AUTHENTICATOR),	"CRMF_SET1_CONTROL_AUTHENTICATOR"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_CONTROL_OLDCERTID),	"CRMF_SET1_CONTROL_OLDCERTID"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_CONTROL_PKIARCHIVEOPTIONS),	"CRMF_SET1_CONTROL_PKIARCHIVEOPTIONS"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_CONTROL_PKIPUBLICATIONINFO),	"CRMF_SET1_CONTROL_PKIPUBLICATIONINFO"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_CONTROL_PROTOCOLENCRKEY),	"CRMF_SET1_CONTROL_PROTOCOLENCRKEY"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_REGINFO_CERTREQ),	"CRMF_SET1_REGINFO_CERTREQ"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_REGINFO_UTF8PAIRS),	"CRMF_SET1_REGINFO_UTF8PAIRS"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_REGTOKEN_CERTREQ),	"CRMF_SET1_REGTOKEN_CERTREQ"},
+{ERR_FUNC(CRMF_F_CRMF_SET1_SUBJECT),	"CRMF_SET1_SUBJECT"},
+{ERR_FUNC(CRMF_F_CRMF_SET_CERTREQID),	"CRMF_SET_CERTREQID"},
+{ERR_FUNC(CRMF_F_CRMF_SET_VERSION2),	"CRMF_SET_VERSION2"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA CRMF_str_reasons[]=
+	{
+{ERR_REASON(CRMF_R_CRMFERROR)            ,"crmferror"},
+{ERR_REASON(CRMF_R_ERROR_CALCULATING_AND_SETTING_POPO),"error calculating and setting popo"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_CONTROL_AUTHENTICATOR_ATAV),"error setting control authenticator atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_CONTROL_OLDCERTID_ATAV),"error setting control oldcertid atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_CONTROL_PKIARCHIVEOPTIONS_ATAV),"error setting control pkiarchiveoptions atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_CONTROL_PKIPUBLICATIONINFO_ATAV),"error setting control pkipublicationinfo atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_CONTROL_PROTOCOLENCRKEY_ATAV),"error setting control protocolencrkey atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_POPSIGNINGKEY),"error setting popsigningkey"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_PUBLIC_KEY),"error setting public key"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_REGINFO_CERTREQ_ATAV),"error setting reginfo certreq atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_REGINFO_UTF8PAIRS_ATAV),"error setting reginfo utf8pairs atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_REGTOKEN_ATAV),"error setting regtoken atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_REGTOKEN_CERTREQ_ATAV),"error setting regtoken certreq atav"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_VERSION_2),"error setting version 2"},
+{ERR_REASON(CRMF_R_UNSUPPORTED_ALGORITHM),"unsupported algorithm"},
+{ERR_REASON(CRMF_R_UNSUPPORTED_ALG_FOR_POPSIGNINGKEY),"unsupported alg for popsigningkey"},
+{ERR_REASON(CRMF_R_UNSUPPORTED_METHOD_FOR_CREATING_POPO),"unsupported method for creating popo"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_CRMF_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(CRMF_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,CRMF_str_functs);
+		ERR_load_strings(0,CRMF_str_reasons);
+		}
+#endif
+	}
diff -Naur crypto/crmf/crmf_lib.c crypto-/crmf/crmf_lib.c
--- cryptoold/crmf/crmf_lib.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/crmf/crmf_lib.c	2017-04-20 21:32:36.422290885 +0700
@@ -0,0 +1,704 @@
+/* vim: set cino={1s noet ts=4 sts=4 sw=4: */
+/* crypto/crmf/crmf_lib.c
+ * CRMF (RFC 4211) library functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by
+ * Nokia for contribution to the OpenSSL project.
+ */
+/* NAMING
+ * The 0 version uses the supplied structure pointer directly in the parent and
+ * it will be freed up when the parent is freed. In the above example crl would
+ * be freed but rev would not.
+ *
+ * The 1 function uses a copy of the supplied structure pointer (or in some
+ * cases increases its link count) in the parent and so both (x and obj above)
+ * should be freed up.
+ */
+/* ############################################################################ *
+ * In this file are the functions which set the individual items inside			*
+ * the CRMF structures															*
+ * ############################################################################ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/cmp.h>
+#include <openssl/crmf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+
+/* ############################################################################ *
+ * Pushes the given control attribute into the controls stack of a CertRequest
+ * (section 6)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push0_control( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *control)
+	{
+	int newControls = 0;
+
+	if (!certReqMsg) goto err;
+	if (!control) goto err;
+
+	if (!(certReqMsg->certReq->controls))
+		{
+		/* as it is OPTIONAL it might not yet be initialized */
+		if( !(certReqMsg->certReq->controls = sk_CRMF_ATTRIBUTETYPEANDVALUE_new_null())) goto err;
+		newControls = 1; /* for potential cleanup in error case */
+		}
+	if (!sk_CRMF_ATTRIBUTETYPEANDVALUE_push( certReqMsg->certReq->controls, control)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_PUSH0_CONTROL, CRMF_R_CRMFERROR);
+
+	if (newControls)
+		{
+		sk_CRMF_ATTRIBUTETYPEANDVALUE_pop_free(certReqMsg->certReq->controls, CRMF_ATTRIBUTETYPEANDVALUE_free);
+		certReqMsg->certReq->controls = NULL;
+		}
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets the id-regCtrl-regToken Control (section 6.1)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!tok) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_regToken);
+	if (!(atav->value.regToken = ASN1_STRING_dup( tok))) goto err;
+
+	if (!CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_REGTOKEN, CRMF_R_ERROR_SETTING_REGTOKEN_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets the id-regCtrl-authenticator Control (section 6.2)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_authenticator( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *auth)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!auth) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_authenticator);
+	if (!(atav->value.regToken = ASN1_STRING_dup( auth))) goto err;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_AUTHENTICATOR, CRMF_R_ERROR_SETTING_CONTROL_AUTHENTICATOR_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets the id-regCtrl-pkiPublicationInfo Control (section 6.3)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_pkiPublicationInfo( CRMF_CERTREQMSG *msg, CRMF_PKIPUBLICATIONINFO *pubinfo)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!pubinfo) goto err;
+
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_pkiPublicationInfo);
+	if (!(atav->value.pkiPublicationInfo = CRMF_PKIPUBLICATIONINFO_dup( pubinfo))) goto err;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PKIPUBLICATIONINFO, CRMF_R_ERROR_SETTING_CONTROL_PKIPUBLICATIONINFO_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################
+ * sets the id-regCtrl-pkiArchiveOptions Control (section 6.4)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_pkiArchiveOptions( CRMF_CERTREQMSG *msg, CRMF_PKIARCHIVEOPTIONS *archopts)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!archopts) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_pkiArchiveOptions);
+	if (!(atav->value.pkiArchiveOptions = CRMF_PKIARCHIVEOPTIONS_dup( archopts))) goto err;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PKIARCHIVEOPTIONS, CRMF_R_ERROR_SETTING_CONTROL_PKIARCHIVEOPTIONS_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets the id-regCtrl-oldCertID Control (section 6.5) from the given
+ * certificate
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_oldCertId( CRMF_CERTREQMSG *certReqMsg, X509 *oldCert)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav   = NULL;
+	CRMF_CERTID				   *certId = NULL;
+	GENERAL_NAME			   *gName  = NULL;
+
+	if ( !certReqMsg) goto err;
+	if ( !oldCert) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())
+		|| !(certId = CRMF_CERTID_new())
+		|| !(gName = GENERAL_NAME_new()))
+		goto err;
+
+	/* X509_NAME_set does not consume the pointer so this is ok */
+	X509_NAME_set( &gName->d.directoryName, X509_get_issuer_name( oldCert));
+	gName->type = GEN_DIRNAME;
+	certId->issuer = gName;
+	if (!(certId->serialNumber = ASN1_INTEGER_dup(X509_get_serialNumber(oldCert)))) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_oldCertID);
+	atav->value.oldCertId = certId;
+
+	if (!CRMF_CERTREQMSG_push0_control( certReqMsg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_OLDCERTID, CRMF_R_ERROR_SETTING_CONTROL_OLDCERTID_ATAV);
+	if (gName) GENERAL_NAME_free(gName);
+	if (certId)
+		{
+		certId->issuer = NULL;
+		CRMF_CERTID_free(certId);
+		}
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * For some reason X509_PUBKEY_dup() does not appear to be implemented by
+ * OpenSSL's X509 code, so we implement it here. It's only needed in the following
+ * function so it can be declared static. *
+ * TODO: check whether that should go elsewhere *
+ * ############################################################################ */
+X509_PUBKEY *
+X509_PUBKEY_dup(X509_PUBKEY *x)
+{
+	return ASN1_item_dup(&X509_PUBKEY_it, x);
+}
+
+
+/* ############################################################################ *
+ * sets the id-regCtrl-protocolEncrKey Control (section 6.6) from the given
+ * public key
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_protocolEncrKey( CRMF_CERTREQMSG *msg, X509_PUBKEY *pubkey)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!pubkey) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_protocolEncrKey);
+	if (!(atav->value.protocolEncrKey = X509_PUBKEY_dup(pubkey))) goto err;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_CONTROL_PROTOCOLENCRKEY, CRMF_R_ERROR_SETTING_CONTROL_PROTOCOLENCRKEY_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * Pushes the attribute given in regInfo in to the CertReqMsg->regInfo stack.
+ * (section 7)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push0_regInfo( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *regInfo)
+	{
+	int newRegInfo = 0;
+
+	if (!certReqMsg) goto err;
+	if (!regInfo) goto err;
+
+	if (!(certReqMsg->regInfo))
+		{
+		/* as it is OPTIONAL it might not yet be initialized */
+		if( !(certReqMsg->regInfo = sk_CRMF_ATTRIBUTETYPEANDVALUE_new_null())) goto err;
+		newRegInfo = 1;
+		}
+	if (!sk_CRMF_ATTRIBUTETYPEANDVALUE_push( certReqMsg->regInfo, regInfo)) goto err;
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_PUSH0_REGINFO, CRMF_R_CRMFERROR);
+
+	if (newRegInfo)
+		{
+		sk_CRMF_ATTRIBUTETYPEANDVALUE_pop_free(certReqMsg->regInfo, CRMF_ATTRIBUTETYPEANDVALUE_free);
+		certReqMsg->regInfo = NULL;
+		}
+	return 0;
+}
+
+/* ############################################################################ *
+ * sets the id-regInfo-utf8Pairs to regInfo (section 7.1) from a given
+ * UTF8string
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_regInfo_utf8Pairs( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *utf8pairs)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!utf8pairs) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regInfo_utf8Pairs);
+	if (!(atav->value.utf8pairs = ASN1_STRING_dup( utf8pairs))) goto err;
+
+	if (!CRMF_CERTREQMSG_push0_regInfo( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_UTF8PAIRS, CRMF_R_ERROR_SETTING_REGINFO_UTF8PAIRS_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets the id-regInfo-certReq to regInfo (section 7.2) from a given certificate
+ * request
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_regInfo_certReq( CRMF_CERTREQMSG *msg, CRMF_CERTREQUEST *certReq)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!certReq) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regInfo_certReq);
+	if (!(atav->value.certReq = CRMF_CERTREQUEST_dup( certReq))) goto err;
+
+	if (!CRMF_CERTREQMSG_push0_regInfo( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_CERTREQ, CRMF_R_ERROR_SETTING_REGINFO_CERTREQ_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets the id-regCtrl-regToken to regInfo (not described in RFC)
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_regInfo_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok)
+	{
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+
+	if (!msg) goto err;
+	if (!tok) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_regToken);
+	if (!(atav->value.regToken = ASN1_STRING_dup( tok))) goto err;
+
+	if (!CRMF_CERTREQMSG_push0_regInfo( msg, atav)) goto err;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_REGINFO_REGTOKEN, CRMF_R_ERROR_SETTING_REGTOKEN_CERTREQ_ATAV);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets version to 2 in cert Template (section 5)
+ *	 version MUST be 2 if supplied.  It SHOULD be omitted.
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set_version2( CRMF_CERTREQMSG *certReqMsg)
+	{
+	if (! certReqMsg) goto err;
+
+	if (! certReqMsg->certReq->certTemplate->version)
+		/* as it is OPTIONAL it might not yet be initialized */
+		certReqMsg->certReq->certTemplate->version = ASN1_INTEGER_new();
+	ASN1_INTEGER_set( certReqMsg->certReq->certTemplate->version, 2L);
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET_VERSION2, CRMF_R_ERROR_SETTING_VERSION_2);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * sets notBefore and/or notAfter in certTemplate of the given certreqmsg
+ * (section 5) - if they are not given as 0
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set_validity( CRMF_CERTREQMSG *certReqMsg, time_t notBefore, time_t notAfter)
+	{
+	CRMF_OPTIONALVALIDITY *validity=NULL;
+	ASN1_TIME *notBeforeAsn=NULL;
+	ASN1_TIME *notAfterAsn=NULL;
+
+	if (! certReqMsg) goto err;
+
+	if (notBefore)
+		{
+		if( !(notBeforeAsn = ASN1_TIME_set(NULL, notBefore))) goto err;
+		}
+	if (notAfter)
+		{
+		if( !(notAfterAsn = ASN1_TIME_set(NULL, notAfter))) goto err;
+		}
+	if (!(validity = CRMF_OPTIONALVALIDITY_new())) goto err;
+
+	validity->notBefore = notBeforeAsn;
+	validity->notAfter	= notAfterAsn;
+
+	certReqMsg->certReq->certTemplate->validity = validity;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET_VALIDITY, CRMF_R_CRMFERROR);
+	if (notBeforeAsn) ASN1_TIME_free(notBeforeAsn);
+	if (notAfterAsn) ASN1_TIME_free(notAfterAsn);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * set the certReqId (section 5)
+ *	  certReqId contains an integer value that is used by the
+ *	  certificate requestor to associate a specific certificate request
+ *	  with a certificate response.
+ * returns 0 on error, 1 on success
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set_certReqId( CRMF_CERTREQMSG *certReqMsg, const long certReqId)
+	{
+	if (! certReqMsg) goto err;
+	if (! certReqMsg->certReq) goto err;
+
+	return ASN1_INTEGER_set(certReqMsg->certReq->certReqId, certReqId);
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET_CERTREQID, CRMF_R_CRMFERROR);
+	return 0;
+	}
+
+/* ############################################################################ *
+ * set the public Key to the certTemplate (chapgter 5)
+ *	  publicKey contains the public key for which the certificate is
+ *	  being created.  This field MUST be filled in if the requestor
+ *	  generates its own key.  The field is omitted if the key is
+ *	  generated by the RA/CA.
+ * returns 0 on error, 1 on success
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_publicKey( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey) {
+	if (! certReqMsg) goto err;
+	if (! pkey) goto err;
+
+	/* this function is not consuming the pointer */
+	return X509_PUBKEY_set(&(certReqMsg->certReq->certTemplate->publicKey), (EVP_PKEY*) pkey);
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_PUBLICKEY, CRMF_R_CRMFERROR);
+	return 0;
+}
+
+/* ############################################################################ *
+ * Set the subject name in the given certificate template (section 5)
+ *	  subject is filled in with the suggested name for the requestor.
+ *	  This would normally be filled in by a name that has been
+ *	  previously issued to the requestor by the CA.
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_subject( CRMF_CERTREQMSG *certReqMsg, const X509_NAME *subject) {
+	if (! certReqMsg) goto err;
+	if (! subject) goto err;
+
+	/* this function is *not* consuming the pointer */
+	return X509_NAME_set(&(certReqMsg->certReq->certTemplate->subject), (X509_NAME*) subject);
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_SUBJECT, CRMF_R_CRMFERROR);
+	return 0;
+}
+
+/* ############################################################################ *
+ * push an extension to the extension stack (section 5)
+ *	  extensions contains extensions that the requestor wants to have
+ *	  placed in the certificate.  These extensions would generally deal
+ *	  with things such as setting the key usage to keyEncipherment.
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push0_extension( CRMF_CERTREQMSG *certReqMsg, X509_EXTENSION *ext) {
+	int createdStack = 0;
+
+	if (! certReqMsg) goto err;
+	if (! ext) goto err;
+
+	if (! certReqMsg->certReq->certTemplate->extensions)
+		{
+		if( !(certReqMsg->certReq->certTemplate->extensions = sk_X509_EXTENSION_new_null())) goto err;
+		createdStack = 1;
+		}
+
+	if( !sk_X509_EXTENSION_push(certReqMsg->certReq->certTemplate->extensions, ext)) goto err;
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_PUSH0_EXTENSION, CRMF_R_CRMFERROR);
+
+	if (createdStack)
+		{
+		sk_X509_EXTENSION_pop_free( certReqMsg->certReq->certTemplate->extensions, X509_EXTENSION_free);
+		certReqMsg->certReq->certTemplate->extensions = NULL;
+		}
+	return 0;
+}
+
+/* ############################################################################ *
+ * Create proof-of-posession information by signing the certrequest with our
+ * private key (section 4.1). Algorithm according to key type.
+ * Aas default, for RSA+DSA SHA-1, is used for generating the input.
+ *
+ * TODO:
+ * This function does not yet work for cases other than the one listed in case 3
+ * of section 4.1.	For this it needs to put subject name and public key into
+ * the POPOSigningKey:
+ *
+   3.  The certificate subject places its name in the Certificate
+	   Template structure along with the public key.  In this case the
+	   poposkInput field is omitted from the POPOSigningKey structure.
+	   The signature field is computed over the DER-encoded certificate
+	   template structure.
+ *
+ * TODO: only RSA/DSA keys are supported so far
+ *
+ * returns a pointer to the created CRMF_POPOSIGNINGKEY on success, NULL on
+ * error
+ * ############################################################################ */
+CRMF_POPOSIGNINGKEY * CRMF_poposigningkey_new( CRMF_CERTREQUEST *certReq, const EVP_PKEY *pkey)
+	{
+	CRMF_POPOSIGNINGKEY *poposig=NULL;
+	size_t certReqSize, maxSignatureSize;
+	unsigned int sigLen;
+	unsigned char *certReqDer=NULL;
+	unsigned char *signature=NULL;
+	const EVP_MD *alg=NULL;
+
+	EVP_MD_CTX *ctx=NULL;
+
+	/* NOTE: PoposkInput is not handled here. */
+	if( !(poposig = CRMF_POPOSIGNINGKEY_new())) goto err;
+	/* get DER representation */
+	certReqSize = i2d_CRMF_CERTREQUEST( certReq, &certReqDer);
+
+	maxSignatureSize = EVP_PKEY_size( (EVP_PKEY*) pkey);
+	signature = OPENSSL_malloc(maxSignatureSize);
+
+	/* set the type of the algorithm */
+	switch (EVP_PKEY_type(pkey->type))
+		{
+#ifndef OPENSSL_NO_DSA
+		case EVP_PKEY_DSA:
+			X509_ALGOR_set0(poposig->algorithmIdentifier, OBJ_nid2obj(NID_dsaWithSHA1), V_ASN1_NULL, NULL);
+			alg = EVP_dss1();
+			break;
+#endif
+#ifndef OPENSSL_NO_RSA
+		case EVP_PKEY_RSA:
+			X509_ALGOR_set0(poposig->algorithmIdentifier, OBJ_nid2obj(NID_sha1WithRSAEncryption), V_ASN1_NULL, NULL);
+			alg = EVP_sha1();
+			break;
+#endif
+		default:
+			CRMFerr(CRMF_F_CRMF_POPOSIGNINGKEY_NEW, CRMF_R_UNSUPPORTED_ALG_FOR_POPSIGNINGKEY);
+			goto err;
+		}
+
+	ctx=EVP_MD_CTX_create();
+	if (!(EVP_SignInit_ex(ctx, alg, NULL))) goto err;
+	if (!(EVP_SignUpdate(ctx, certReqDer, certReqSize))) goto err;
+	if (!(EVP_SignFinal(ctx, signature, &sigLen, (EVP_PKEY*) pkey))) goto err;
+
+	/* set the signature value */
+	if (!(ASN1_BIT_STRING_set( poposig->signature, signature, sigLen))) goto err;
+
+	/* Actually this should not be needed but OpenSSL defaults all bitstrings to be a NamedBitList */
+	poposig->signature->flags &= ~0x07;
+	poposig->signature->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+	/* cleanup */
+	OPENSSL_free(certReqDer);
+	EVP_MD_CTX_destroy(ctx);
+	OPENSSL_free(signature);
+	return poposig;
+err:
+	CRMFerr(CRMF_F_CRMF_POPOSIGNINGKEY_NEW, CRMF_R_ERROR_SETTING_POPSIGNINGKEY);
+	if( poposig) CRMF_POPOSIGNINGKEY_free( poposig);
+	if( certReqDer) OPENSSL_free(certReqDer);
+	if( ctx) EVP_MD_CTX_destroy(ctx);
+	if( signature) OPENSSL_free(signature);
+	return NULL;
+	}
+
+/* ############################################################################ *
+ * calculate and set the proof of possession based on the popoMethod (define in cmp.h)
+ * the following types are supported so far (#defines in crfm.h):
+ *	 CRMF_POPO_NONE: ProofOfPossession field omitted, CA/RA uses out-of-band method to verify POP (compare RFC 4211, section 4).
+ *	 CRMF_POPO_SIGNATURE: according to section 4.1 (only case 3 supported so far)
+ *	 CRMF_POPO_ENCRCERT:  according to section 4.2 with the indirect method
+ *	 (subsequentMessage/enccert)
+ *
+	  subsequentMessage is used to indicate that the POP will be
+	  completed by decrypting a message from the CA/RA and returning a
+	  response.  The type of message to be decrypted is indicated by the
+	  value used.
+
+		 encrCert indicates that the certificate issued is to be
+		 returned in an encrypted form.  The requestor is required to
+		 decrypt the certificate and prove success to the CA/RA.  The
+		 details of this are provided by the CRP.
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CRMF_CERTREQMSG_calc_and_set_popo( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey, int popoMethod)
+	{
+	CRMF_PROOFOFPOSSESION *newPopo=NULL;
+
+	if (popoMethod == CRMF_POPO_NONE) return 1;  /* nothing to be done */
+
+	if (! certReqMsg) goto err;
+	if (! pkey) goto err;
+
+	if( !(newPopo = CRMF_PROOFOFPOSSESION_new())) goto err;
+
+	switch (popoMethod)
+		{
+		case CRMF_POPO_RAVERIFIED:
+			newPopo->type = CRMF_PROOFOFPOSESSION_RAVERIFIED;
+			newPopo->value.raVerified = ASN1_NULL_new();
+			break;
+
+		case CRMF_POPO_SIGNATURE:
+			if( !(newPopo->value.signature = CRMF_poposigningkey_new( certReqMsg->certReq, pkey))) goto err;
+			newPopo->type = CRMF_PROOFOFPOSESSION_SIGNATURE;
+			break;
+
+		case CRMF_POPO_ENCRCERT:
+			newPopo->type = CRMF_PROOFOFPOSESSION_KEYENCIPHERMENT;
+			newPopo->value.keyEncipherment = CRMF_POPOPRIVKEY_new();
+
+			newPopo->value.keyEncipherment->type = CRMF_POPOPRIVKEY_SUBSEQUENTMESSAGE;
+
+			newPopo->value.keyEncipherment->value.subsequentMessage = ASN1_INTEGER_new();
+			ASN1_INTEGER_set(newPopo->value.keyEncipherment->value.subsequentMessage, CRMF_SUBSEQUENTMESSAGE_ENCRCERT);
+			break;
+
+		default:
+			CRMFerr(CRMF_F_CRMF_CERTREQMSG_CALC_AND_SET_POPO, CRMF_R_UNSUPPORTED_METHOD_FOR_CREATING_POPO);
+			goto err;
+		}
+
+	if(certReqMsg->popo)
+		/* OPTIONAL but initialized before */
+		CRMF_PROOFOFPOSSESION_free(certReqMsg->popo);
+	certReqMsg->popo = newPopo;
+
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_CALC_AND_SET_POPO, CRMF_R_ERROR_CALCULATING_AND_SETTING_POPO);
+	if( newPopo) CRMF_PROOFOFPOSSESION_free( newPopo);
+	return 0;
+	}
+
diff -Naur crypto/crmf/crmf_msg.c crypto-/crmf/crmf_msg.c
--- cryptoold/crmf/crmf_msg.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/crmf/crmf_msg.c	2017-04-20 16:50:26.941043274 +0700
@@ -0,0 +1,122 @@
+/* vim: set cino={1s noet ts=4 sts=4 sw=4: */
+/* crypto/crmf/crmf_msg.c
+ * Functions for creating CRMF (RFC 4211) messages for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+/* ############################################################################ */
+/* In this file are the functions which build and evaluate the CRMF messages	*/
+/* ############################################################################ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/x509.h>
+#include <string.h>
+
+/* ############################################################################ * 
+ * creates a new CRMF certifcate request message
+ * TODO there are some optional settings which are not cared for yet
+ * TODO maybe create a crmf_ctx?
+ * ############################################################################ */
+CRMF_CERTREQMSG * CRMF_cr_new( const long certReqId, 
+							   const EVP_PKEY *pkey, 
+							   const X509_NAME *subject, 
+							   X509_EXTENSIONS *extensions)
+	{
+	CRMF_CERTREQMSG *certReqMsg;
+	int i;
+
+	if( !(certReqMsg = CRMF_CERTREQMSG_new())) goto err;
+
+#if 0
+	/* version MUST be 2 if supplied.  It SHOULD be omitted. */
+	CRMF_CERTREQMSG_set_version2( certReqMsg);
+#endif
+
+	CRMF_CERTREQMSG_set_certReqId( certReqMsg, certReqId);
+	if (!CRMF_CERTREQMSG_set1_publicKey( certReqMsg, pkey))
+		{
+		CRMFerr(CRMF_F_CRMF_CR_NEW, CRMF_R_ERROR_SETTING_PUBLIC_KEY);
+		goto err;
+		}
+
+	CRMF_CERTREQMSG_set1_subject( certReqMsg, subject);
+
+	/* validity time could be set here */
+
+	for (i = 0; i < sk_X509_EXTENSION_num(extensions); i++)
+		/* X509v3_add_ext will allocate new stack if there isn't one already */
+		X509v3_add_ext(&certReqMsg->certReq->certTemplate->extensions, sk_X509_EXTENSION_value(extensions, i), i);
+	
+	return certReqMsg;
+err:
+	CRMFerr(CRMF_F_CRMF_CR_NEW, CRMF_R_CRMFERROR);
+	if( certReqMsg)
+		CRMF_CERTREQMSG_free( certReqMsg);
+	return NULL;
+	}
+
diff -Naur crypto/crmf/crmf_pbm.c crypto-/crmf/crmf_pbm.c
--- cryptoold/crmf/crmf_pbm.c	1970-01-01 07:00:00.000000000 +0700
+++ crypto/crmf/crmf_pbm.c	2017-04-20 16:50:26.945043172 +0700
@@ -0,0 +1,222 @@
+/* vim: set cino={1s noet ts=4 sts=4 sw=4: */
+/* crypto/crmf/crmf_pbm.c
+ * CRMF (RFC 4211) "Password Based Mac" functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in
+ *	  the documentation and/or other materials provided with the
+ *	  distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *	  software must display the following acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *	  endorse or promote products derived from this software without
+ *	  prior written permission. For written permission, please contact
+ *	  openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *	  nor may "OpenSSL" appear in their names without prior written
+ *	  permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *	  acknowledgment:
+ *	  "This product includes software developed by the OpenSSL Project
+ *	  for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2014 Nokia Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia for contribution to the OpenSSL project.
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#include <openssl/err.h>
+
+#define SALT_LEN		 16
+#define ITERATION_COUNT 500
+
+/* ############################################################################ *
+ * creates and initializes CRMF_PBMPARAMETER (section 4.4)
+ * returns pointer to CRMF_PBMPARAMETER on success, NULL on error
+ * TODO: this should take the parameters to be set via the arguments
+ * ############################################################################ */
+CRMF_PBMPARAMETER * CRMF_pbm_new(void)
+	{
+	CRMF_PBMPARAMETER *pbm=NULL;
+	unsigned char salt[SALT_LEN];
+
+	if(!(pbm = CRMF_PBMPARAMETER_new())) goto err;
+
+	/* salt contains a randomly generated value used in computing the key
+	 * of the MAC process.	The salt SHOULD be at least 8 octets (64
+	 * bits) long.
+	 */
+	RAND_pseudo_bytes(salt, SALT_LEN);
+	if (!(ASN1_OCTET_STRING_set(pbm->salt, salt, SALT_LEN))) goto err;
+
+	/* owf identifies the algorithm and associated parameters used to
+	 * compute the key used in the MAC process.  All implementations MUST
+	 * support SHA-1.
+	 */
+	/* TODO right now SHA-1 is hardcoded */
+	X509_ALGOR_set0(pbm->owf, OBJ_nid2obj(NID_sha1), V_ASN1_UNDEF, NULL);
+
+	/*
+	   iterationCount identifies the number of times the hash is applied
+	   during the key computation process.	The iterationCount MUST be a
+	   minimum of 100.	Many people suggest using values as high as 1000
+	   iterations as the minimum value.  The trade off here is between
+	   protection of the password from attacks and the time spent by the
+	   server processing all of the different iterations in deriving
+	   passwords.  Hashing is generally considered a cheap operation but
+	   this may not be true with all hash functions in the future.
+	   */
+	ASN1_INTEGER_set(pbm->iterationCount, ITERATION_COUNT);
+
+	/* mac identifies the algorithm and associated parameters of the MAC
+	   function to be used.  All implementations MUST support HMAC-SHA1
+	   [HMAC].	All implementations SHOULD support DES-MAC and Triple-
+	   DES-MAC [PKCS11].
+	   */
+	/* TODO right now HMAC-SHA1 is hardcoded */
+	/* X509_ALGOR_set0(mac, OBJ_nid2obj(NID_id_alg_dh_sig_hmac_sha1), V_ASN1_UNDEF, NULL); */
+	X509_ALGOR_set0(pbm->mac, OBJ_nid2obj(NID_hmac_sha1), V_ASN1_UNDEF, NULL);
+
+	return pbm;
+err:
+	if(pbm) CRMF_PBMPARAMETER_free(pbm);
+	return NULL;
+	}
+
+
+/* ############################################################################
+ * this function calculates the PBM based on the settings of the given CRMF_PBMPARAMENTER
+ * @pbm identifies the algorithms to use
+ * @msg message to apply the PBM for
+ * @msgLen length of the message
+ * @secret key to use
+ * @secretLen length of the key
+ * @mac pointer to the computed mac, is allocated here, will be freed if not
+ *		pointing to NULL
+ * @macLen pointer to the length of the mac, will be set
+ *
+ * returns 1 at success, 0 at error
+ * ############################################################################ */
+int CRMF_passwordBasedMac_new( const CRMF_PBMPARAMETER *pbm,
+			   const unsigned char* msg, size_t msgLen, 
+			   const unsigned char* secret, size_t secretLen,
+			   unsigned char** mac, unsigned int* macLen
+			   )
+	{
+	const EVP_MD *m=NULL;
+	EVP_MD_CTX *ctx=NULL;
+	unsigned char basekey[EVP_MAX_MD_SIZE];
+	unsigned int basekeyLen;
+	long iterations;
+
+	if (!mac) goto err;
+	if( *mac) OPENSSL_free(*mac);
+
+	if (!pbm) goto err;
+	if (!msg) goto err;
+	if (!secret) goto err;
+
+	*mac = OPENSSL_malloc(EVP_MAX_MD_SIZE);
+
+	OpenSSL_add_all_digests();
+
+	/*
+	 * owf identifies the algorithm and associated parameters used to
+	 * compute the key used in the MAC process.  All implementations MUST
+	 * support SHA-1.
+	 */
+	if (!(m = EVP_get_digestbyobj(pbm->owf->algorithm))) goto err;
+
+	ctx=EVP_MD_CTX_create();
+
+	/* compute the basekey of the salted secret */
+	if (!(EVP_DigestInit_ex(ctx, m, NULL))) goto err;
+	/* first the secret */
+	EVP_DigestUpdate(ctx, secret, secretLen);
+	/* then the salt */
+	EVP_DigestUpdate(ctx, pbm->salt->data, pbm->salt->length);
+	if (!(EVP_DigestFinal_ex(ctx, basekey, &basekeyLen))) goto err;
+
+	/* the first iteration is already done above -> -1 */
+	iterations = ASN1_INTEGER_get(pbm->iterationCount)-1;
+	while( iterations--)
+		{
+		if (!(EVP_DigestInit_ex(ctx, m, NULL))) goto err;
+		EVP_DigestUpdate(ctx, basekey, basekeyLen);
+		if (!(EVP_DigestFinal_ex(ctx, basekey, &basekeyLen))) goto err;
+		}
+
+	/*
+	 * mac identifies the algorithm and associated parameters of the MAC
+	 * function to be used.  All implementations MUST support HMAC-SHA1
+	 * [HMAC].	All implementations SHOULD support DES-MAC and Triple-
+	 * DES-MAC [PKCS11].
+	 */
+	switch (OBJ_obj2nid(pbm->mac->algorithm))
+		{
+		case NID_hmac_sha1:
+			HMAC(EVP_sha1(), basekey, basekeyLen, msg, msgLen, *mac, macLen);
+			break;
+			/* optional TODO: DES-MAC, Triple DES-MAC */
+			/* which NIDs to use for these algorithms??? */
+		default:
+			CRMFerr(CRMF_F_CRMF_PASSWORDBASEDMAC_NEW, CRMF_R_UNSUPPORTED_ALGORITHM);
+			goto err;
+		}
+
+	/* cleanup */
+	EVP_MD_CTX_destroy(ctx);
+
+	return 1;
+err:
+	if( mac && *mac) OPENSSL_free(*mac);
+	CRMFerr(CRMF_F_CRMF_PASSWORDBASEDMAC_NEW, CRMF_R_CRMFERROR);
+	return 0;
+	}
diff -Naur crypto/crmf/rfc4211.txt crypto-/crmf/rfc4211.txt
--- cryptoold/crmf/rfc4211.txt	1970-01-01 07:00:00.000000000 +0700
+++ crypto/crmf/rfc4211.txt	2017-04-20 16:50:26.945043172 +0700
@@ -0,0 +1,2243 @@
+
+
+
+
+
+
+Network Working Group                                          J. Schaad
+Request for Comments: 4211                       Soaring Hawk Consulting
+Obsoletes: 2511                                           September 2005
+Category: Standards Track
+
+
+               Internet X.509 Public Key Infrastructure
+               Certificate Request Message Format (CRMF)
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2005).
+
+Abstract
+
+   This document describes the Certificate Request Message Format (CRMF)
+   syntax and semantics.  This syntax is used to convey a request for a
+   certificate to a Certification Authority (CA), possibly via a
+   Registration Authority (RA), for the purposes of X.509 certificate
+   production.  The request will typically include a public key and the
+   associated registration information.  This document does not define a
+   certificate request protocol.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                     [Page 1]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Table Of Contents
+
+   1. Introduction and Terminology ....................................3
+   2. Overview ........................................................3
+      2.1. Changes since RFC 2511 .....................................4
+   3. CertReqMessage Syntax ...........................................4
+   4. Proof-of-Possession (POP) .......................................5
+      4.1. Signature Key POP ..........................................7
+      4.2. Key Encipherment Keys ......................................9
+           4.2.1. Private Key Info Content Type ......................11
+           4.2.2. Private Key Structures .............................12
+           4.2.3. Challenge-Response Guidelines ......................13
+      4.3. Key Agreement Keys ........................................14
+      4.4. Use of Password-Based MAC .................................14
+   5. CertRequest syntax .............................................16
+   6. Controls Syntax ................................................18
+      6.1. Registration Token Control ................................18
+      6.2. Authenticator Control .....................................19
+      6.3. Publication Information Control ...........................19
+      6.4. Archive Options Control ...................................21
+      6.5. OldCert ID Control ........................................23
+      6.6. Protocol Encryption Key Control ...........................23
+   7. RegInfo Controls ...............................................23
+      7.1. utf8Pairs .................................................23
+      7.2. certReq ...................................................24
+   8. Object Identifiers .............................................24
+   9. Security Considerations ........................................25
+   10. References ....................................................26
+      10.1. Normative References .....................................26
+      10.2. Informative References ...................................27
+   11. Acknowledgements ..............................................28
+   Appendix A.  Use of RegInfo for Name-Value Pairs ..................29
+      A.1.  Defined Names ............................................29
+      A.2.  IssuerName, SubjectName, and Validity Value Encoding .....29
+   Appendix B.  ASN.1 Structures and OIDs ............................32
+   Appendix C.  Why do Proof-of-Possession (POP) .....................38
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                     [Page 2]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+1.  Introduction and Terminology
+
+   This document describes the Certificate Request Message Format
+   (CRMF).  A Certificate Request Message object is used within a
+   protocol to convey a request for a certificate to a Certification
+   Authority (CA), possibly via a Registration Authority (RA), for the
+   purposes of X.509 certificate production.  The request will typically
+   include a public key and the associated registration information.
+
+   The certificate request object defined in this document is not a
+   stand-alone protocol.  The information defined in this document is
+   designed to be used by an externally defined Certificate Request
+   Protocol (CRP).  The referencing protocol is expected to define what
+   algorithms are used, and what registration information and control
+   structures are defined.  Many of the requirements in this document
+   refer to the referencing Certificate Request Protocol (CRP).
+
+   Certificate requests may be submitted by an RA requesting a
+   certificate on behalf of a Subject, by a CA requesting a cross-
+   certificate from another CA, or directly by an End Entity (EE).
+
+   The key words "MUST", "REQUIRED", "SHOULD", "RECOMMENDED", and "MAY"
+   in this document (in uppercase, as shown) are to be interpreted as
+   described in RFC 2119 [RFC2119].
+
+2.  Overview
+
+   Construction of a certification request involves the following steps:
+
+   a)  A CertRequest object is constructed.  This object may include the
+       public key, all or a portion of the Subject name, other requested
+       certificate fields, and additional control information related to
+       the registration process.  Depending on the CRP, this information
+       can be specified by the Subject and potentially modified by an
+       RA, or specified by the RA based on knowledge of the Subject or
+       documentation presented by the Subject.
+
+   b)  If required, a proof-of-possession (of the private key
+       corresponding to the public key for which a certificate is being
+       requested) value is calculated.
+
+   c)  Additional registration information can be combined with the
+       proof-of-possession value and the CertRequest structure to form a
+       CertReqMessage.  Additional registration information can be added
+       by both the Subject and an RA.
+
+
+
+
+
+
+Schaad                      Standards Track                     [Page 3]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   d)  The CertReqMessage is securely communicated to a CA.  Specific
+       means of secure transport are to be specified by each CRP that
+       refers to this document.
+
+2.1.  Changes since RFC 2511
+
+   1.  Addition of an introduction section.
+
+   2.  Addition of the concept of a CRP and language relating to CRPs.
+
+   3.  In section 6.2, changed regToken to authenticator.
+
+   4.  Add information describing the contents of the EncryptedValue
+       structure.
+
+   5.  Changed name and contents of OID {id-regInfo 1}.
+
+   6.  Added text detailing what goes into the fields of the different
+       structures defined in the document.
+
+   7.  Replaced Appendix A with a reference to [RFC2875].  The only
+       difference is that the old text specified to use subject alt name
+       instead of subject name if subject name was empty.  This is not
+       possible for a CA certificate issued using PKIX.  It would
+       however be useful to update RFC 2875 to have this fallback
+       position.
+
+   7.  Insert Appendix C describing why POP is necessary and what some
+       of the different POP attacks are.
+
+   8.  pop field in the CertReqMsg structure has been renamed to popo to
+       avoid confusion between POP and pop.
+
+   9.  The use of the EncryptedValue structure has been deprecated in
+       favor of the EnvelopedData structure.
+
+   10.  Add details on how private keys are to be structured when
+       encrypted.
+
+   11.  Allow for POP on key agreement algorithms other than DH.
+
+3.  CertReqMessage Syntax
+
+   A certificate request message is composed of the certificate request,
+   an optional proof-of-possession field, and an optional registration
+   information field.
+
+
+
+
+
+Schaad                      Standards Track                     [Page 4]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
+
+   CertReqMsg ::= SEQUENCE {
+      certReq   CertRequest,
+      popo       ProofOfPossession  OPTIONAL,
+      -- content depends upon key type
+      regInfo   SEQUENCE SIZE(1..MAX) of AttributeTypeAndValue OPTIONAL
+   }
+
+   The fields of CertReqMsg have the following meaning:
+
+      certReq contains the template of the certificate being requested.
+      The template is filled in by (or on behalf of) the Subject.  Not
+      all fields within the template need to be specified.  Details on
+      this field are found in section 5.
+
+      popo contains the value used to demonstrate that the entity that
+      will be identified as the Subject of the certificate is actually
+      in possession of the corresponding private key.  This field varies
+      in structure and content based on the public key algorithm and the
+      mode (encryption vs. signature) in which the algorithm is used, as
+      specified in the KeyUsage field of the certificate to be issued.
+      Details on this field are found in section 4.
+
+      regInfo field SHOULD contain only supplementary information
+      relating to the context of the certificate request, where such
+      information is required to fulfill the request.  This information
+      might include subscriber contact information, billing information,
+      or other ancillary information useful to fulfillment of the
+      request.
+
+   Information directly related to certificate content SHOULD be
+   included in the certReq content.  However, inclusion of additional
+   certReq content by RAs can invalidate the popo field (depending on
+   the details of the POP method used).  Therefore, data intended for
+   certificate content MAY be provided in regInfo.
+
+   It is the responsibility of a referencing CRP to define the details
+   of what can be specified in the regInfo field.  This document
+   describes one method of encoding the information found in this field.
+   Details on this encoding are found in Appendix A.
+
+4.  Proof-of-Possession (POP)
+
+   In order to prevent certain attacks (see Appendix C) and to allow a
+   CA/RA to properly check the validity of the binding between a subject
+   and a key pair, the PKI management structures specified here make it
+   possible for a subject to prove that it has possession of (i.e., is
+
+
+
+Schaad                      Standards Track                     [Page 5]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   able to use) the private key corresponding to the public key for
+   which a certificate is requested.  A given CRP is free to choose how
+   to enforce POP (e.g., out-of-band procedural means versus the CRMF
+   in-band message) in its certification exchanges.  Within a given CRP,
+   CAs and RAs are free to choose from among the POP methods provided
+   (i.e., this is a policy issue local to an RA/CA).  A CRP SHOULD
+   define either which POP methods are required, or specify a mechanism
+   for clients to discover the POP methods supported.
+
+   Any CRP referencing this document MUST enforce POP by some means.
+   There are currently many non-PKIX operational protocols in use
+   (various electronic mail protocols are one example) that do not
+   explicitly check the binding between the end entity and the private
+   key.  Until operational protocols that do verify the binding (for
+   signature, encryption, and key agreement key pairs) exist, and are
+   ubiquitous, this binding cannot be assumed to have been verified by
+   the CA/RA.  Therefore, one cannot truly know if the binding of the
+   public key and the identity in the certificate is actually correct.
+
+   POP is accomplished in different ways depending on the type of key
+   for which a certificate is requested.  If a key can be used for
+   multiple purposes (e.g., a signing and decryption RSA key), then any
+   of the methods MAY be used.  Protocol designers need to be aware that
+   there can be hardware limitations on what POP methods may be usable,
+   e.g., if the private key is maintained in a hardware token.
+
+   This specification allows for cases where POP is validated by the CA,
+   the RA, or both.  Some policies require the CA to verify POP during
+   certificate issuance, in which case the RA MUST forward the end
+   entity's CertRequest and ProofOfPossession fields unaltered to the
+   CA.  (In this case, the RA could verify the POP and reject failing
+   certificate requests rather than forwarding them to the CA.)  If the
+   CA is not required by policy to verify POP, then the RA SHOULD
+   forward the end entity's request and proof, unaltered, to the CA as
+   above.  If this is not possible (for example because the RA verifies
+   POP by an out-of-band method), then the RA uses the raVerified
+   element to attest to the CA that the required proof has been
+   validated.  If the CA/RA uses an out-of-band method to verify POP
+   (such as physical delivery of CA/RA-generated private keys), then the
+   ProofOfPossession field is omitted.
+
+   ProofOfPossession ::= CHOICE {
+       raVerified        [0] NULL,
+       signature         [1] POPOSigningKey,
+       keyEncipherment   [2] POPOPrivKey,
+       keyAgreement      [3] POPOPrivKey }
+
+
+
+
+
+Schaad                      Standards Track                     [Page 6]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of ProofOfPossession have the following meaning:
+
+      raVerified indicates that the RA has performed the POP required on
+      the certificate request.  This field is used by an RA when 1) the
+      CA is not required to do its own POP verification and 2) the RA
+      needs to change the contents of the certReq field.  CRPs MUST
+      provide a method for the RA to sign the ProofOfPossession.  A
+      requestor MUST NOT set this field and an RA/CA MUST NOT accept a
+      ProofOfPossession where the requestor sets this field.
+
+      signature is used for performing POP with signature keys.  The
+      details of this field are covered in section 4.1.
+
+      keyEncipherment is used for performing POP with key encipherment
+      encryption based keys (i.e., RSA).  The details of this field are
+      covered in section 4.2.
+
+      keyAgreement is used for performing POP with key agreement type
+      encryption keys (i.e., DH).  The details of this field are covered
+      in section 4.3.
+
+4.1.  Signature Key POP
+
+   POP for a signature key is accomplished by performing a signature
+   operation on a piece of data containing the identity for which the
+   certificate is desired.
+
+   There are three cases that need to be looked at when doing a POP for
+   a signature key:
+
+   1.  The certificate subject has not yet established an authenticated
+       identity with a CA/RA, but has a password and identity string
+       from the CA/RA.  In this case, the POPOSigningKeyInput structure
+       would be filled out using the publicKeyMAC choice for authInfo,
+       and the password and identity would be used to compute the
+       publicKeyMAC value.  The public key for the certificate being
+       requested would be placed in both the POPOSigningKeyInput and the
+       Certificate Template structures.  The signature field is computed
+       over the DER-encoded POPOSigningKeyInput structure.
+
+   2.  The CA/RA has established an authenticated identity for the
+       certificate subject, but the requestor is not placing it into the
+       certificate request.  In this case, the POPOSigningKeyInput
+       structure would be filled out using the sender choice for
+       authInfo.  The public key for the certificate being requested
+       would be placed in both the POPOSigningKeyInput and the
+       Certificate Template structures.  The signature field is computed
+       over the DER-encoded POPOSigningKeyInput structure.
+
+
+
+Schaad                      Standards Track                     [Page 7]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   3.  The certificate subject places its name in the Certificate
+       Template structure along with the public key.  In this case the
+       poposkInput field is omitted from the POPOSigningKey structure.
+       The signature field is computed over the DER-encoded certificate
+       template structure.
+
+   POPOSigningKey ::= SEQUENCE {
+       poposkInput         [0] POPOSigningKeyInput OPTIONAL,
+       algorithmIdentifier     AlgorithmIdentifier,
+       signature               BIT STRING }
+
+   The fields of POPOSigningKey have the following meaning:
+
+      poposkInput contains the data to be signed, when present.  This
+      field MUST be present when the certificate template does not
+      contain both the public key value and a subject name value.
+
+      algorithmIdentifier identifiers the signature algorithm and an
+      associated parameters used to produce the POP value.
+
+      signature contains the POP value produce.  If poposkInput is
+      present, the signature is computed over the DER-encoded value of
+      poposkInput.  If poposkInput is absent, the signature is computed
+      over the DER-encoded value of certReq.
+
+   POPOSigningKeyInput ::= SEQUENCE {
+       authInfo            CHOICE {
+           sender              [0] GeneralName,
+           -- used only if an authenticated identity has been
+           -- established for the sender (e.g., a DN from a
+           -- previously-issued and currently-valid certificate)
+           publicKeyMAC        PKMACValue },
+           -- used if no authenticated GeneralName currently exists for
+           -- the sender; publicKeyMAC contains a password-based MAC
+           -- on the DER-encoded value of publicKey
+       publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
+
+   The fields of POPOSigningKeyInput have the following meaning:
+
+      sender contains an authenticated identity that has been previously
+      established for the subject.
+
+      publicKeyMAC contains a computed value that uses a shared secret
+      between the CA/RA and the certificate requestor.
+
+      publicKey contains a copy of the public key from the certificate
+      template.  This MUST be exactly the same value as is contained in
+      the certificate template.
+
+
+
+Schaad                      Standards Track                     [Page 8]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   PKMACValue ::= SEQUENCE {
+      algId  AlgorithmIdentifier,
+      value  BIT STRING }
+
+   The fields of PKMACValue have the following meaning:
+
+      algId identifies the algorithm used to compute the MAC value.  All
+      implementations MUST support id-PasswordBasedMAC.  The details on
+      this algorithm are presented in section 4.4.
+
+      value contains the computed MAC value.  The MAC value is computed
+      over the DER-encoded public key of the certificate subject.
+
+   The CA/RA identifies the shared secret to be used by looking at 1)
+   the general name field in the certificate request or 2) either the
+   regToken (see section 6.1) or authToken (see section 6.2) controls.
+
+4.2.  Key Encipherment Keys
+
+   POP for key encipherment keys is accomplished by one of three
+   different methods.  The private key can be provided to the CA/RA, an
+   encrypted challenge from the CA/RA can be decrypted (direct method),
+   or the created certificate can be returned encrypted and used as the
+   challenge response (indirect method).
+
+   POPOPrivKey ::= CHOICE {
+       thisMessage       [0] BIT STRING,   -- deprecated
+       subsequentMessage [1] SubsequentMessage,
+       dhMAC             [2] BIT STRING,   -- deprecated
+       agreeMAC          [3] PKMACValue,
+       encryptedKey      [4] EnvelopedData }
+     -- for keyAgreement (only), possession is proven in this message
+     -- (which contains a MAC (over the DER-encoded value of the
+     -- certReq parameter in CertReqMsg, which must include both subject
+     -- and publicKey) based on a key derived from the end entity's
+     -- private DH key and the CA's public DH key);
+     -- the dhMAC value MUST be calculated as per the directions given
+     -- in RFC 2875 for static DH proof-of-possession.
+
+   SubsequentMessage ::= INTEGER {
+       encrCert (0),
+       challengeResp (1) }
+
+   The fields of POPOPrivKey have the following meaning:
+
+      thisMessage contains the encrypted private key for which a
+      certificate is to be issued.  The possession of the private key is
+      proved by providing it to the CA/RA.  This field was incorrectly
+
+
+
+Schaad                      Standards Track                     [Page 9]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      typed when the specification was first written.  The correct way
+      to use this field is to create an EncryptedValue structure where
+      the encrypted content is the private key, the EncryptedValue
+      structure is then wrapped in the BIT STRING type.  This field has
+      been deprecated in favor of encryptedKey.
+
+      subsequentMessage is used to indicate that the POP will be
+      completed by decrypting a message from the CA/RA and returning a
+      response.  The type of message to be decrypted is indicated by the
+      value used.
+
+         encrCert indicates that the certificate issued is to be
+         returned in an encrypted form.  The requestor is required to
+         decrypt the certificate and prove success to the CA/RA.  The
+         details of this are provided by the CRP.
+
+         challengeResponse indicates that a challenge message is to be
+         sent from the CA/RA to the requestor.  The details of the
+         challenge message and the response are to be provided by the
+         CRP.
+
+      dhMAC is used for Diffie-Hellman key agreement keys.  It contains
+      a computed MAC that is obtained by using the requestor's private
+      key and the CA/RA public key.  The use of this field is deprecated
+      in favor of the agreeMAC field.  Details are covered in section
+      4.3.
+
+      agreeMAC is used for key agreement keys.  It contains a computed
+      MAC that is obtained by using the requestor's private key and a
+      matching CA/RA public key.  Details are covered in section 4.3.
+
+         macAlg contains the algorithm identifying the method used to
+         compute the MAC value.
+
+         macValue contains the computed MAC value.
+
+      encryptedKey contains the encrypted private key matching the
+      public key for which the certificate is to be issued.  It also
+      contains an identification value to indicate it was constructed by
+      the requestor of the certificate.  The enveloped content type MUST
+      be id-ct-encKeyWithID.
+
+   It is expected that protocols that incorporate this specification
+   will include the confirmation and challenge-response messages
+   necessary for a complete protocol.
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 10]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+4.2.1.  Private Key Info Content Type
+
+   This content type is used for 1) proving possession of private keys
+   and 2) escrow of private keys (using the archive options control in
+   section 6.4).  This structure is based on the private key info
+   structure from [PKCS8] but has one deliberate difference.  There is a
+   potential attack on escrow agents if they decrypt the private key but
+   don't know to whom the encrypted key is supposed to belong.  An
+   attacker could intercept the encrypted private key, build a
+   certificate request around it and then ask for a recovery operation
+   on the private key.
+
+   This content type and its structure are:
+
+      id-ct-encKeyWithID OBJECT IDENTIFIER ::= {id-ct 21}
+
+      EncKeyWithID ::= SEQUENCE {
+        privateKey           PrivateKeyInfo,
+        identifier CHOICE {
+          string               UTF8String,
+          generalName          GeneralName
+        } OPTIONAL
+      }
+
+      PrivateKeyInfo ::= SEQUENCE {
+         version                   INTEGER,
+         privateKeyAlgorithm       AlgorithmIdentifier,
+         privateKey                OCTET STRING,
+         attributes                [0] IMPLICIT Attributes OPTIONAL
+      }
+
+   Attributes ::= SET OF Attribute
+
+   The fields of EncKeyWithID are defined as:
+
+      privateKey contains the encoded private key.  Definitions for
+      three private key formats are included in this document.
+      Specifications for asymmetric algorithms need to include both the
+      public and private key definitions for consistency.
+
+      identifier contains a name that the CA/RA can associate with the
+      requestor.  This will generally be either the DN of a certificate
+      or a text token passed and known to both the requestor and the
+      CA/RA.  This field MUST be present if the purpose is to prove
+      possession of the private key.  The field SHOULD be present if
+      archiving a key and the archive agent is expected to decrypt the
+      key.
+
+
+
+
+Schaad                      Standards Track                    [Page 11]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of PrivatekeyInfo are define as:
+
+      version MUST be the value 0
+
+      privateKeyAlgorithm contains the identifier for the private key
+      object
+
+      privateKey is an octet string whose contents is the private key
+      and whose format is defined by the value of privateKeyAlgorithm.
+
+      attributes is a set of attributes.  They are extended information
+      that is part of the private key information.
+
+4.2.2.  Private Key Structures
+
+   We are defining the structures here to be used for three algorithms.
+
+4.2.2.1.  D-H Private Keys
+
+   When creating a PrivateKeyInfo for a D-H key, the following rules
+   apply:
+
+     1. The privateKeyAlgorithm MUST be set to id-dh-private-number.
+        The parameter for id-dh-private-number is DomainParameters
+        (imported from [PKIXALG]).
+
+     2. The ASN structure for privateKey MUST be
+
+        DH-PrivateKey ::= INTEGER
+
+     3. The attributes field MUST be omitted.
+
+4.2.2.2.  DSA Private Keys
+
+   When creating a PrivateKeyInfo for a DSA key, the following rules
+   apply:
+
+     1. The privateKeyAlgorithm MUST be set to id-dsa.  The parameters
+        for id-dsa is Dss-Parms (imported from [PKIXALG]).
+
+     2. The ASN structure for privateKey MUST be
+
+        DSA-PrivateKey ::= INTEGER
+
+     3. The attributes field MUST be omitted.
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 12]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+4.2.2.3.  RSA Private Keys
+
+   When creating a PrivateKeyInfo for an RSA key, the following rules
+   apply:
+
+     1. The privateKeyAlgorithm MUST be set to rsaEncryption.
+
+     2. The ASN structure for privateKey MUST be RSAPrivateKey (defined
+        in [PKCS1])
+
+     3. The attributes field MUST be omitted.
+
+4.2.3.  Challenge-Response Guidelines
+
+   The following provides guidelines to enrollment protocol authors
+   about how an indirect proof-of-possession is expected to work and
+   about some of the areas where one needs to be careful in crafting the
+   messages to implement this POP method.
+
+   1.  The original enrollment request includes a proof of identity of
+       some type and the public portion of the encryption key.  Note
+       that the proof of identity needs to cover the public portion of
+       the encryption key to prevent substitution attacks (where the
+       attacker changes your public key for his public key).
+
+   2.  The response message from the server includes an encrypted data
+       value of some type.  That value needs to be authenticated in some
+       fashion as having come from the server.  The specification needs
+       to include the specifics of how this value is returned for the
+       different key types.  For RSA keys, the value can be specified as
+       being directly encrypted by the RSA public key; this will not
+       work for a D-H key where you need to specify an indirect
+       mechanism to encrypt the value.
+
+   3.  The second request message includes a hash of the decrypted
+       value.  This message MUST NOT be just the hash of the encrypted
+       value, as one should never "sign" a completely random value.  It
+       is desirable to include information such as the identity string
+       in the hashing process so that this can be made explicitly.  This
+       returned value MUST be included in a second proof of identity.
+
+   It is strongly suggested that transaction identifiers and nonce
+   values be required when performing indirect POP, as this allows for
+   1) tying the different messages in the process together and 2)
+   letting each entity inject some amount of random data into the
+   process of doing identity proofs.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 13]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+4.3.  Key Agreement Keys
+
+   POP for key agreement keys is accomplished by one of four different
+   methods.  The first three are identical to those presented above for
+   key encryption keys.  The fourth method takes advantage of the fact
+   that a shared secret is produced and that the value can be used to
+   MAC information.
+
+   When the direct or indirect encryption methods presented above are
+   used, the CA/RA will need to create an ephemeral key for those cases
+   where the encryption algorithm parameters do not match between the
+   CA/RA and the requestor.
+
+   The end entity may also MAC the certificate request (using a shared
+   secret key derived from computation) as a fourth alternative for
+   demonstrating POP.  This option may be used only if the CA/RA already
+   has a certificate that is known to the end entity and if the Subject
+   is able to use the CA/RA's parameters.
+
+   For the DH key agreement algorithm, all implementations MUST support
+   the static DH Proof-of-Possession.  Details on this algorithm can be
+   found in section 3 of [RFC2875].  NOTE: If either the subject or
+   issuer name in the CA certificate is empty, then the alternative name
+   should be used in its place.
+
+4.4.  Use of Password-Based MAC
+
+   This MAC algorithm was designed to take a shared secret (a password)
+   and use it to compute a check value over a piece of information.  The
+   assumption is that, without the password, the correct check value
+   cannot be computed.  The algorithm computes the one-way function
+   multiple times in order to slow down any dictionary attacks against
+   the password value.
+
+   The algorithm identifier and parameter structure used for Password-
+   Based MAC is:
+
+      id-PasswordBasedMAC OBJECT IDENTIFIER ::=
+                                         { 1 2 840 113533 7 66 13}
+
+      PBMParameter ::= SEQUENCE {
+         salt                OCTET STRING,
+         owf                 AlgorithmIdentifier,
+         iterationCount      INTEGER,
+         mac                 AlgorithmIdentifier
+         )
+
+
+
+
+
+Schaad                      Standards Track                    [Page 14]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of PEMParameter have the following meaning:
+
+      salt contains a randomly generated value used in computing the key
+      of the MAC process.  The salt SHOULD be at least 8 octets (64
+      bits) long.
+
+      owf identifies the algorithm and associated parameters used to
+      compute the key used in the MAC process.  All implementations MUST
+      support SHA-1.
+
+      iterationCount identifies the number of times the hash is applied
+      during the key computation process.  The iterationCount MUST be a
+      minimum of 100.  Many people suggest using values as high as 1000
+      iterations as the minimum value.  The trade off here is between
+      protection of the password from attacks and the time spent by the
+      server processing all of the different iterations in deriving
+      passwords.  Hashing is generally considered a cheap operation but
+      this may not be true with all hash functions in the future.
+
+      mac identifies the algorithm and associated parameters of the MAC
+      function to be used.  All implementations MUST support HMAC-SHA1
+      [HMAC].  All implementations SHOULD support DES-MAC and Triple-
+      DES-MAC [PKCS11].
+
+   The following is pseudo-code for the algorithm:
+
+   Inputs:
+          pw   - an octet string containing the user's password
+          data - an octet string containing the value to be MAC-ed
+          Iter - iteration count
+
+   Output:
+          MAC  - an octet string containing the resultant MAC value
+
+   1.  Generate a random salt value S
+
+   2.  Append the salt to the pw.  K = pw || salt.
+
+   3.  Hash the value of K.  K = HASH(K)
+
+   4.  If Iter is greater than zero.  Iter = Iter - 1.  Goto step 3.
+
+   5.  Compute an HMAC as documented in [HMAC].
+
+       MAC = HASH( K XOR opad, HASH( K XOR ipad, data) )
+
+       Where opad and ipad are defined in [HMAC].
+
+
+
+
+Schaad                      Standards Track                    [Page 15]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+5.  CertRequest syntax
+
+   The CertRequest syntax consists of a request identifier, a template
+   of certificate content, and an optional sequence of control
+   information.
+
+   CertRequest ::= SEQUENCE {
+      certReqId     INTEGER,        -- ID for matching request and reply
+      certTemplate  CertTemplate, --Selected fields of cert to be issued
+      controls      Controls OPTIONAL } -- Attributes affecting issuance
+
+   CertTemplate ::= SEQUENCE {
+      version      [0] Version               OPTIONAL,
+      serialNumber [1] INTEGER               OPTIONAL,
+      signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
+      issuer       [3] Name                  OPTIONAL,
+      validity     [4] OptionalValidity      OPTIONAL,
+      subject      [5] Name                  OPTIONAL,
+      publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
+      issuerUID    [7] UniqueIdentifier      OPTIONAL,
+      subjectUID   [8] UniqueIdentifier      OPTIONAL,
+      extensions   [9] Extensions            OPTIONAL }
+
+   OptionalValidity ::= SEQUENCE {
+      notBefore  [0] Time OPTIONAL,
+      notAfter   [1] Time OPTIONAL } --at least one must be present
+
+   Time ::= CHOICE {
+      utcTime        UTCTime,
+      generalTime    GeneralizedTime }
+
+   The fields of CertRequest have the following meaning:
+
+      certReqId contains an integer value that is used by the
+      certificate requestor to associate a specific certificate request
+      with a certificate response.
+
+      certTemplate contains a template of an X.509 certificate.  The
+      requestor fills in those fields for which specific values are
+      desired.  Details on the fields are given below.
+
+      controls contains attributes that are not part of the certificate,
+      but control the context in which the certificate is to be issued.
+      Details on the controls defined in this document can be found in
+      section 6.  Other documents may define other controls.  CRPs are
+      responsible for specifying which controls are required.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 16]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of CertTemplate have the following meaning:
+
+      version MUST be 2 if supplied.  It SHOULD be omitted.
+
+      serialNumber MUST be omitted.  This field is assigned by the CA
+      during certificate creation.
+
+      signingAlg MUST be omitted.  This field is assigned by the CA
+      during certificate creation.
+
+      issuer is normally omitted.  It would be filled in with the CA
+      that the requestor desires to issue the certificate in situations
+      where an RA is servicing more than one CA.
+
+      validity is normally omitted.  It can be used to request that
+      certificates either start at some point in the future or expire at
+      some specific time.  A case where this field would commonly be
+      used is when a cross certificate is issued for a CA.  In this case
+      the validity of an existing certificate would be placed in this
+      field so that the new certificate would have the same validity
+      period as the existing certificate.  If validity is not omitted,
+      then at least one of the sub-fields MUST be specified.  The sub-
+      fields are as follows:
+
+         notBefore contains the requested start time of the certificate.
+         The time follows the same rules as the notBefore time in
+         [PROFILE].
+
+         notAfter contains the requested expiration time of the
+         certificate.  The time follows the same rules as the notAfter
+         time in [PROFILE].
+
+      subject is filled in with the suggested name for the requestor.
+      This would normally be filled in by a name that has been
+      previously issued to the requestor by the CA.
+
+      publicKey contains the public key for which the certificate is
+      being created.  This field MUST be filled in if the requestor
+      generates its own key.  The field is omitted if the key is
+      generated by the RA/CA.
+
+      issuerUID MUST be omitted.  This field has been deprecated in
+      [PROFILE].
+
+      subjectUID MUST be omitted.  This field has been deprecated in
+      [PROFILE].
+
+
+
+
+
+Schaad                      Standards Track                    [Page 17]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      extensions contains extensions that the requestor wants to have
+      placed in the certificate.  These extensions would generally deal
+      with things such as setting the key usage to keyEncipherment.
+
+   With the exception of the publicKey field, the CA/RA is permitted to
+   alter any requested field.  The returned certificate needs to be
+   checked by the requestor to see if the fields have been set in an
+   acceptable manner.  CA/RA SHOULD use the template fields if possible.
+
+   There are cases where all fields of the template can be omitted.  If
+   the key generation is being done at the CA/RA and the identity proof
+   is placed in a different location (such as the id-regCtrl-regToken
+   below), then there are no fields that need to be specified by the
+   certificate requestor.
+
+6.  Controls Syntax
+
+   The generator of a CertRequest may include one or more control values
+   pertaining to the processing of the request.
+
+   Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
+
+   The following controls are defined by this document:  regToken
+   (section 6.1); authenticator (section 6.2); pkiPublicationInfo
+   (section 6.3); pkiArchiveOptions (section 6.4); oldCertID (section
+   6.5); protocolEncrKey (section 6.6).  Each CRP MUST define the set of
+   controls supported by that protocol.  Additional controls may be
+   defined by additional RFCs or by the CRP protocol itself.
+
+6.1.  Registration Token Control
+
+   A regToken control contains one-time information (either based on a
+   secret value or other shared information) intended to be used by the
+   CA to verify the identity of the subject prior to issuing a
+   certificate.  Upon receipt of a certification request containing a
+   value for regToken, the receiving CA verifies the information in
+   order to confirm the identity claimed in the certification request.
+
+   The value for regToken may be generated by the CA and provided out of
+   band to the subscriber, or may otherwise be available to both the CA
+   and the subscriber.  The security of any out-of-band exchange should
+   be commensurate with the risk that the CA will tolerate with regard
+   to accepting an intercepted value from someone other than the
+   intended subscriber.  The regToken value is not encrypted on return,
+   if the data is considered to be sensitive, it needs to be shrouded by
+   the requestor.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 18]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The regToken control is used only for initialization of an end entity
+   into the PKI, whereas the authenticator control (see section 7.2) can
+   be used for the initial as well as subsequent certification requests.
+
+   In some instances of use the value for regToken could be a text
+   string or a numeric quantity such as a random number.  In the latter
+   case, the value is encoded as a text string representation of the
+   binary quantity.  The encoding of regToken SHALL be UTF8String.
+
+   id-regCtrl-regToken            OBJECT IDENTIFIER ::= { id-regCtrl 1 }
+
+   Without prior agreement between the subscriber and CA agents, this
+   value would be a textual shared secret of some type.  If a computed
+   value based on that shared secret is to be used instead, it is
+   suggested that the CRP define a new registration control for that
+   specific computation.
+
+6.2.  Authenticator Control
+
+   An authenticator control contains information used on an ongoing
+   basis to establish a non-cryptographic check of identity in
+   communication with the CA.  Examples include:  mother's maiden name,
+   last four digits of social security number, or other knowledge-based
+   information shared with the subscriber's CA; a hash of such
+   information; or other information produced for this purpose.  The
+   value for an authenticator control may be generated by the subscriber
+   or by the CA.
+
+   In some instances of use, the value for authenticator could be a text
+   string or a numeric quantity such as a random number.  The value in
+   the latter case is encoded as a text string representation of the
+   binary quantity.  The encoding of authenticator SHALL be UTF8String.
+
+   id-regCtrl-authenticator       OBJECT IDENTIFIER ::= { id-regCtrl 2 }
+
+   When deciding whether to use an authenticator or a regToken, use the
+   following guidelines.  If the value is a one-time usage value, then
+   regToken would be used.  If the value has a long-term usage, then the
+   authenticator control would be used.
+
+6.3.  Publication Information Control
+
+   The pkiPublicationInfo control enables subscribers to influence the
+   CA/RA's publication of the certificate.  This control is considered
+   advisory and can be ignored by CAs/RAs.  It is defined by the
+   following OID and syntax:
+
+
+
+
+
+Schaad                      Standards Track                    [Page 19]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   id-regCtrl-pkiPublicationInfo  OBJECT IDENTIFIER ::= { id-regCtrl 3 }
+
+   PKIPublicationInfo ::= SEQUENCE {
+        action     INTEGER {
+                     dontPublish (0),
+                     pleasePublish (1) },
+        pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
+
+   SinglePubInfo ::= SEQUENCE {
+         pubMethod    INTEGER {
+             dontCare    (0),
+             x500        (1),
+             web         (2),
+             ldap        (3) },
+         pubLocation  GeneralName OPTIONAL }
+
+   The fields of PKIPublicationInfo have the following meaning:
+
+      action indicates whether or not the requestor wishes the CA/RA to
+      publish the certificate.  The values and their means are:
+
+         dontPublish indicates that the requester wishes the CA/RA not
+         to publish the certificate (this may indicate that the
+         requester intends to publish the certificate him/herself).  If
+         dontPublish is used, the pubInfos field MUST be omitted.
+
+         pleasePublish indicates that the requestor wishes the CA/RA to
+         publish the certificate.
+
+      pubInfos holds the locations where the requestor desires the CA/RA
+      to publish the certificate.  This field is omitted if the
+      dontPublish choice is selected.  If the requestor wants to specify
+      some locations for the certificate to be published, and to allow
+      the CA/RA to publish in other locations, it would specify multiple
+      values of the SinglePubInfo structure, one of which would be
+      dontCare.
+
+   The fields of SinglePubInfo have the following meaning:
+
+      pubMethod indicates the address type for the location at which the
+      requestor desires the certificate to be placed by the CA/RA.
+
+         dontCare indicates that the CA/RA can publish the certificate
+         in whatever locations it chooses.  If dontCare is used, the
+         pubInfos field MUST be omitted.
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 20]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+         x500 indicates that the requestor wishes for the CA/RA to
+         publish the certificate in a specific location.  The location
+         is indicated in the x500 field of pubLocation.
+
+         ldap indicates that the requestor wishes for the CA/RA to
+         publish the certificate in a specific location.  The location
+         is indicated in the ldap field of pubLocation.
+
+         web indicates that the requestor wishes for the CA/RA to
+         publish the certificate in a specific location.  The location
+         is indicated in the http field of pubLocation.
+
+      pubLocation contains the address at which the certificate is to be
+      placed.  The choice in the general name field is dictated by the
+      pubMethod selection in this structure.
+
+   Publication locations can be supplied in any order.  All locations
+   are to be processed by the CA for purposes of publication.
+
+6.4.  Archive Options Control
+
+   The pkiArchiveOptions control enables subscribers to supply
+   information needed to establish an archive of the private key
+   corresponding to the public key of the certification request.  It is
+   defined by the following OID and syntax:
+
+   id-regCtrl-pkiArchiveOptions   OBJECT IDENTIFIER ::= { id-regCtrl 4 }
+
+   PKIArchiveOptions ::= CHOICE {
+      encryptedPrivKey     [0] EncryptedKey,
+      -- the actual value of the private key
+      keyGenParameters     [1] KeyGenParameters,
+      -- parameters which allow the private key to be re-generated
+      archiveRemGenPrivKey [2] BOOLEAN }
+      -- set to TRUE if sender wishes receiver to archive the private
+      -- key of a key pair that the receiver generates in response to
+      -- this request; set to FALSE if no archival is desired.
+
+   EncryptedKey ::= CHOICE {
+      encryptedValue        EncryptedValue, -- deprecated
+      envelopedData     [0] EnvelopedData }
+      -- The encrypted private key MUST be placed in the envelopedData
+      -- encryptedContentInfo encryptedContent OCTET STRING.
+
+   EncryptedValue ::= SEQUENCE {
+      intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
+      -- the intended algorithm for which the value will be used
+      symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
+
+
+
+Schaad                      Standards Track                    [Page 21]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      -- the symmetric algorithm used to encrypt the value
+      encSymmKey    [2] BIT STRING           OPTIONAL,
+      -- the (encrypted) symmetric key used to encrypt the value
+      keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
+      -- algorithm used to encrypt the symmetric key
+      valueHint     [4] OCTET STRING         OPTIONAL,
+      -- a brief description or identifier of the encValue content
+      -- (may be meaningful only to the sending entity, and used only
+      -- if EncryptedValue might be re-examined by the sending entity
+      -- in the future)
+      encValue       BIT STRING }
+   -- The use of the EncryptedValue field has been deprecated in favor
+   -- of the EnvelopedData structure.
+   --
+   -- When EncryptedValue is used to carry a private key (as opposed to
+   -- a certificate), implementations MUST support the encValue field
+   -- containing an encrypted PrivateKeyInfo as defined in [PKCS11],
+   -- section 12.11.  If encValue contains some other format/encoding
+   -- for the private key, the first octet of valueHint MAY be used
+   -- to indicate the format/encoding (but note that the possible values
+   -- of this octet are not specified at this time).  In all cases, the
+   -- intendedAlg field MUST be used to indicate at least the OID of
+   -- the intended algorithm of the private key, unless this information
+   -- is known a priori to both sender and receiver by some other means.
+
+   KeyGenParameters ::= OCTET STRING
+
+   The fields of PKIArchiveOptions have the following meaning:
+
+      encryptedPrivKey contains an encrypted version of the private key.
+
+      keyGenParameters contains the information needed by the requestor
+      to regenerate the private key.  As an example, for many RSA
+      implementations one could send the first random number(s) tested
+      for primality.  The structure to go here is not defined by this
+      document.  CRPs that define content for this structure MUST define
+      not only the content that is to go here, but also how that data is
+      shrouded from unauthorized access.
+
+      archiveRemGenPrivKey indicates that the requestor desires that the
+      key generated by the CA/RA on the requestor's behalf be archived.
+
+   The fields of EncryptedKey have the following meaning:
+
+      encryptedValue is longer used.  This field has been deprecated
+      along with the EncryptedValue structure.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 22]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      envelopedData contains the encrypted value of the private key.
+      CPRs that use this structure MUST define the entity or entities
+      for whom the data is to be encrypted (the EE, escrow agents, CAs)
+      and how that key or set of keys is to be determined.  Details on
+      constructing an EnvelopedData structure are found in [CMS].  The
+      encrypted content MUST be an id-ct-encKeyWithID.  The identifier
+      can be omitted unless this structure is also being used to do
+      proof-of-possession.
+
+6.5.  OldCert ID Control
+
+   If present, the OldCertID control specifies the certificate to be
+   updated by the current certification request.  The OID and syntax is:
+
+   id-regCtrl-oldCertID           OBJECT IDENTIFIER ::= { id-regCtrl 5 }
+
+   CertId ::= SEQUENCE {
+         issuer           GeneralName,
+         serialNumber     INTEGER
+     }
+
+6.6.  Protocol Encryption Key Control
+
+   If present, the protocolEncrKey control specifies a key that the CA
+   is to use in encrypting a response to CertReqMessages.  The OID for
+   this control is id-regCtrl-protocolEncrKey.  The parameter structure
+   for this field is SubjectPublicKeyInfo.  (This structure is defined
+   in [PROFILE].)
+
+   id-regCtrl-protocolEncrKey     OBJECT IDENTIFIER ::= { id-regCtrl 6 }
+
+   This control is used when a CA has information to send to the
+   subscriber that needs to be encrypted.  Such information includes a
+   private key generated by the CA for use by the subscriber.
+
+7.  RegInfo Controls
+
+   This section documents the controls that are to be placed in the
+   regInfo field of the CertReqMsg structure.
+
+7.1.  utf8Pairs
+
+   This control is used to convey text-based information from the
+   Subject to an RA to a CA issuing a certificate.  The OID for this
+   structure is id-regInfo-utf8Paris and has a type of UTF8String.
+
+      id-regInfo-utf8Pairs    OBJECT IDENTIFIER ::= { id-regInfo 1 }
+
+
+
+
+Schaad                      Standards Track                    [Page 23]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The name is terminated by the question mark character ('?').  The
+   value is terminated by the percent character '%'.  Name value pairs
+   can be repeated.  Thus the syntax is:
+
+      Name?Value%[Name?Value%]*
+
+   The %xx mechanism of [RFC1738] is used to encode '?' (%3f) and '%'
+   (%25) if they are not being used for their reserved purpose.  Names
+   MUST NOT start with a numeric character.
+
+   This control can appear multiple times in the regInfo structure.
+   Resolution of conflicts of information is a matter of local policy on
+   the RA/CA.
+
+   Appendix A contains a set of common names and data formats
+   corresponding to fields that commonly appear in certificates and
+   directories.
+
+7.2.  certReq
+
+   This control is designed to deal with the problem where an RA needs
+   to modify the certificate template proposed by a Subject, but the
+   Subject used the certificate template as part of its POP calculation.
+   In this case, the RA can place a new certificate template in the
+   regInfo sequence.
+
+   This control has the OID id-regInfo-certReq and the structure
+   CertRequest.  There can only be one instance of this attribute in the
+   regInfo sequence.  If this control exists in the regInfo structure,
+   then the certificate template in the request is ignored.  The RA MUST
+   copy all data from the core template to this attribute.
+
+      id-regInfo-certReq       OBJECT IDENTIFIER ::= { id-regInfo 2 }
+
+8.  Object Identifiers
+
+   The OID id-pkix has the value
+
+   id-pkix  OBJECT IDENTIFIER  ::= { iso(1) identified-organization(3)
+   dod(6) internet(1) security(5) mechanisms(5) pkix(7) }
+
+   -- arc for Internet X.509 PKI protocols and their components
+   id-pkip  OBJECT IDENTIFIER :: { id-pkix pkip(5) }
+
+   -- arc for Registration Controls in CRMF
+   id-regCtrl  OBJECT IDENTIFIER ::= { id-pkip regCtrl(1) }
+
+
+
+
+
+Schaad                      Standards Track                    [Page 24]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   -- arc for Registration Info in CRMF
+   id-regInfo       OBJECT IDENTIFIER ::= { id-pkip id-regInfo(2) }
+
+9.  Security Considerations
+
+   Enrollment protocols, by their very nature, involve large amounts of
+   private information.  This can include private keys, identity
+   numbers, credit card numbers, and the like.  The security of any CRP
+   is based on the security mechanisms of the protocol and/or process
+   used to communicate between CAs, RAs and EEs.  All protocols must
+   provide for masking, either via encryption or off-line processing, of
+   all subscriber-sensitive information.
+
+   Many enrollment protocols provide for the initial establishment of
+   identity between the CA/RA and the EE by the use of a token.
+   Generally this token is delivered using an out-of-band delivery
+   method (such as the governmental mail system).  The security of any
+   out-of-band exchange needs to be commensurate with the risk that the
+   CA/RA will tolerate with regard to interception of the token by a
+   third party.
+
+   Implementation must implement Proof-of-Possession (POP) values during
+   certificate enrollment processes.  A good POP algorithm needs to
+   provide proof of two things: 1) that the key is tied to a specific
+   user and 2) that the user has use of the key in question.  Failure to
+   implement POP allows people to create certificates where the public
+   key and the name values do not correctly bind.  This allows for
+   impersonation on signature keys and interception of encrypted
+   messages.
+
+   Implementations must use high entropy random number generators in
+   producing private keys.  Implementations must randomly generate
+   content-encryption keys, message-authentication keys, initialization
+   vectors (IVs), salt, and padding.  The use of inadequate pseudo-
+   random number generators (PRNGs) to generate cryptographic keys can
+   result in little or no security.  An attacker may find it much easier
+   to reproduce the PRNG environment that produced the keys, searching
+   the resulting small set of possibilities, rather than brute force
+   searching the whole key space.  The generation of quality random
+   numbers is difficult.  RFC 4086 [RANDOM] offers important guidance in
+   this area and Appendix 3 of FIPS Pub 186 [DSS] provides one quality
+   PRNG technique.
+
+   Implementations must protect private keys.  The compromise of a
+   signer's private key permits third parties to masquerade as the
+   signer.  The compromise of a decryption private key allows for
+   interception of messages by a third party.
+
+
+
+
+Schaad                      Standards Track                    [Page 25]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   One feature of the certificate message request syntax is for the key
+   generation to be performed remotely from the creation of the
+   certificate request.  This feature should never be used for
+   generation of signing keys.  If signing keys are generated for the
+   user, then an element of repudiation comes into play.  The user can
+   claim that an item was signed by the entity that generated the key as
+   well as any entity that might have seen the key value during transfer
+   from the generator the to EE.  Care must be taken to protect
+   encryption keys by the remote key generator to protect against
+   interception of the keys by a third party.  This means that the
+   encryption algorithms used need to be secure, and a content
+   encryption key or a key encryption key must be used to mask the
+   private key during transport back to the user.  CRP protocols must
+   never assume that a signature key generated by the user can be used
+   to decrypt the package in which an encryption private key is
+   transported.
+
+   This document describes a method by which key escrow may be done.
+   There are several issues that need to be taken into account when
+   doing key escrow.  First, the client must be able to correctly
+   identify the entity to which a key is to be escrowed or the CRP must
+   provide a method by which the client can discover this information.
+   A CRP cannot assume that the key escrow agent and the CA are the same
+   entity and thus have the same names.  Second, the algorithms used to
+   mask the private key or other key generation information during
+   transport to the escrow agent need to be commensurate with the value
+   of the data being protected by the key.  Third, the escrow agent
+   needs to provide sufficient safeguards that an escrowed key is
+   returned only to entities that should be able to obtain the private
+   key.  Generally, this should be restricted to the entity that
+   escrowed the data.  Fourth, the escrow data base needs to be stored
+   in a secure manner.  One common method for doing this is to re-
+   encrypt the data to keys that only the escrow agent has access to.
+   In this case, one may need to escrow the escrow agent key as well.
+   Access to either the escrow agent or the archived key would amount to
+   access to all private keys that have been escrowed with that agent.
+
+10.  References
+
+10.1.  Normative References
+
+   [PKCS1]   Jonsson, J. and B. Kaliski, "Public-Key Cryptography
+             Standards (PKCS) #1: RSA Cryptography Specifications
+             Version 2.1", RFC 3447, February 2003.
+
+   [HMAC]    Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
+             Keyed-Hashing for Message Authentication", RFC 2104,
+             February 1997.
+
+
+
+Schaad                      Standards Track                    [Page 26]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   [PKCS11]  RSA Laboratories, The Public-Key Cryptography Standards -
+             "PKCS #11 v2.11:  Cryptographic Token Interface Standard",
+             RSA Security Inc., June 2001.
+
+   [RFC2119] Bradner, S., "Key words for use in RFCs to Indicate
+             Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [PROFILE] Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
+             X.509 Public Key Infrastructure Certificate and Certificate
+             Revocation List (CRL) Profile", RFC 3280, April 2002.
+
+   [PKIXALG] Bassham, L., Polk, W., and R. Housley, "Algorithms and
+             Identifiers for the Internet X.509 Public Key
+             Infrastructure Certificate and Certificate Revocation List
+             (CRL) Profile", RFC 3279, April 2002.
+
+   [CMS]     Housley, R., "Cryptographic Message Syntax (CMS)", RFC
+             3852, July 2004.
+
+   [RFC2875] Prafullchandra, H. and J. Schaad, "Diffie-Hellman
+             Proof-of-Possession Algorithms", RFC 2875, July 2000.
+
+10.2.  Informative References
+
+   [DSS]     National Institute of Standards and Technology, FIPS Pub
+             186: Digital Signature Standard, May 1994.
+
+   [PKCS8]   RSA Laboratories, "PKCS #8: Private-Key Information Syntax
+             Standard", PKCS #8 v1.2, November 1993.
+
+   [RANDOM]  Eastlake, D., 3rd, Schiller, J., and S. Crocker,
+             "Randomness Requirements for Security", BCP 106, RFC 4086,
+             June 2005.
+
+   [RFC2202] Cheng, P. and R. Glenn, "Test Cases for HMAC-MD5 and
+             HMAC-SHA-1", RFC 2202, September 1997.
+
+   [RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
+             Resource Locators (URL)", RFC 1738, December 1994.
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 27]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+11.  Acknowledgements
+
+   The working group would like to thank Michael Myers, Carlisle Adams,
+   Dave Solo, and David Kemp, who authored the original version of this
+   document.
+
+   The working group also gratefully acknowledges the contributions of
+   Barbara Fox, Warwick Ford, Russ Housley, and John Pawling, whose
+   review and comments significantly clarified and improved the utility
+   of this specification.  The members of the ca-talk mailing list also
+   provided significant input with respect to interoperability testing.
+
+   The text of Appendix C (Why do POP) was taken from an e-mail message
+   by Al Arsenault and was originally part of the PKIX Roadmap document.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 28]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Appendix A.  Use of RegInfo for Name-Value Pairs
+
+   The "value" field of the id-regInfo-utf8Pairs string (with "tag"
+   field equal to 12 and appropriate "length" field) will contain a
+   series of UTF-8 name/value pairs.
+
+   This Appendix lists some common examples of such pairs for the
+   purpose of promoting interoperability among independent
+   implementations of this specification.  It is recognized that this
+   list is not exhaustive and will grow with time and implementation
+   experience.
+
+A.1.  Defined Names
+
+   The following table defines a recommended set of named elements.  The
+   value in the column "Name Value" is the exact text string that will
+   appear in the regInfo.
+
+      Name Value
+      ----------
+      version            -- version of this variation of regInfo use
+      corp_company       -- company affiliation of subscriber
+      org_unit           -- organizational unit
+      mail_firstName     -- personal name component
+      mail_middleName    -- personal name component
+      mail_lastName      -- personal name component
+      mail_email         -- subscriber's email address
+      jobTitle           -- job title of subscriber
+      employeeID         -- employee identification number or string
+      mailStop           -- mail stop
+      issuerName         -- name of CA
+      subjectName        -- name of Subject
+      validity           -- validity interval
+
+   For example:
+
+      version?1%corp_company?Example, Inc.%org_unit?Engineering%
+      mail_firstName?John%mail_lastName?Smith%jobTitle?Team Leader%
+      mail_email?john@example.com%
+
+A.2.  IssuerName, SubjectName, and Validity Value Encoding
+
+   When they appear in id-regInfo-utf8Pairs syntax as named elements,
+   the encoding of values for issuerName, subjectName, and validity
+   SHALL use the following syntax.  The characters [] indicate an
+   optional field, ::= and | have their usual BNF meanings, and all
+   other symbols (except spaces, which are insignificant) outside non-
+   terminal names are terminals.  Alphabetics are case-sensitive.
+
+
+
+Schaad                      Standards Track                    [Page 29]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      issuerName  ::= <names>
+      subjectName ::= <names>
+      <names>     ::= <name> | <names>:<name>
+
+      <validity>  ::= validity ? [<notbefore>]-[<notafter>]
+
+      <notbefore> ::= <time>
+      <notafter>  ::= <time>
+
+   Where <time> is UTC time in the form YYYYMMDD[HH[MM[SS]]].  HH, MM,
+   and SS default to 00 and are omitted if at the and of value 00.
+
+   Example validity encoding:
+
+      validity?-19991231%
+
+   is a validity interval with no value for notBefore, and a value of
+   December 31, 1999 for notAfter.
+
+   Each name comprises a single character name form identifier, followed
+   by a name value of one or more UTF-8 characters.  Within a name
+   value, when it is necessary to disambiguate a character that has
+   formatting significance at an outer level, the escape sequence %xx
+   SHALL be used, where xx represents the hex value for the encoding
+   concerned.  The percent symbol is represented by %%.
+
+      <name> ::= X<xname>|O<oname>|E<ename>|D<dname>|U<uname>|I<iname>
+
+   Name forms and value formats are as follows:
+
+   X.500 directory name form (identifier "X"):
+
+      <xname> ::= <rdns>
+      <rdns>  ::= <rdn> | <rdns> , <rdn>
+      <rdn>   ::= <avas>
+      <avas>  ::= <ava> | <avas> + <ava>
+      <ava>   ::= <attyp> = <avalue>
+      <attyp> ::= OID.<oid> | <stdat>
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 30]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   Standard attribute type <stdat> is an alphabetic attribute type
+   identifier from the following set:
+
+      C      (country)
+      L      (locality)
+      ST     (state or province)
+      O      (organization)
+      OU     (organizational unit)
+      CN     (common name)
+      STREET (street address)
+      E      (E-mail address).
+
+   <avalue> is a name component in the form of a UTF-8 character string
+   of 1 to 64 characters, with the restriction that in the IA5 subset of
+   UTF-8 only the characters of ASN.1 PrintableString may be used.
+
+   Other name form (identifier "O"):
+      <oname> ::= <oid> , <utf8string>
+
+   E-mail address (rfc822name) name form (identifier "E"):
+      <ename> ::= <ia5string>
+
+   DNS name form (identifier "D"):
+      <dname> ::= <ia5string>
+
+   URI name form (identifier "U"):
+      <uname> ::= <ia5string>
+
+   IP address (identifier "I"):
+      <iname> ::= <oid>
+
+   For example:
+
+      issuerName?XOU=Our CA,O=Example,C=US% subjectName?XCN=John Smith,
+      O=Example, C=US, E=john@example.com%
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 31]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Appendix B.  ASN.1 Structures and OIDs
+
+PKIXCRMF-2005 {iso(1) identified-organization(3) dod(6) internet(1)
+security(5) mechanisms(5) pkix(7) id-mod(0) id-mod-crmf2005(36)}
+
+DEFINITIONS IMPLICIT TAGS ::=
+BEGIN
+
+IMPORTS
+  -- Directory Authentication Framework (X.509)
+     Version, AlgorithmIdentifier, Name, Time,
+     SubjectPublicKeyInfo, Extensions, UniqueIdentifier, Attribute
+        FROM PKIX1Explicit88 {iso(1) identified-organization(3) dod(6)
+            internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
+            id-pkix1-explicit(18)} -- found in [PROFILE]
+
+  -- Certificate Extensions (X.509)
+     GeneralName
+        FROM PKIX1Implicit88 {iso(1) identified-organization(3) dod(6)
+               internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
+               id-pkix1-implicit(19)}  -- found in [PROFILE]
+
+  -- Cryptographic Message Syntax
+     EnvelopedData
+        FROM CryptographicMessageSyntax2004 { iso(1) member-body(2)
+             us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)
+             modules(0) cms-2004(24) };  -- found in [CMS]
+
+-- The following definition may be uncommented for use with
+-- ASN.1 compilers that do not understand UTF8String.
+
+-- UTF8String ::= [UNIVERSAL 12] IMPLICIT OCTET STRING
+       -- The contents of this type correspond to RFC 2279.
+
+id-pkix  OBJECT IDENTIFIER  ::= { iso(1) identified-organization(3)
+dod(6) internet(1) security(5) mechanisms(5) 7 }
+
+-- arc for Internet X.509 PKI protocols and their components
+
+id-pkip  OBJECT IDENTIFIER ::= { id-pkix 5 }
+
+id-smime OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+             us(840) rsadsi(113549) pkcs(1) pkcs9(9) 16 }
+
+id-ct   OBJECT IDENTIFIER ::= { id-smime  1 }  -- content types
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 32]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+-- Core definitions for this module
+
+CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
+
+CertReqMsg ::= SEQUENCE {
+ certReq   CertRequest,
+ popo       ProofOfPossession  OPTIONAL,
+ -- content depends upon key type
+ regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
+
+CertRequest ::= SEQUENCE {
+ certReqId     INTEGER,          -- ID for matching request and reply
+ certTemplate  CertTemplate,  -- Selected fields of cert to be issued
+ controls      Controls OPTIONAL }   -- Attributes affecting issuance
+
+CertTemplate ::= SEQUENCE {
+ version      [0] Version               OPTIONAL,
+ serialNumber [1] INTEGER               OPTIONAL,
+ signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
+ issuer       [3] Name                  OPTIONAL,
+ validity     [4] OptionalValidity      OPTIONAL,
+ subject      [5] Name                  OPTIONAL,
+ publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
+ issuerUID    [7] UniqueIdentifier      OPTIONAL,
+ subjectUID   [8] UniqueIdentifier      OPTIONAL,
+ extensions   [9] Extensions            OPTIONAL }
+
+OptionalValidity ::= SEQUENCE {
+ notBefore  [0] Time OPTIONAL,
+ notAfter   [1] Time OPTIONAL } -- at least one MUST be present
+
+Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
+AttributeTypeAndValue ::= SEQUENCE {
+ type         OBJECT IDENTIFIER,
+ value        ANY DEFINED BY type }
+
+ProofOfPossession ::= CHOICE {
+ raVerified        [0] NULL,
+ -- used if the RA has already verified that the requester is in
+ -- possession of the private key
+ signature         [1] POPOSigningKey,
+ keyEncipherment   [2] POPOPrivKey,
+ keyAgreement      [3] POPOPrivKey }
+
+POPOSigningKey ::= SEQUENCE {
+ poposkInput           [0] POPOSigningKeyInput OPTIONAL,
+ algorithmIdentifier   AlgorithmIdentifier,
+ signature             BIT STRING }
+
+
+
+Schaad                      Standards Track                    [Page 33]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+ -- The signature (using "algorithmIdentifier") is on the
+ -- DER-encoded value of poposkInput.  NOTE: If the CertReqMsg
+ -- certReq CertTemplate contains the subject and publicKey values,
+ -- then poposkInput MUST be omitted and the signature MUST be
+ -- computed over the DER-encoded value of CertReqMsg certReq.  If
+ -- the CertReqMsg certReq CertTemplate does not contain both the
+ -- public key and subject values (i.e., if it contains only one
+ -- of these, or neither), then poposkInput MUST be present and
+ -- MUST be signed.
+
+
+POPOSigningKeyInput ::= SEQUENCE {
+ authInfo            CHOICE {
+     sender              [0] GeneralName,
+     -- used only if an authenticated identity has been
+     -- established for the sender (e.g., a DN from a
+     -- previously-issued and currently-valid certificate)
+     publicKeyMAC        PKMACValue },
+     -- used if no authenticated GeneralName currently exists for
+     -- the sender; publicKeyMAC contains a password-based MAC
+     -- on the DER-encoded value of publicKey
+ publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
+
+PKMACValue ::= SEQUENCE {
+algId  AlgorithmIdentifier,
+-- algorithm value shall be PasswordBasedMac {1 2 840 113533 7 66 13}
+-- parameter value is PBMParameter
+value  BIT STRING }
+
+PBMParameter ::= SEQUENCE {
+   salt                OCTET STRING,
+   owf                 AlgorithmIdentifier,
+   -- AlgId for a One-Way Function (SHA-1 recommended)
+   iterationCount      INTEGER,
+   -- number of times the OWF is applied
+   mac                 AlgorithmIdentifier
+   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+}   -- or HMAC [HMAC, RFC2202])
+
+POPOPrivKey ::= CHOICE {
+ thisMessage       [0] BIT STRING,         -- Deprecated
+ -- possession is proven in this message (which contains the private
+ -- key itself (encrypted for the CA))
+ subsequentMessage [1] SubsequentMessage,
+ -- possession will be proven in a subsequent message
+ dhMAC             [2] BIT STRING,         -- Deprecated
+ agreeMAC          [3] PKMACValue,
+ encryptedKey      [4] EnvelopedData }
+
+
+
+Schaad                      Standards Track                    [Page 34]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+ -- for keyAgreement (only), possession is proven in this message
+ -- (which contains a MAC (over the DER-encoded value of the
+ -- certReq parameter in CertReqMsg, which MUST include both subject
+ -- and publicKey) based on a key derived from the end entity's
+ -- private DH key and the CA's public DH key);
+
+SubsequentMessage ::= INTEGER {
+ encrCert (0),
+ -- requests that resulting certificate be encrypted for the
+ -- end entity (following which, POP will be proven in a
+ -- confirmation message)
+ challengeResp (1) }
+ -- requests that CA engage in challenge-response exchange with
+ -- end entity in order to prove private key possession
+
+-- Object identifier assignments --
+
+-- Registration Controls in CRMF
+id-regCtrl OBJECT IDENTIFIER ::= { id-pkip 1 }
+
+
+id-regCtrl-regToken OBJECT IDENTIFIER ::= { id-regCtrl 1 }
+--with syntax:
+RegToken ::= UTF8String
+
+id-regCtrl-authenticator OBJECT IDENTIFIER ::= { id-regCtrl 2 }
+--with syntax:
+Authenticator ::= UTF8String
+
+id-regCtrl-pkiPublicationInfo OBJECT IDENTIFIER ::= { id-regCtrl 3 }
+--with syntax:
+
+PKIPublicationInfo ::= SEQUENCE {
+action     INTEGER {
+             dontPublish (0),
+             pleasePublish (1) },
+pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
+  -- pubInfos MUST NOT be present if action is "dontPublish"
+  -- (if action is "pleasePublish" and pubInfos is omitted,
+  -- "dontCare" is assumed)
+
+SinglePubInfo ::= SEQUENCE {
+ pubMethod    INTEGER {
+     dontCare    (0),
+     x500        (1),
+     web         (2),
+     ldap        (3) },
+ pubLocation  GeneralName OPTIONAL }
+
+
+
+Schaad                      Standards Track                    [Page 35]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+
+id-regCtrl-pkiArchiveOptions     OBJECT IDENTIFIER ::= { id-regCtrl 4 }
+--with syntax:
+PKIArchiveOptions ::= CHOICE {
+ encryptedPrivKey     [0] EncryptedKey,
+ -- the actual value of the private key
+ keyGenParameters     [1] KeyGenParameters,
+ -- parameters that allow the private key to be re-generated
+ archiveRemGenPrivKey [2] BOOLEAN }
+ -- set to TRUE if sender wishes receiver to archive the private
+ -- key of a key pair that the receiver generates in response to
+ -- this request; set to FALSE if no archival is desired.
+
+EncryptedKey ::= CHOICE {
+ encryptedValue        EncryptedValue,   -- Deprecated
+ envelopedData     [0] EnvelopedData }
+ -- The encrypted private key MUST be placed in the envelopedData
+ -- encryptedContentInfo encryptedContent OCTET STRING.
+
+EncryptedValue ::= SEQUENCE {
+ intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
+ -- the intended algorithm for which the value will be used
+ symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
+ -- the symmetric algorithm used to encrypt the value
+ encSymmKey    [2] BIT STRING           OPTIONAL,
+ -- the (encrypted) symmetric key used to encrypt the value
+ keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
+ -- algorithm used to encrypt the symmetric key
+ valueHint     [4] OCTET STRING         OPTIONAL,
+ -- a brief description or identifier of the encValue content
+ -- (may be meaningful only to the sending entity, and used only
+ -- if EncryptedValue might be re-examined by the sending entity
+ -- in the future)
+ encValue       BIT STRING }
+ -- the encrypted value itself
+-- When EncryptedValue is used to carry a private key (as opposed to
+-- a certificate), implementations MUST support the encValue field
+-- containing an encrypted PrivateKeyInfo as defined in [PKCS11],
+-- section 12.11.  If encValue contains some other format/encoding
+-- for the private key, the first octet of valueHint MAY be used
+-- to indicate the format/encoding (but note that the possible values
+-- of this octet are not specified at this time).  In all cases, the
+-- intendedAlg field MUST be used to indicate at least the OID of
+-- the intended algorithm of the private key, unless this information
+-- is known a priori to both sender and receiver by some other means.
+
+KeyGenParameters ::= OCTET STRING
+
+
+
+
+Schaad                      Standards Track                    [Page 36]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+id-regCtrl-oldCertID          OBJECT IDENTIFIER ::= { id-regCtrl 5 }
+--with syntax:
+OldCertId ::= CertId
+
+CertId ::= SEQUENCE {
+ issuer           GeneralName,
+ serialNumber     INTEGER }
+
+id-regCtrl-protocolEncrKey    OBJECT IDENTIFIER ::= { id-regCtrl 6 }
+--with syntax:
+ProtocolEncrKey ::= SubjectPublicKeyInfo
+
+-- Registration Info in CRMF
+id-regInfo OBJECT IDENTIFIER ::= { id-pkip 2 }
+
+id-regInfo-utf8Pairs    OBJECT IDENTIFIER ::= { id-regInfo 1 }
+--with syntax
+UTF8Pairs ::= UTF8String
+
+
+id-regInfo-certReq       OBJECT IDENTIFIER ::= { id-regInfo 2 }
+--with syntax
+CertReq ::= CertRequest
+
+-- id-ct-encKeyWithID is a new content type used for CMS objects.
+-- it contains both a private key and an identifier for key escrow
+-- agents to check against recovery requestors.
+
+id-ct-encKeyWithID OBJECT IDENTIFIER ::= {id-ct 21}
+
+EncKeyWithID ::= SEQUENCE {
+  privateKey           PrivateKeyInfo,
+  identifier CHOICE {
+    string             UTF8String,
+    generalName        GeneralName
+  } OPTIONAL
+}
+
+PrivateKeyInfo ::= SEQUENCE {
+   version                   INTEGER,
+   privateKeyAlgorithm       AlgorithmIdentifier,
+   privateKey                OCTET STRING,
+   attributes                [0] IMPLICIT Attributes OPTIONAL
+}
+
+Attributes ::= SET OF Attribute
+
+END
+
+
+
+Schaad                      Standards Track                    [Page 37]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Appendix C.  Why do Proof-of-Possession (POP)
+
+   Proof-of-Possession, or POP, means that the CA is adequately
+   convinced that the entity requesting a certificate for the public key
+   Y, has access to the corresponding private key X.
+
+   POP is important because it provides an appropriate level of
+   assurance of the correct operation of the PKI as a whole.  At its
+   lowest level, POP counters the "self-inflicted denial of service";
+   that is, an entity voluntarily gets a certificate that cannot be used
+   to sign or encrypt/decrypt information.  However, as the following
+   two examples demonstrate, POP also counters less direct, but more
+   severe, threats:
+
+      POP for signing keys: it is important to provide POP for keys used
+      to sign material, in order to provide non-repudiation of
+      transactions.  For example, suppose Alice legitimately has private
+      key X and its corresponding public key Y.  Alice has a certificate
+      from Charlie, a CA, containing Y.  Alice uses X to sign a
+      transaction T.  Without POP, Mal could also get a certificate from
+      Charlie containing the same public key, Y.  Now, there are two
+      possible threats: Mal could claim to have been the real signer of
+      T; or Alice can falsely deny signing T, claiming that it was
+      instead Mal.  Since no one can reliably prove that Mal did or did
+      not ever possess X, neither of these claims can be refuted, and
+      thus the service provided by and the confidence in the PKI has
+      been defeated.  (Of course, if Mal really did possess X, Alice's
+      private key, then no POP mechanism in the world will help, but
+      that is a different problem.)
+
+      Note that one level of protection can be gained by having Alice
+      (as the true signer of the transaction) include in the signed
+      information, her certificate or an identifier of her certificate
+      (e.g., a hash of her certificate).  This might make it more
+      difficult for Mal to claim authorship; he would have to assert
+      that he incorrectly included Alice's certificate, rather than his
+      own.  However, it would not stop Alice from falsely repudiating
+      her actions.  Since the certificate itself is a public item, Mal
+      indeed could have inserted Alice's certificate or identifier into
+      the signed transaction, and thus its presence does not indicate
+      that Alice was the one who participated in the now-repudiated
+      transaction.  The only reliable way to stop this attack is to
+      require that Mal prove he possesses X before his certificate is
+      issued.
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 38]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      For signing keys used only for authentication, and not for non-
+      repudiation, the threat is lower because users may not care about
+      Alice's after-the-fact repudiation, and thus POP becomes less
+      important.  However, POP SHOULD still be done wherever feasible in
+      this environment, by either off-line or on-line means.
+
+      POP for key management keys:  Similarly, POP for key management
+      keys (that is, keys used for either key agreement or key exchange)
+      can help to prevent undermining confidence in the PKI.  Suppose
+      that Al is a new instructor in the Computer Science Department of
+      a local university.  Al has created a draft final exam for the
+      Introduction to Networking course he is teaching.  He wants to
+      send a copy of the draft final to Dorothy, the Department Head,
+      for her review prior to giving the exam.  This exam will of course
+      be encrypted, as several students have access to the computer
+      system.  However, a quick search of the certificate repository
+      (e.g., search the repository for all records with
+      subjectPublicKey=Dorothy's-value) turns up the fact that several
+      students have certificates containing the same public key
+      management key as Dorothy.  At this point, if no POP has been done
+      by the CA, Al has no way of knowing whether all of the students
+      have simply created these certificates without knowing the
+      corresponding private key (and thus it is safe to send the
+      encrypted exam to Dorothy), or whether the students have somehow
+      acquired Dorothy's private key (and thus it is certainly not safe
+      to send the exam).  Thus, the service to be provided by the PKI
+      allowing users to communicate with one another, with confidence in
+      who they are communicating with, has been totally defeated.  If
+      the CA is providing POP, then either no students will have such
+      certificates, or Al can know with certainty that the students do
+      indeed know Dorothy's private key, and act accordingly.
+
+Author's Address
+
+   Jim Schaad
+   Soaring Hawk Consulting
+   PO Box 675
+   Gold Bar, WA 98251
+
+   EMail: jimsch@exmsft.com
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 39]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2005).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 40]
+
diff -Naur crypto/err/err.c crypto-/err/err.c
--- cryptoold/err/err.c	2017-04-20 16:15:38.523001201 +0700
+++ crypto/err/err.c	2017-04-20 16:50:26.945043172 +0700
@@ -157,7 +157,9 @@
 	{ERR_PACK(ERR_LIB_FIPS,0,0),		"FIPS routines"},
 	{ERR_PACK(ERR_LIB_CMS,0,0),		"CMS routines"},
 	{ERR_PACK(ERR_LIB_HMAC,0,0),		"HMAC routines"},
-	{ERR_PACK(ERR_LIB_GOST,0,0),		"GOST routines"},
+  {ERR_PACK(ERR_LIB_GOST,0,0),		"GOST routines"},
+  {ERR_PACK(ERR_LIB_CMP,0,0)		,"CMP routines"},
+  {ERR_PACK(ERR_LIB_CRMF,0,0)		,"CRMF routines"},
 	{0, NULL},
 };
 
@@ -199,7 +201,10 @@
 	{ERR_R_DSO_LIB,				"DSO lib"},
 	{ERR_R_ENGINE_LIB,			"ENGINE lib"},
 	{ERR_R_OCSP_LIB,			"OCSP lib"},
-	{ERR_R_TS_LIB,				"TS lib"},
+  {ERR_R_TS_LIB,				"TS lib"},
+
+  {ERR_R_CMP_LIB				,"CMP lib"},
+  {ERR_R_CRMF_LIB				,"CRMF lib"},
 
 	{ERR_R_NESTED_ASN1_ERROR,		"nested asn1 error"},
 	{ERR_R_BAD_ASN1_OBJECT_HEADER,		"bad asn1 object header"},
